
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model AssetHistory
 * 
 */
export type AssetHistory = $Result.DefaultSelection<Prisma.$AssetHistoryPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Contract
 * 
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model departments
 * 
 */
export type departments = $Result.DefaultSelection<Prisma.$departmentsPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model employee_roles
 * 
 */
export type employee_roles = $Result.DefaultSelection<Prisma.$employee_rolesPayload>
/**
 * Model employees
 * 
 */
export type employees = $Result.DefaultSelection<Prisma.$employeesPayload>
/**
 * Model InventoryCategory
 * 
 */
export type InventoryCategory = $Result.DefaultSelection<Prisma.$InventoryCategoryPayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model InventorySupplier
 * 
 */
export type InventorySupplier = $Result.DefaultSelection<Prisma.$InventorySupplierPayload>
/**
 * Model InventoryTransaction
 * 
 */
export type InventoryTransaction = $Result.DefaultSelection<Prisma.$InventoryTransactionPayload>
/**
 * Model it_departments
 * 
 */
export type it_departments = $Result.DefaultSelection<Prisma.$it_departmentsPayload>
/**
 * Model it_employee_roles
 * 
 */
export type it_employee_roles = $Result.DefaultSelection<Prisma.$it_employee_rolesPayload>
/**
 * Model it_employees
 * 
 */
export type it_employees = $Result.DefaultSelection<Prisma.$it_employeesPayload>
/**
 * Model it_roles
 * 
 */
export type it_roles = $Result.DefaultSelection<Prisma.$it_rolesPayload>
/**
 * Model KnowledgeBase
 * 
 */
export type KnowledgeBase = $Result.DefaultSelection<Prisma.$KnowledgeBasePayload>
/**
 * Model License
 * 
 */
export type License = $Result.DefaultSelection<Prisma.$LicensePayload>
/**
 * Model Monitor
 * 
 */
export type Monitor = $Result.DefaultSelection<Prisma.$MonitorPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model TicketAttachment
 * 
 */
export type TicketAttachment = $Result.DefaultSelection<Prisma.$TicketAttachmentPayload>
/**
 * Model TicketComment
 * 
 */
export type TicketComment = $Result.DefaultSelection<Prisma.$TicketCommentPayload>
/**
 * Model TicketHistory
 * 
 */
export type TicketHistory = $Result.DefaultSelection<Prisma.$TicketHistoryPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model webmes_User
 * 
 */
export type webmes_User = $Result.DefaultSelection<Prisma.$webmes_UserPayload>
/**
 * Model webmes_Role
 * 
 */
export type webmes_Role = $Result.DefaultSelection<Prisma.$webmes_RolePayload>
/**
 * Model webmes_Permission
 * 
 */
export type webmes_Permission = $Result.DefaultSelection<Prisma.$webmes_PermissionPayload>
/**
 * Model webmes_UserRole
 * 
 */
export type webmes_UserRole = $Result.DefaultSelection<Prisma.$webmes_UserRolePayload>
/**
 * Model webmes_RolePermission
 * 
 */
export type webmes_RolePermission = $Result.DefaultSelection<Prisma.$webmes_RolePermissionPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Assets
 * const assets = await prisma.asset.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Assets
   * const assets = await prisma.asset.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs>;

  /**
   * `prisma.assetHistory`: Exposes CRUD operations for the **AssetHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetHistories
    * const assetHistories = await prisma.assetHistory.findMany()
    * ```
    */
  get assetHistory(): Prisma.AssetHistoryDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs>;

  /**
   * `prisma.departments`: Exposes CRUD operations for the **departments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.departments.findMany()
    * ```
    */
  get departments(): Prisma.departmentsDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.employee_roles`: Exposes CRUD operations for the **employee_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employee_roles
    * const employee_roles = await prisma.employee_roles.findMany()
    * ```
    */
  get employee_roles(): Prisma.employee_rolesDelegate<ExtArgs>;

  /**
   * `prisma.employees`: Exposes CRUD operations for the **employees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employees.findMany()
    * ```
    */
  get employees(): Prisma.employeesDelegate<ExtArgs>;

  /**
   * `prisma.inventoryCategory`: Exposes CRUD operations for the **InventoryCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryCategories
    * const inventoryCategories = await prisma.inventoryCategory.findMany()
    * ```
    */
  get inventoryCategory(): Prisma.InventoryCategoryDelegate<ExtArgs>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs>;

  /**
   * `prisma.inventorySupplier`: Exposes CRUD operations for the **InventorySupplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventorySuppliers
    * const inventorySuppliers = await prisma.inventorySupplier.findMany()
    * ```
    */
  get inventorySupplier(): Prisma.InventorySupplierDelegate<ExtArgs>;

  /**
   * `prisma.inventoryTransaction`: Exposes CRUD operations for the **InventoryTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryTransactions
    * const inventoryTransactions = await prisma.inventoryTransaction.findMany()
    * ```
    */
  get inventoryTransaction(): Prisma.InventoryTransactionDelegate<ExtArgs>;

  /**
   * `prisma.it_departments`: Exposes CRUD operations for the **it_departments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more It_departments
    * const it_departments = await prisma.it_departments.findMany()
    * ```
    */
  get it_departments(): Prisma.it_departmentsDelegate<ExtArgs>;

  /**
   * `prisma.it_employee_roles`: Exposes CRUD operations for the **it_employee_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more It_employee_roles
    * const it_employee_roles = await prisma.it_employee_roles.findMany()
    * ```
    */
  get it_employee_roles(): Prisma.it_employee_rolesDelegate<ExtArgs>;

  /**
   * `prisma.it_employees`: Exposes CRUD operations for the **it_employees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more It_employees
    * const it_employees = await prisma.it_employees.findMany()
    * ```
    */
  get it_employees(): Prisma.it_employeesDelegate<ExtArgs>;

  /**
   * `prisma.it_roles`: Exposes CRUD operations for the **it_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more It_roles
    * const it_roles = await prisma.it_roles.findMany()
    * ```
    */
  get it_roles(): Prisma.it_rolesDelegate<ExtArgs>;

  /**
   * `prisma.knowledgeBase`: Exposes CRUD operations for the **KnowledgeBase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeBases
    * const knowledgeBases = await prisma.knowledgeBase.findMany()
    * ```
    */
  get knowledgeBase(): Prisma.KnowledgeBaseDelegate<ExtArgs>;

  /**
   * `prisma.license`: Exposes CRUD operations for the **License** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Licenses
    * const licenses = await prisma.license.findMany()
    * ```
    */
  get license(): Prisma.LicenseDelegate<ExtArgs>;

  /**
   * `prisma.monitor`: Exposes CRUD operations for the **Monitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monitors
    * const monitors = await prisma.monitor.findMany()
    * ```
    */
  get monitor(): Prisma.MonitorDelegate<ExtArgs>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs>;

  /**
   * `prisma.ticketAttachment`: Exposes CRUD operations for the **TicketAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketAttachments
    * const ticketAttachments = await prisma.ticketAttachment.findMany()
    * ```
    */
  get ticketAttachment(): Prisma.TicketAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.ticketComment`: Exposes CRUD operations for the **TicketComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketComments
    * const ticketComments = await prisma.ticketComment.findMany()
    * ```
    */
  get ticketComment(): Prisma.TicketCommentDelegate<ExtArgs>;

  /**
   * `prisma.ticketHistory`: Exposes CRUD operations for the **TicketHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketHistories
    * const ticketHistories = await prisma.ticketHistory.findMany()
    * ```
    */
  get ticketHistory(): Prisma.TicketHistoryDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs>;

  /**
   * `prisma.webmes_User`: Exposes CRUD operations for the **webmes_User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webmes_Users
    * const webmes_Users = await prisma.webmes_User.findMany()
    * ```
    */
  get webmes_User(): Prisma.webmes_UserDelegate<ExtArgs>;

  /**
   * `prisma.webmes_Role`: Exposes CRUD operations for the **webmes_Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webmes_Roles
    * const webmes_Roles = await prisma.webmes_Role.findMany()
    * ```
    */
  get webmes_Role(): Prisma.webmes_RoleDelegate<ExtArgs>;

  /**
   * `prisma.webmes_Permission`: Exposes CRUD operations for the **webmes_Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webmes_Permissions
    * const webmes_Permissions = await prisma.webmes_Permission.findMany()
    * ```
    */
  get webmes_Permission(): Prisma.webmes_PermissionDelegate<ExtArgs>;

  /**
   * `prisma.webmes_UserRole`: Exposes CRUD operations for the **webmes_UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webmes_UserRoles
    * const webmes_UserRoles = await prisma.webmes_UserRole.findMany()
    * ```
    */
  get webmes_UserRole(): Prisma.webmes_UserRoleDelegate<ExtArgs>;

  /**
   * `prisma.webmes_RolePermission`: Exposes CRUD operations for the **webmes_RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webmes_RolePermissions
    * const webmes_RolePermissions = await prisma.webmes_RolePermission.findMany()
    * ```
    */
  get webmes_RolePermission(): Prisma.webmes_RolePermissionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Asset: 'Asset',
    AssetHistory: 'AssetHistory',
    AuditLog: 'AuditLog',
    Contract: 'Contract',
    departments: 'departments',
    Document: 'Document',
    employee_roles: 'employee_roles',
    employees: 'employees',
    InventoryCategory: 'InventoryCategory',
    InventoryItem: 'InventoryItem',
    InventorySupplier: 'InventorySupplier',
    InventoryTransaction: 'InventoryTransaction',
    it_departments: 'it_departments',
    it_employee_roles: 'it_employee_roles',
    it_employees: 'it_employees',
    it_roles: 'it_roles',
    KnowledgeBase: 'KnowledgeBase',
    License: 'License',
    Monitor: 'Monitor',
    roles: 'roles',
    Ticket: 'Ticket',
    TicketAttachment: 'TicketAttachment',
    TicketComment: 'TicketComment',
    TicketHistory: 'TicketHistory',
    User: 'User',
    Vendor: 'Vendor',
    webmes_User: 'webmes_User',
    webmes_Role: 'webmes_Role',
    webmes_Permission: 'webmes_Permission',
    webmes_UserRole: 'webmes_UserRole',
    webmes_RolePermission: 'webmes_RolePermission'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "asset" | "assetHistory" | "auditLog" | "contract" | "departments" | "document" | "employee_roles" | "employees" | "inventoryCategory" | "inventoryItem" | "inventorySupplier" | "inventoryTransaction" | "it_departments" | "it_employee_roles" | "it_employees" | "it_roles" | "knowledgeBase" | "license" | "monitor" | "roles" | "ticket" | "ticketAttachment" | "ticketComment" | "ticketHistory" | "user" | "vendor" | "webmes_User" | "webmes_Role" | "webmes_Permission" | "webmes_UserRole" | "webmes_RolePermission"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      AssetHistory: {
        payload: Prisma.$AssetHistoryPayload<ExtArgs>
        fields: Prisma.AssetHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>
          }
          findFirst: {
            args: Prisma.AssetHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>
          }
          findMany: {
            args: Prisma.AssetHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>[]
          }
          create: {
            args: Prisma.AssetHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>
          }
          createMany: {
            args: Prisma.AssetHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AssetHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>
          }
          update: {
            args: Prisma.AssetHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>
          }
          deleteMany: {
            args: Prisma.AssetHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssetHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetHistoryPayload>
          }
          aggregate: {
            args: Prisma.AssetHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetHistory>
          }
          groupBy: {
            args: Prisma.AssetHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<AssetHistoryCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      departments: {
        payload: Prisma.$departmentsPayload<ExtArgs>
        fields: Prisma.departmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.departmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.departmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          findFirst: {
            args: Prisma.departmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.departmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          findMany: {
            args: Prisma.departmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>[]
          }
          create: {
            args: Prisma.departmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          createMany: {
            args: Prisma.departmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.departmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          update: {
            args: Prisma.departmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          deleteMany: {
            args: Prisma.departmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.departmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.departmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          aggregate: {
            args: Prisma.DepartmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartments>
          }
          groupBy: {
            args: Prisma.departmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.departmentsCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentsCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      employee_roles: {
        payload: Prisma.$employee_rolesPayload<ExtArgs>
        fields: Prisma.employee_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employee_rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employee_rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolesPayload>
          }
          findFirst: {
            args: Prisma.employee_rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employee_rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolesPayload>
          }
          findMany: {
            args: Prisma.employee_rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolesPayload>[]
          }
          create: {
            args: Prisma.employee_rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolesPayload>
          }
          createMany: {
            args: Prisma.employee_rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.employee_rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolesPayload>
          }
          update: {
            args: Prisma.employee_rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolesPayload>
          }
          deleteMany: {
            args: Prisma.employee_rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employee_rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.employee_rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolesPayload>
          }
          aggregate: {
            args: Prisma.Employee_rolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee_roles>
          }
          groupBy: {
            args: Prisma.employee_rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Employee_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.employee_rolesCountArgs<ExtArgs>
            result: $Utils.Optional<Employee_rolesCountAggregateOutputType> | number
          }
        }
      }
      employees: {
        payload: Prisma.$employeesPayload<ExtArgs>
        fields: Prisma.employeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          findFirst: {
            args: Prisma.employeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          findMany: {
            args: Prisma.employeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>[]
          }
          create: {
            args: Prisma.employeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          createMany: {
            args: Prisma.employeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.employeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          update: {
            args: Prisma.employeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          deleteMany: {
            args: Prisma.employeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.employeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          aggregate: {
            args: Prisma.EmployeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployees>
          }
          groupBy: {
            args: Prisma.employeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.employeesCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeesCountAggregateOutputType> | number
          }
        }
      }
      InventoryCategory: {
        payload: Prisma.$InventoryCategoryPayload<ExtArgs>
        fields: Prisma.InventoryCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCategoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCategoryPayload>
          }
          findMany: {
            args: Prisma.InventoryCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCategoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCategoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCategoryPayload>
          }
          update: {
            args: Prisma.InventoryCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCategoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCategoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryCategory>
          }
          groupBy: {
            args: Prisma.InventoryCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCategoryCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      InventorySupplier: {
        payload: Prisma.$InventorySupplierPayload<ExtArgs>
        fields: Prisma.InventorySupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventorySupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventorySupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySupplierPayload>
          }
          findFirst: {
            args: Prisma.InventorySupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventorySupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySupplierPayload>
          }
          findMany: {
            args: Prisma.InventorySupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySupplierPayload>[]
          }
          create: {
            args: Prisma.InventorySupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySupplierPayload>
          }
          createMany: {
            args: Prisma.InventorySupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventorySupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySupplierPayload>
          }
          update: {
            args: Prisma.InventorySupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySupplierPayload>
          }
          deleteMany: {
            args: Prisma.InventorySupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventorySupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventorySupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySupplierPayload>
          }
          aggregate: {
            args: Prisma.InventorySupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventorySupplier>
          }
          groupBy: {
            args: Prisma.InventorySupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventorySupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventorySupplierCountArgs<ExtArgs>
            result: $Utils.Optional<InventorySupplierCountAggregateOutputType> | number
          }
        }
      }
      InventoryTransaction: {
        payload: Prisma.$InventoryTransactionPayload<ExtArgs>
        fields: Prisma.InventoryTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          findFirst: {
            args: Prisma.InventoryTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          findMany: {
            args: Prisma.InventoryTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
          }
          create: {
            args: Prisma.InventoryTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          createMany: {
            args: Prisma.InventoryTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          update: {
            args: Prisma.InventoryTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          deleteMany: {
            args: Prisma.InventoryTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          aggregate: {
            args: Prisma.InventoryTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryTransaction>
          }
          groupBy: {
            args: Prisma.InventoryTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryTransactionCountAggregateOutputType> | number
          }
        }
      }
      it_departments: {
        payload: Prisma.$it_departmentsPayload<ExtArgs>
        fields: Prisma.it_departmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.it_departmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_departmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.it_departmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_departmentsPayload>
          }
          findFirst: {
            args: Prisma.it_departmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_departmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.it_departmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_departmentsPayload>
          }
          findMany: {
            args: Prisma.it_departmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_departmentsPayload>[]
          }
          create: {
            args: Prisma.it_departmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_departmentsPayload>
          }
          createMany: {
            args: Prisma.it_departmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.it_departmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_departmentsPayload>
          }
          update: {
            args: Prisma.it_departmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_departmentsPayload>
          }
          deleteMany: {
            args: Prisma.it_departmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.it_departmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.it_departmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_departmentsPayload>
          }
          aggregate: {
            args: Prisma.It_departmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIt_departments>
          }
          groupBy: {
            args: Prisma.it_departmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<It_departmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.it_departmentsCountArgs<ExtArgs>
            result: $Utils.Optional<It_departmentsCountAggregateOutputType> | number
          }
        }
      }
      it_employee_roles: {
        payload: Prisma.$it_employee_rolesPayload<ExtArgs>
        fields: Prisma.it_employee_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.it_employee_rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employee_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.it_employee_rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employee_rolesPayload>
          }
          findFirst: {
            args: Prisma.it_employee_rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employee_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.it_employee_rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employee_rolesPayload>
          }
          findMany: {
            args: Prisma.it_employee_rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employee_rolesPayload>[]
          }
          create: {
            args: Prisma.it_employee_rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employee_rolesPayload>
          }
          createMany: {
            args: Prisma.it_employee_rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.it_employee_rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employee_rolesPayload>
          }
          update: {
            args: Prisma.it_employee_rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employee_rolesPayload>
          }
          deleteMany: {
            args: Prisma.it_employee_rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.it_employee_rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.it_employee_rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employee_rolesPayload>
          }
          aggregate: {
            args: Prisma.It_employee_rolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIt_employee_roles>
          }
          groupBy: {
            args: Prisma.it_employee_rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<It_employee_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.it_employee_rolesCountArgs<ExtArgs>
            result: $Utils.Optional<It_employee_rolesCountAggregateOutputType> | number
          }
        }
      }
      it_employees: {
        payload: Prisma.$it_employeesPayload<ExtArgs>
        fields: Prisma.it_employeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.it_employeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.it_employeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employeesPayload>
          }
          findFirst: {
            args: Prisma.it_employeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.it_employeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employeesPayload>
          }
          findMany: {
            args: Prisma.it_employeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employeesPayload>[]
          }
          create: {
            args: Prisma.it_employeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employeesPayload>
          }
          createMany: {
            args: Prisma.it_employeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.it_employeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employeesPayload>
          }
          update: {
            args: Prisma.it_employeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employeesPayload>
          }
          deleteMany: {
            args: Prisma.it_employeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.it_employeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.it_employeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_employeesPayload>
          }
          aggregate: {
            args: Prisma.It_employeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIt_employees>
          }
          groupBy: {
            args: Prisma.it_employeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<It_employeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.it_employeesCountArgs<ExtArgs>
            result: $Utils.Optional<It_employeesCountAggregateOutputType> | number
          }
        }
      }
      it_roles: {
        payload: Prisma.$it_rolesPayload<ExtArgs>
        fields: Prisma.it_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.it_rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.it_rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_rolesPayload>
          }
          findFirst: {
            args: Prisma.it_rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.it_rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_rolesPayload>
          }
          findMany: {
            args: Prisma.it_rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_rolesPayload>[]
          }
          create: {
            args: Prisma.it_rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_rolesPayload>
          }
          createMany: {
            args: Prisma.it_rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.it_rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_rolesPayload>
          }
          update: {
            args: Prisma.it_rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_rolesPayload>
          }
          deleteMany: {
            args: Prisma.it_rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.it_rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.it_rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$it_rolesPayload>
          }
          aggregate: {
            args: Prisma.It_rolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIt_roles>
          }
          groupBy: {
            args: Prisma.it_rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<It_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.it_rolesCountArgs<ExtArgs>
            result: $Utils.Optional<It_rolesCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeBase: {
        payload: Prisma.$KnowledgeBasePayload<ExtArgs>
        fields: Prisma.KnowledgeBaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeBaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeBaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          findFirst: {
            args: Prisma.KnowledgeBaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeBaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          findMany: {
            args: Prisma.KnowledgeBaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>[]
          }
          create: {
            args: Prisma.KnowledgeBaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          createMany: {
            args: Prisma.KnowledgeBaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KnowledgeBaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          update: {
            args: Prisma.KnowledgeBaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeBaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeBaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KnowledgeBaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          aggregate: {
            args: Prisma.KnowledgeBaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeBase>
          }
          groupBy: {
            args: Prisma.KnowledgeBaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeBaseCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseCountAggregateOutputType> | number
          }
        }
      }
      License: {
        payload: Prisma.$LicensePayload<ExtArgs>
        fields: Prisma.LicenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LicenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LicenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          findFirst: {
            args: Prisma.LicenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LicenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          findMany: {
            args: Prisma.LicenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          create: {
            args: Prisma.LicenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          createMany: {
            args: Prisma.LicenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LicenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          update: {
            args: Prisma.LicenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          deleteMany: {
            args: Prisma.LicenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LicenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LicenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          aggregate: {
            args: Prisma.LicenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLicense>
          }
          groupBy: {
            args: Prisma.LicenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<LicenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.LicenseCountArgs<ExtArgs>
            result: $Utils.Optional<LicenseCountAggregateOutputType> | number
          }
        }
      }
      Monitor: {
        payload: Prisma.$MonitorPayload<ExtArgs>
        fields: Prisma.MonitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>
          }
          findFirst: {
            args: Prisma.MonitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>
          }
          findMany: {
            args: Prisma.MonitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>[]
          }
          create: {
            args: Prisma.MonitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>
          }
          createMany: {
            args: Prisma.MonitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MonitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>
          }
          update: {
            args: Prisma.MonitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>
          }
          deleteMany: {
            args: Prisma.MonitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MonitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitorPayload>
          }
          aggregate: {
            args: Prisma.MonitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonitor>
          }
          groupBy: {
            args: Prisma.MonitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonitorCountArgs<ExtArgs>
            result: $Utils.Optional<MonitorCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      TicketAttachment: {
        payload: Prisma.$TicketAttachmentPayload<ExtArgs>
        fields: Prisma.TicketAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          findFirst: {
            args: Prisma.TicketAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          findMany: {
            args: Prisma.TicketAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
          }
          create: {
            args: Prisma.TicketAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          createMany: {
            args: Prisma.TicketAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          update: {
            args: Prisma.TicketAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.TicketAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          aggregate: {
            args: Prisma.TicketAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketAttachment>
          }
          groupBy: {
            args: Prisma.TicketAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketAttachmentCountAggregateOutputType> | number
          }
        }
      }
      TicketComment: {
        payload: Prisma.$TicketCommentPayload<ExtArgs>
        fields: Prisma.TicketCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findFirst: {
            args: Prisma.TicketCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findMany: {
            args: Prisma.TicketCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          create: {
            args: Prisma.TicketCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          createMany: {
            args: Prisma.TicketCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          update: {
            args: Prisma.TicketCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          deleteMany: {
            args: Prisma.TicketCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          aggregate: {
            args: Prisma.TicketCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketComment>
          }
          groupBy: {
            args: Prisma.TicketCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCommentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentCountAggregateOutputType> | number
          }
        }
      }
      TicketHistory: {
        payload: Prisma.$TicketHistoryPayload<ExtArgs>
        fields: Prisma.TicketHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>
          }
          findFirst: {
            args: Prisma.TicketHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>
          }
          findMany: {
            args: Prisma.TicketHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>[]
          }
          create: {
            args: Prisma.TicketHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>
          }
          createMany: {
            args: Prisma.TicketHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>
          }
          update: {
            args: Prisma.TicketHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>
          }
          deleteMany: {
            args: Prisma.TicketHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>
          }
          aggregate: {
            args: Prisma.TicketHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketHistory>
          }
          groupBy: {
            args: Prisma.TicketHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<TicketHistoryCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      webmes_User: {
        payload: Prisma.$webmes_UserPayload<ExtArgs>
        fields: Prisma.webmes_UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.webmes_UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.webmes_UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserPayload>
          }
          findFirst: {
            args: Prisma.webmes_UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.webmes_UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserPayload>
          }
          findMany: {
            args: Prisma.webmes_UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserPayload>[]
          }
          create: {
            args: Prisma.webmes_UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserPayload>
          }
          createMany: {
            args: Prisma.webmes_UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.webmes_UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserPayload>
          }
          update: {
            args: Prisma.webmes_UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserPayload>
          }
          deleteMany: {
            args: Prisma.webmes_UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.webmes_UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.webmes_UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserPayload>
          }
          aggregate: {
            args: Prisma.Webmes_UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebmes_User>
          }
          groupBy: {
            args: Prisma.webmes_UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<Webmes_UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.webmes_UserCountArgs<ExtArgs>
            result: $Utils.Optional<Webmes_UserCountAggregateOutputType> | number
          }
        }
      }
      webmes_Role: {
        payload: Prisma.$webmes_RolePayload<ExtArgs>
        fields: Prisma.webmes_RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.webmes_RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.webmes_RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePayload>
          }
          findFirst: {
            args: Prisma.webmes_RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.webmes_RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePayload>
          }
          findMany: {
            args: Prisma.webmes_RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePayload>[]
          }
          create: {
            args: Prisma.webmes_RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePayload>
          }
          createMany: {
            args: Prisma.webmes_RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.webmes_RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePayload>
          }
          update: {
            args: Prisma.webmes_RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePayload>
          }
          deleteMany: {
            args: Prisma.webmes_RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.webmes_RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.webmes_RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePayload>
          }
          aggregate: {
            args: Prisma.Webmes_RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebmes_Role>
          }
          groupBy: {
            args: Prisma.webmes_RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Webmes_RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.webmes_RoleCountArgs<ExtArgs>
            result: $Utils.Optional<Webmes_RoleCountAggregateOutputType> | number
          }
        }
      }
      webmes_Permission: {
        payload: Prisma.$webmes_PermissionPayload<ExtArgs>
        fields: Prisma.webmes_PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.webmes_PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.webmes_PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_PermissionPayload>
          }
          findFirst: {
            args: Prisma.webmes_PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.webmes_PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_PermissionPayload>
          }
          findMany: {
            args: Prisma.webmes_PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_PermissionPayload>[]
          }
          create: {
            args: Prisma.webmes_PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_PermissionPayload>
          }
          createMany: {
            args: Prisma.webmes_PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.webmes_PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_PermissionPayload>
          }
          update: {
            args: Prisma.webmes_PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_PermissionPayload>
          }
          deleteMany: {
            args: Prisma.webmes_PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.webmes_PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.webmes_PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_PermissionPayload>
          }
          aggregate: {
            args: Prisma.Webmes_PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebmes_Permission>
          }
          groupBy: {
            args: Prisma.webmes_PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Webmes_PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.webmes_PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<Webmes_PermissionCountAggregateOutputType> | number
          }
        }
      }
      webmes_UserRole: {
        payload: Prisma.$webmes_UserRolePayload<ExtArgs>
        fields: Prisma.webmes_UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.webmes_UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.webmes_UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserRolePayload>
          }
          findFirst: {
            args: Prisma.webmes_UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.webmes_UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserRolePayload>
          }
          findMany: {
            args: Prisma.webmes_UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserRolePayload>[]
          }
          create: {
            args: Prisma.webmes_UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserRolePayload>
          }
          createMany: {
            args: Prisma.webmes_UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.webmes_UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserRolePayload>
          }
          update: {
            args: Prisma.webmes_UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserRolePayload>
          }
          deleteMany: {
            args: Prisma.webmes_UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.webmes_UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.webmes_UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_UserRolePayload>
          }
          aggregate: {
            args: Prisma.Webmes_UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebmes_UserRole>
          }
          groupBy: {
            args: Prisma.webmes_UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Webmes_UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.webmes_UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<Webmes_UserRoleCountAggregateOutputType> | number
          }
        }
      }
      webmes_RolePermission: {
        payload: Prisma.$webmes_RolePermissionPayload<ExtArgs>
        fields: Prisma.webmes_RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.webmes_RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.webmes_RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.webmes_RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.webmes_RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePermissionPayload>
          }
          findMany: {
            args: Prisma.webmes_RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePermissionPayload>[]
          }
          create: {
            args: Prisma.webmes_RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePermissionPayload>
          }
          createMany: {
            args: Prisma.webmes_RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.webmes_RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePermissionPayload>
          }
          update: {
            args: Prisma.webmes_RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.webmes_RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.webmes_RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.webmes_RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webmes_RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.Webmes_RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebmes_RolePermission>
          }
          groupBy: {
            args: Prisma.webmes_RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Webmes_RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.webmes_RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<Webmes_RolePermissionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AssetCountOutputType
   */

  export type AssetCountOutputType = {
    AssetHistory: number
    License: number
    Ticket: number
    Contract: number
  }

  export type AssetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AssetHistory?: boolean | AssetCountOutputTypeCountAssetHistoryArgs
    License?: boolean | AssetCountOutputTypeCountLicenseArgs
    Ticket?: boolean | AssetCountOutputTypeCountTicketArgs
    Contract?: boolean | AssetCountOutputTypeCountContractArgs
  }

  // Custom InputTypes
  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCountOutputType
     */
    select?: AssetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountAssetHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetHistoryWhereInput
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountLicenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseWhereInput
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }


  /**
   * Count Type ContractCountOutputType
   */

  export type ContractCountOutputType = {
    Asset: number
  }

  export type ContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Asset?: boolean | ContractCountOutputTypeCountAssetArgs
  }

  // Custom InputTypes
  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractCountOutputType
     */
    select?: ContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }


  /**
   * Count Type DepartmentsCountOutputType
   */

  export type DepartmentsCountOutputType = {
    employees: number
  }

  export type DepartmentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | DepartmentsCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * DepartmentsCountOutputType without action
   */
  export type DepartmentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentsCountOutputType
     */
    select?: DepartmentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentsCountOutputType without action
   */
  export type DepartmentsCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeesWhereInput
  }


  /**
   * Count Type EmployeesCountOutputType
   */

  export type EmployeesCountOutputType = {
    employee_roles: number
  }

  export type EmployeesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee_roles?: boolean | EmployeesCountOutputTypeCountEmployee_rolesArgs
  }

  // Custom InputTypes
  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesCountOutputType
     */
    select?: EmployeesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountEmployee_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_rolesWhereInput
  }


  /**
   * Count Type InventoryCategoryCountOutputType
   */

  export type InventoryCategoryCountOutputType = {
    InventoryItem: number
  }

  export type InventoryCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InventoryItem?: boolean | InventoryCategoryCountOutputTypeCountInventoryItemArgs
  }

  // Custom InputTypes
  /**
   * InventoryCategoryCountOutputType without action
   */
  export type InventoryCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCategoryCountOutputType
     */
    select?: InventoryCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryCategoryCountOutputType without action
   */
  export type InventoryCategoryCountOutputTypeCountInventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }


  /**
   * Count Type InventoryItemCountOutputType
   */

  export type InventoryItemCountOutputType = {
    InventoryTransaction: number
  }

  export type InventoryItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InventoryTransaction?: boolean | InventoryItemCountOutputTypeCountInventoryTransactionArgs
  }

  // Custom InputTypes
  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItemCountOutputType
     */
    select?: InventoryItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountInventoryTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
  }


  /**
   * Count Type InventorySupplierCountOutputType
   */

  export type InventorySupplierCountOutputType = {
    InventoryItem: number
  }

  export type InventorySupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InventoryItem?: boolean | InventorySupplierCountOutputTypeCountInventoryItemArgs
  }

  // Custom InputTypes
  /**
   * InventorySupplierCountOutputType without action
   */
  export type InventorySupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySupplierCountOutputType
     */
    select?: InventorySupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventorySupplierCountOutputType without action
   */
  export type InventorySupplierCountOutputTypeCountInventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }


  /**
   * Count Type It_departmentsCountOutputType
   */

  export type It_departmentsCountOutputType = {
    it_employees: number
  }

  export type It_departmentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    it_employees?: boolean | It_departmentsCountOutputTypeCountIt_employeesArgs
  }

  // Custom InputTypes
  /**
   * It_departmentsCountOutputType without action
   */
  export type It_departmentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the It_departmentsCountOutputType
     */
    select?: It_departmentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * It_departmentsCountOutputType without action
   */
  export type It_departmentsCountOutputTypeCountIt_employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: it_employeesWhereInput
  }


  /**
   * Count Type It_employeesCountOutputType
   */

  export type It_employeesCountOutputType = {
    it_employee_roles: number
  }

  export type It_employeesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    it_employee_roles?: boolean | It_employeesCountOutputTypeCountIt_employee_rolesArgs
  }

  // Custom InputTypes
  /**
   * It_employeesCountOutputType without action
   */
  export type It_employeesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the It_employeesCountOutputType
     */
    select?: It_employeesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * It_employeesCountOutputType without action
   */
  export type It_employeesCountOutputTypeCountIt_employee_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: it_employee_rolesWhereInput
  }


  /**
   * Count Type It_rolesCountOutputType
   */

  export type It_rolesCountOutputType = {
    it_employee_roles: number
  }

  export type It_rolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    it_employee_roles?: boolean | It_rolesCountOutputTypeCountIt_employee_rolesArgs
  }

  // Custom InputTypes
  /**
   * It_rolesCountOutputType without action
   */
  export type It_rolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the It_rolesCountOutputType
     */
    select?: It_rolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * It_rolesCountOutputType without action
   */
  export type It_rolesCountOutputTypeCountIt_employee_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: it_employee_rolesWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    employee_roles: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee_roles?: boolean | RolesCountOutputTypeCountEmployee_rolesArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountEmployee_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_rolesWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    KnowledgeBase: number
    TicketAttachment: number
    TicketComment: number
    TicketHistory: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KnowledgeBase?: boolean | TicketCountOutputTypeCountKnowledgeBaseArgs
    TicketAttachment?: boolean | TicketCountOutputTypeCountTicketAttachmentArgs
    TicketComment?: boolean | TicketCountOutputTypeCountTicketCommentArgs
    TicketHistory?: boolean | TicketCountOutputTypeCountTicketHistoryArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountKnowledgeBaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountTicketAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountTicketCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountTicketHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketHistoryWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Asset: number
    AssetHistory_AssetHistory_newOwnerIdToUser: number
    AssetHistory_AssetHistory_oldOwnerIdToUser: number
    AuditLog: number
    Document: number
    InventoryTransaction: number
    KnowledgeBase: number
    Ticket_Ticket_assignedToIdToUser: number
    Ticket_Ticket_requestedByIdToUser: number
    TicketAttachment: number
    TicketComment: number
    TicketHistory: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Asset?: boolean | UserCountOutputTypeCountAssetArgs
    AssetHistory_AssetHistory_newOwnerIdToUser?: boolean | UserCountOutputTypeCountAssetHistory_AssetHistory_newOwnerIdToUserArgs
    AssetHistory_AssetHistory_oldOwnerIdToUser?: boolean | UserCountOutputTypeCountAssetHistory_AssetHistory_oldOwnerIdToUserArgs
    AuditLog?: boolean | UserCountOutputTypeCountAuditLogArgs
    Document?: boolean | UserCountOutputTypeCountDocumentArgs
    InventoryTransaction?: boolean | UserCountOutputTypeCountInventoryTransactionArgs
    KnowledgeBase?: boolean | UserCountOutputTypeCountKnowledgeBaseArgs
    Ticket_Ticket_assignedToIdToUser?: boolean | UserCountOutputTypeCountTicket_Ticket_assignedToIdToUserArgs
    Ticket_Ticket_requestedByIdToUser?: boolean | UserCountOutputTypeCountTicket_Ticket_requestedByIdToUserArgs
    TicketAttachment?: boolean | UserCountOutputTypeCountTicketAttachmentArgs
    TicketComment?: boolean | UserCountOutputTypeCountTicketCommentArgs
    TicketHistory?: boolean | UserCountOutputTypeCountTicketHistoryArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssetHistory_AssetHistory_newOwnerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssetHistory_AssetHistory_oldOwnerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountKnowledgeBaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicket_Ticket_assignedToIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicket_Ticket_requestedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketHistoryWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    Contract: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Contract?: boolean | VendorCountOutputTypeCountContractArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }


  /**
   * Count Type Webmes_UserCountOutputType
   */

  export type Webmes_UserCountOutputType = {
    roles: number
  }

  export type Webmes_UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Webmes_UserCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * Webmes_UserCountOutputType without action
   */
  export type Webmes_UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webmes_UserCountOutputType
     */
    select?: Webmes_UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Webmes_UserCountOutputType without action
   */
  export type Webmes_UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: webmes_UserRoleWhereInput
  }


  /**
   * Count Type Webmes_RoleCountOutputType
   */

  export type Webmes_RoleCountOutputType = {
    permissions: number
    users: number
  }

  export type Webmes_RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | Webmes_RoleCountOutputTypeCountPermissionsArgs
    users?: boolean | Webmes_RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * Webmes_RoleCountOutputType without action
   */
  export type Webmes_RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webmes_RoleCountOutputType
     */
    select?: Webmes_RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Webmes_RoleCountOutputType without action
   */
  export type Webmes_RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: webmes_RolePermissionWhereInput
  }

  /**
   * Webmes_RoleCountOutputType without action
   */
  export type Webmes_RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: webmes_UserRoleWhereInput
  }


  /**
   * Count Type Webmes_PermissionCountOutputType
   */

  export type Webmes_PermissionCountOutputType = {
    roles: number
  }

  export type Webmes_PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Webmes_PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * Webmes_PermissionCountOutputType without action
   */
  export type Webmes_PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webmes_PermissionCountOutputType
     */
    select?: Webmes_PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Webmes_PermissionCountOutputType without action
   */
  export type Webmes_PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: webmes_RolePermissionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
  }

  export type AssetSumAggregateOutputType = {
    id: number | null
    ownerId: number | null
  }

  export type AssetMinAggregateOutputType = {
    id: number | null
    name: string | null
    serialNumber: string | null
    assetTag: string | null
    type: string | null
    brand: string | null
    model: string | null
    spec: string | null
    purchaseDate: Date | null
    warrantyUntil: Date | null
    location: string | null
    status: string | null
    ownerId: number | null
  }

  export type AssetMaxAggregateOutputType = {
    id: number | null
    name: string | null
    serialNumber: string | null
    assetTag: string | null
    type: string | null
    brand: string | null
    model: string | null
    spec: string | null
    purchaseDate: Date | null
    warrantyUntil: Date | null
    location: string | null
    status: string | null
    ownerId: number | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    name: number
    serialNumber: number
    assetTag: number
    type: number
    brand: number
    model: number
    spec: number
    purchaseDate: number
    warrantyUntil: number
    location: number
    status: number
    ownerId: number
    _all: number
  }


  export type AssetAvgAggregateInputType = {
    id?: true
    ownerId?: true
  }

  export type AssetSumAggregateInputType = {
    id?: true
    ownerId?: true
  }

  export type AssetMinAggregateInputType = {
    id?: true
    name?: true
    serialNumber?: true
    assetTag?: true
    type?: true
    brand?: true
    model?: true
    spec?: true
    purchaseDate?: true
    warrantyUntil?: true
    location?: true
    status?: true
    ownerId?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    name?: true
    serialNumber?: true
    assetTag?: true
    type?: true
    brand?: true
    model?: true
    spec?: true
    purchaseDate?: true
    warrantyUntil?: true
    location?: true
    status?: true
    ownerId?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    name?: true
    serialNumber?: true
    assetTag?: true
    type?: true
    brand?: true
    model?: true
    spec?: true
    purchaseDate?: true
    warrantyUntil?: true
    location?: true
    status?: true
    ownerId?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _avg?: AssetAvgAggregateInputType
    _sum?: AssetSumAggregateInputType
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: number
    name: string
    serialNumber: string
    assetTag: string | null
    type: string
    brand: string | null
    model: string | null
    spec: string | null
    purchaseDate: Date | null
    warrantyUntil: Date | null
    location: string | null
    status: string
    ownerId: number | null
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    serialNumber?: boolean
    assetTag?: boolean
    type?: boolean
    brand?: boolean
    model?: boolean
    spec?: boolean
    purchaseDate?: boolean
    warrantyUntil?: boolean
    location?: boolean
    status?: boolean
    ownerId?: boolean
    User?: boolean | Asset$UserArgs<ExtArgs>
    AssetHistory?: boolean | Asset$AssetHistoryArgs<ExtArgs>
    License?: boolean | Asset$LicenseArgs<ExtArgs>
    Monitor?: boolean | Asset$MonitorArgs<ExtArgs>
    Ticket?: boolean | Asset$TicketArgs<ExtArgs>
    Contract?: boolean | Asset$ContractArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>


  export type AssetSelectScalar = {
    id?: boolean
    name?: boolean
    serialNumber?: boolean
    assetTag?: boolean
    type?: boolean
    brand?: boolean
    model?: boolean
    spec?: boolean
    purchaseDate?: boolean
    warrantyUntil?: boolean
    location?: boolean
    status?: boolean
    ownerId?: boolean
  }

  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Asset$UserArgs<ExtArgs>
    AssetHistory?: boolean | Asset$AssetHistoryArgs<ExtArgs>
    License?: boolean | Asset$LicenseArgs<ExtArgs>
    Monitor?: boolean | Asset$MonitorArgs<ExtArgs>
    Ticket?: boolean | Asset$TicketArgs<ExtArgs>
    Contract?: boolean | Asset$ContractArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
      AssetHistory: Prisma.$AssetHistoryPayload<ExtArgs>[]
      License: Prisma.$LicensePayload<ExtArgs>[]
      Monitor: Prisma.$MonitorPayload<ExtArgs> | null
      Ticket: Prisma.$TicketPayload<ExtArgs>[]
      Contract: Prisma.$ContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      serialNumber: string
      assetTag: string | null
      type: string
      brand: string | null
      model: string | null
      spec: string | null
      purchaseDate: Date | null
      warrantyUntil: Date | null
      location: string | null
      status: string
      ownerId: number | null
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Asset$UserArgs<ExtArgs> = {}>(args?: Subset<T, Asset$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    AssetHistory<T extends Asset$AssetHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Asset$AssetHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    License<T extends Asset$LicenseArgs<ExtArgs> = {}>(args?: Subset<T, Asset$LicenseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findMany"> | Null>
    Monitor<T extends Asset$MonitorArgs<ExtArgs> = {}>(args?: Subset<T, Asset$MonitorArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Ticket<T extends Asset$TicketArgs<ExtArgs> = {}>(args?: Subset<T, Asset$TicketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    Contract<T extends Asset$ContractArgs<ExtArgs> = {}>(args?: Subset<T, Asset$ContractArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */ 
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'Int'>
    readonly name: FieldRef<"Asset", 'String'>
    readonly serialNumber: FieldRef<"Asset", 'String'>
    readonly assetTag: FieldRef<"Asset", 'String'>
    readonly type: FieldRef<"Asset", 'String'>
    readonly brand: FieldRef<"Asset", 'String'>
    readonly model: FieldRef<"Asset", 'String'>
    readonly spec: FieldRef<"Asset", 'String'>
    readonly purchaseDate: FieldRef<"Asset", 'DateTime'>
    readonly warrantyUntil: FieldRef<"Asset", 'DateTime'>
    readonly location: FieldRef<"Asset", 'String'>
    readonly status: FieldRef<"Asset", 'String'>
    readonly ownerId: FieldRef<"Asset", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
  }

  /**
   * Asset.User
   */
  export type Asset$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Asset.AssetHistory
   */
  export type Asset$AssetHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    where?: AssetHistoryWhereInput
    orderBy?: AssetHistoryOrderByWithRelationInput | AssetHistoryOrderByWithRelationInput[]
    cursor?: AssetHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetHistoryScalarFieldEnum | AssetHistoryScalarFieldEnum[]
  }

  /**
   * Asset.License
   */
  export type Asset$LicenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    where?: LicenseWhereInput
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    cursor?: LicenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * Asset.Monitor
   */
  export type Asset$MonitorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    where?: MonitorWhereInput
  }

  /**
   * Asset.Ticket
   */
  export type Asset$TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Asset.Contract
   */
  export type Asset$ContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model AssetHistory
   */

  export type AggregateAssetHistory = {
    _count: AssetHistoryCountAggregateOutputType | null
    _avg: AssetHistoryAvgAggregateOutputType | null
    _sum: AssetHistorySumAggregateOutputType | null
    _min: AssetHistoryMinAggregateOutputType | null
    _max: AssetHistoryMaxAggregateOutputType | null
  }

  export type AssetHistoryAvgAggregateOutputType = {
    id: number | null
    assetId: number | null
    oldOwnerId: number | null
    newOwnerId: number | null
  }

  export type AssetHistorySumAggregateOutputType = {
    id: number | null
    assetId: number | null
    oldOwnerId: number | null
    newOwnerId: number | null
  }

  export type AssetHistoryMinAggregateOutputType = {
    id: number | null
    assetId: number | null
    oldOwnerId: number | null
    newOwnerId: number | null
    changedAt: Date | null
    reason: string | null
  }

  export type AssetHistoryMaxAggregateOutputType = {
    id: number | null
    assetId: number | null
    oldOwnerId: number | null
    newOwnerId: number | null
    changedAt: Date | null
    reason: string | null
  }

  export type AssetHistoryCountAggregateOutputType = {
    id: number
    assetId: number
    oldOwnerId: number
    newOwnerId: number
    changedAt: number
    reason: number
    _all: number
  }


  export type AssetHistoryAvgAggregateInputType = {
    id?: true
    assetId?: true
    oldOwnerId?: true
    newOwnerId?: true
  }

  export type AssetHistorySumAggregateInputType = {
    id?: true
    assetId?: true
    oldOwnerId?: true
    newOwnerId?: true
  }

  export type AssetHistoryMinAggregateInputType = {
    id?: true
    assetId?: true
    oldOwnerId?: true
    newOwnerId?: true
    changedAt?: true
    reason?: true
  }

  export type AssetHistoryMaxAggregateInputType = {
    id?: true
    assetId?: true
    oldOwnerId?: true
    newOwnerId?: true
    changedAt?: true
    reason?: true
  }

  export type AssetHistoryCountAggregateInputType = {
    id?: true
    assetId?: true
    oldOwnerId?: true
    newOwnerId?: true
    changedAt?: true
    reason?: true
    _all?: true
  }

  export type AssetHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetHistory to aggregate.
     */
    where?: AssetHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetHistories to fetch.
     */
    orderBy?: AssetHistoryOrderByWithRelationInput | AssetHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetHistories
    **/
    _count?: true | AssetHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetHistoryMaxAggregateInputType
  }

  export type GetAssetHistoryAggregateType<T extends AssetHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetHistory[P]>
      : GetScalarType<T[P], AggregateAssetHistory[P]>
  }




  export type AssetHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetHistoryWhereInput
    orderBy?: AssetHistoryOrderByWithAggregationInput | AssetHistoryOrderByWithAggregationInput[]
    by: AssetHistoryScalarFieldEnum[] | AssetHistoryScalarFieldEnum
    having?: AssetHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetHistoryCountAggregateInputType | true
    _avg?: AssetHistoryAvgAggregateInputType
    _sum?: AssetHistorySumAggregateInputType
    _min?: AssetHistoryMinAggregateInputType
    _max?: AssetHistoryMaxAggregateInputType
  }

  export type AssetHistoryGroupByOutputType = {
    id: number
    assetId: number
    oldOwnerId: number | null
    newOwnerId: number | null
    changedAt: Date
    reason: string | null
    _count: AssetHistoryCountAggregateOutputType | null
    _avg: AssetHistoryAvgAggregateOutputType | null
    _sum: AssetHistorySumAggregateOutputType | null
    _min: AssetHistoryMinAggregateOutputType | null
    _max: AssetHistoryMaxAggregateOutputType | null
  }

  type GetAssetHistoryGroupByPayload<T extends AssetHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], AssetHistoryGroupByOutputType[P]>
        }
      >
    >


  export type AssetHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    oldOwnerId?: boolean
    newOwnerId?: boolean
    changedAt?: boolean
    reason?: boolean
    Asset?: boolean | AssetDefaultArgs<ExtArgs>
    User_AssetHistory_newOwnerIdToUser?: boolean | AssetHistory$User_AssetHistory_newOwnerIdToUserArgs<ExtArgs>
    User_AssetHistory_oldOwnerIdToUser?: boolean | AssetHistory$User_AssetHistory_oldOwnerIdToUserArgs<ExtArgs>
  }, ExtArgs["result"]["assetHistory"]>


  export type AssetHistorySelectScalar = {
    id?: boolean
    assetId?: boolean
    oldOwnerId?: boolean
    newOwnerId?: boolean
    changedAt?: boolean
    reason?: boolean
  }

  export type AssetHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Asset?: boolean | AssetDefaultArgs<ExtArgs>
    User_AssetHistory_newOwnerIdToUser?: boolean | AssetHistory$User_AssetHistory_newOwnerIdToUserArgs<ExtArgs>
    User_AssetHistory_oldOwnerIdToUser?: boolean | AssetHistory$User_AssetHistory_oldOwnerIdToUserArgs<ExtArgs>
  }

  export type $AssetHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetHistory"
    objects: {
      Asset: Prisma.$AssetPayload<ExtArgs>
      User_AssetHistory_newOwnerIdToUser: Prisma.$UserPayload<ExtArgs> | null
      User_AssetHistory_oldOwnerIdToUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assetId: number
      oldOwnerId: number | null
      newOwnerId: number | null
      changedAt: Date
      reason: string | null
    }, ExtArgs["result"]["assetHistory"]>
    composites: {}
  }

  type AssetHistoryGetPayload<S extends boolean | null | undefined | AssetHistoryDefaultArgs> = $Result.GetResult<Prisma.$AssetHistoryPayload, S>

  type AssetHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetHistoryCountAggregateInputType | true
    }

  export interface AssetHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetHistory'], meta: { name: 'AssetHistory' } }
    /**
     * Find zero or one AssetHistory that matches the filter.
     * @param {AssetHistoryFindUniqueArgs} args - Arguments to find a AssetHistory
     * @example
     * // Get one AssetHistory
     * const assetHistory = await prisma.assetHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetHistoryFindUniqueArgs>(args: SelectSubset<T, AssetHistoryFindUniqueArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AssetHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetHistoryFindUniqueOrThrowArgs} args - Arguments to find a AssetHistory
     * @example
     * // Get one AssetHistory
     * const assetHistory = await prisma.assetHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AssetHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetHistoryFindFirstArgs} args - Arguments to find a AssetHistory
     * @example
     * // Get one AssetHistory
     * const assetHistory = await prisma.assetHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetHistoryFindFirstArgs>(args?: SelectSubset<T, AssetHistoryFindFirstArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AssetHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetHistoryFindFirstOrThrowArgs} args - Arguments to find a AssetHistory
     * @example
     * // Get one AssetHistory
     * const assetHistory = await prisma.assetHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AssetHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetHistories
     * const assetHistories = await prisma.assetHistory.findMany()
     * 
     * // Get first 10 AssetHistories
     * const assetHistories = await prisma.assetHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetHistoryWithIdOnly = await prisma.assetHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetHistoryFindManyArgs>(args?: SelectSubset<T, AssetHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AssetHistory.
     * @param {AssetHistoryCreateArgs} args - Arguments to create a AssetHistory.
     * @example
     * // Create one AssetHistory
     * const AssetHistory = await prisma.assetHistory.create({
     *   data: {
     *     // ... data to create a AssetHistory
     *   }
     * })
     * 
     */
    create<T extends AssetHistoryCreateArgs>(args: SelectSubset<T, AssetHistoryCreateArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AssetHistories.
     * @param {AssetHistoryCreateManyArgs} args - Arguments to create many AssetHistories.
     * @example
     * // Create many AssetHistories
     * const assetHistory = await prisma.assetHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetHistoryCreateManyArgs>(args?: SelectSubset<T, AssetHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AssetHistory.
     * @param {AssetHistoryDeleteArgs} args - Arguments to delete one AssetHistory.
     * @example
     * // Delete one AssetHistory
     * const AssetHistory = await prisma.assetHistory.delete({
     *   where: {
     *     // ... filter to delete one AssetHistory
     *   }
     * })
     * 
     */
    delete<T extends AssetHistoryDeleteArgs>(args: SelectSubset<T, AssetHistoryDeleteArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AssetHistory.
     * @param {AssetHistoryUpdateArgs} args - Arguments to update one AssetHistory.
     * @example
     * // Update one AssetHistory
     * const assetHistory = await prisma.assetHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetHistoryUpdateArgs>(args: SelectSubset<T, AssetHistoryUpdateArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AssetHistories.
     * @param {AssetHistoryDeleteManyArgs} args - Arguments to filter AssetHistories to delete.
     * @example
     * // Delete a few AssetHistories
     * const { count } = await prisma.assetHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetHistoryDeleteManyArgs>(args?: SelectSubset<T, AssetHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetHistories
     * const assetHistory = await prisma.assetHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetHistoryUpdateManyArgs>(args: SelectSubset<T, AssetHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssetHistory.
     * @param {AssetHistoryUpsertArgs} args - Arguments to update or create a AssetHistory.
     * @example
     * // Update or create a AssetHistory
     * const assetHistory = await prisma.assetHistory.upsert({
     *   create: {
     *     // ... data to create a AssetHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetHistory we want to update
     *   }
     * })
     */
    upsert<T extends AssetHistoryUpsertArgs>(args: SelectSubset<T, AssetHistoryUpsertArgs<ExtArgs>>): Prisma__AssetHistoryClient<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AssetHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetHistoryCountArgs} args - Arguments to filter AssetHistories to count.
     * @example
     * // Count the number of AssetHistories
     * const count = await prisma.assetHistory.count({
     *   where: {
     *     // ... the filter for the AssetHistories we want to count
     *   }
     * })
    **/
    count<T extends AssetHistoryCountArgs>(
      args?: Subset<T, AssetHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetHistoryAggregateArgs>(args: Subset<T, AssetHistoryAggregateArgs>): Prisma.PrismaPromise<GetAssetHistoryAggregateType<T>>

    /**
     * Group by AssetHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetHistoryGroupByArgs['orderBy'] }
        : { orderBy?: AssetHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetHistory model
   */
  readonly fields: AssetHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    User_AssetHistory_newOwnerIdToUser<T extends AssetHistory$User_AssetHistory_newOwnerIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, AssetHistory$User_AssetHistory_newOwnerIdToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    User_AssetHistory_oldOwnerIdToUser<T extends AssetHistory$User_AssetHistory_oldOwnerIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, AssetHistory$User_AssetHistory_oldOwnerIdToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetHistory model
   */ 
  interface AssetHistoryFieldRefs {
    readonly id: FieldRef<"AssetHistory", 'Int'>
    readonly assetId: FieldRef<"AssetHistory", 'Int'>
    readonly oldOwnerId: FieldRef<"AssetHistory", 'Int'>
    readonly newOwnerId: FieldRef<"AssetHistory", 'Int'>
    readonly changedAt: FieldRef<"AssetHistory", 'DateTime'>
    readonly reason: FieldRef<"AssetHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AssetHistory findUnique
   */
  export type AssetHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetHistory to fetch.
     */
    where: AssetHistoryWhereUniqueInput
  }

  /**
   * AssetHistory findUniqueOrThrow
   */
  export type AssetHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetHistory to fetch.
     */
    where: AssetHistoryWhereUniqueInput
  }

  /**
   * AssetHistory findFirst
   */
  export type AssetHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetHistory to fetch.
     */
    where?: AssetHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetHistories to fetch.
     */
    orderBy?: AssetHistoryOrderByWithRelationInput | AssetHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetHistories.
     */
    cursor?: AssetHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetHistories.
     */
    distinct?: AssetHistoryScalarFieldEnum | AssetHistoryScalarFieldEnum[]
  }

  /**
   * AssetHistory findFirstOrThrow
   */
  export type AssetHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetHistory to fetch.
     */
    where?: AssetHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetHistories to fetch.
     */
    orderBy?: AssetHistoryOrderByWithRelationInput | AssetHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetHistories.
     */
    cursor?: AssetHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetHistories.
     */
    distinct?: AssetHistoryScalarFieldEnum | AssetHistoryScalarFieldEnum[]
  }

  /**
   * AssetHistory findMany
   */
  export type AssetHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetHistories to fetch.
     */
    where?: AssetHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetHistories to fetch.
     */
    orderBy?: AssetHistoryOrderByWithRelationInput | AssetHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetHistories.
     */
    cursor?: AssetHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetHistories.
     */
    skip?: number
    distinct?: AssetHistoryScalarFieldEnum | AssetHistoryScalarFieldEnum[]
  }

  /**
   * AssetHistory create
   */
  export type AssetHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetHistory.
     */
    data: XOR<AssetHistoryCreateInput, AssetHistoryUncheckedCreateInput>
  }

  /**
   * AssetHistory createMany
   */
  export type AssetHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetHistories.
     */
    data: AssetHistoryCreateManyInput | AssetHistoryCreateManyInput[]
  }

  /**
   * AssetHistory update
   */
  export type AssetHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetHistory.
     */
    data: XOR<AssetHistoryUpdateInput, AssetHistoryUncheckedUpdateInput>
    /**
     * Choose, which AssetHistory to update.
     */
    where: AssetHistoryWhereUniqueInput
  }

  /**
   * AssetHistory updateMany
   */
  export type AssetHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetHistories.
     */
    data: XOR<AssetHistoryUpdateManyMutationInput, AssetHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AssetHistories to update
     */
    where?: AssetHistoryWhereInput
  }

  /**
   * AssetHistory upsert
   */
  export type AssetHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetHistory to update in case it exists.
     */
    where: AssetHistoryWhereUniqueInput
    /**
     * In case the AssetHistory found by the `where` argument doesn't exist, create a new AssetHistory with this data.
     */
    create: XOR<AssetHistoryCreateInput, AssetHistoryUncheckedCreateInput>
    /**
     * In case the AssetHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetHistoryUpdateInput, AssetHistoryUncheckedUpdateInput>
  }

  /**
   * AssetHistory delete
   */
  export type AssetHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    /**
     * Filter which AssetHistory to delete.
     */
    where: AssetHistoryWhereUniqueInput
  }

  /**
   * AssetHistory deleteMany
   */
  export type AssetHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetHistories to delete
     */
    where?: AssetHistoryWhereInput
  }

  /**
   * AssetHistory.User_AssetHistory_newOwnerIdToUser
   */
  export type AssetHistory$User_AssetHistory_newOwnerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AssetHistory.User_AssetHistory_oldOwnerIdToUser
   */
  export type AssetHistory$User_AssetHistory_oldOwnerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AssetHistory without action
   */
  export type AssetHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    recordId: number | null
    userId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    recordId: number | null
    userId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    action: string | null
    tableName: string | null
    recordId: number | null
    oldValue: string | null
    newValue: string | null
    userId: number | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    action: string | null
    tableName: string | null
    recordId: number | null
    oldValue: string | null
    newValue: string | null
    userId: number | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    tableName: number
    recordId: number
    oldValue: number
    newValue: number
    userId: number
    ipAddress: number
    userAgent: number
    timestamp: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    recordId?: true
    userId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    recordId?: true
    userId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    tableName?: true
    recordId?: true
    oldValue?: true
    newValue?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    tableName?: true
    recordId?: true
    oldValue?: true
    newValue?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    tableName?: true
    recordId?: true
    oldValue?: true
    newValue?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    action: string
    tableName: string
    recordId: number | null
    oldValue: string | null
    newValue: string | null
    userId: number
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    oldValue?: boolean
    newValue?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>


  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    tableName?: boolean
    recordId?: boolean
    oldValue?: boolean
    newValue?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      action: string
      tableName: string
      recordId: number | null
      oldValue: string | null
      newValue: string | null
      userId: number
      ipAddress: string | null
      userAgent: string | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly tableName: FieldRef<"AuditLog", 'String'>
    readonly recordId: FieldRef<"AuditLog", 'Int'>
    readonly oldValue: FieldRef<"AuditLog", 'String'>
    readonly newValue: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'Int'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    vendorId: number | null
  }

  export type ContractSumAggregateOutputType = {
    id: number | null
    amount: number | null
    vendorId: number | null
  }

  export type ContractMinAggregateOutputType = {
    id: number | null
    title: string | null
    contractNo: string | null
    startDate: Date | null
    endDate: Date | null
    amount: number | null
    description: string | null
    vendorId: number | null
  }

  export type ContractMaxAggregateOutputType = {
    id: number | null
    title: string | null
    contractNo: string | null
    startDate: Date | null
    endDate: Date | null
    amount: number | null
    description: string | null
    vendorId: number | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    title: number
    contractNo: number
    startDate: number
    endDate: number
    amount: number
    description: number
    vendorId: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    id?: true
    amount?: true
    vendorId?: true
  }

  export type ContractSumAggregateInputType = {
    id?: true
    amount?: true
    vendorId?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    title?: true
    contractNo?: true
    startDate?: true
    endDate?: true
    amount?: true
    description?: true
    vendorId?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    title?: true
    contractNo?: true
    startDate?: true
    endDate?: true
    amount?: true
    description?: true
    vendorId?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    title?: true
    contractNo?: true
    startDate?: true
    endDate?: true
    amount?: true
    description?: true
    vendorId?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: number
    title: string
    contractNo: string
    startDate: Date
    endDate: Date
    amount: number | null
    description: string | null
    vendorId: number
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    contractNo?: boolean
    startDate?: boolean
    endDate?: boolean
    amount?: boolean
    description?: boolean
    vendorId?: boolean
    Vendor?: boolean | VendorDefaultArgs<ExtArgs>
    Asset?: boolean | Contract$AssetArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>


  export type ContractSelectScalar = {
    id?: boolean
    title?: boolean
    contractNo?: boolean
    startDate?: boolean
    endDate?: boolean
    amount?: boolean
    description?: boolean
    vendorId?: boolean
  }

  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Vendor?: boolean | VendorDefaultArgs<ExtArgs>
    Asset?: boolean | Contract$AssetArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      Vendor: Prisma.$VendorPayload<ExtArgs>
      Asset: Prisma.$AssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      contractNo: string
      startDate: Date
      endDate: Date
      amount: number | null
      description: string | null
      vendorId: number
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Asset<T extends Contract$AssetArgs<ExtArgs> = {}>(args?: Subset<T, Contract$AssetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */ 
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'Int'>
    readonly title: FieldRef<"Contract", 'String'>
    readonly contractNo: FieldRef<"Contract", 'String'>
    readonly startDate: FieldRef<"Contract", 'DateTime'>
    readonly endDate: FieldRef<"Contract", 'DateTime'>
    readonly amount: FieldRef<"Contract", 'Float'>
    readonly description: FieldRef<"Contract", 'String'>
    readonly vendorId: FieldRef<"Contract", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
  }

  /**
   * Contract.Asset
   */
  export type Contract$AssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model departments
   */

  export type AggregateDepartments = {
    _count: DepartmentsCountAggregateOutputType | null
    _avg: DepartmentsAvgAggregateOutputType | null
    _sum: DepartmentsSumAggregateOutputType | null
    _min: DepartmentsMinAggregateOutputType | null
    _max: DepartmentsMaxAggregateOutputType | null
  }

  export type DepartmentsAvgAggregateOutputType = {
    id: number | null
  }

  export type DepartmentsSumAggregateOutputType = {
    id: number | null
  }

  export type DepartmentsMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DepartmentsMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DepartmentsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DepartmentsAvgAggregateInputType = {
    id?: true
  }

  export type DepartmentsSumAggregateInputType = {
    id?: true
  }

  export type DepartmentsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DepartmentsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DepartmentsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DepartmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departments to aggregate.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned departments
    **/
    _count?: true | DepartmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentsMaxAggregateInputType
  }

  export type GetDepartmentsAggregateType<T extends DepartmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartments[P]>
      : GetScalarType<T[P], AggregateDepartments[P]>
  }




  export type departmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentsWhereInput
    orderBy?: departmentsOrderByWithAggregationInput | departmentsOrderByWithAggregationInput[]
    by: DepartmentsScalarFieldEnum[] | DepartmentsScalarFieldEnum
    having?: departmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentsCountAggregateInputType | true
    _avg?: DepartmentsAvgAggregateInputType
    _sum?: DepartmentsSumAggregateInputType
    _min?: DepartmentsMinAggregateInputType
    _max?: DepartmentsMaxAggregateInputType
  }

  export type DepartmentsGroupByOutputType = {
    id: number
    name: string
    _count: DepartmentsCountAggregateOutputType | null
    _avg: DepartmentsAvgAggregateOutputType | null
    _sum: DepartmentsSumAggregateOutputType | null
    _min: DepartmentsMinAggregateOutputType | null
    _max: DepartmentsMaxAggregateOutputType | null
  }

  type GetDepartmentsGroupByPayload<T extends departmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentsGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentsGroupByOutputType[P]>
        }
      >
    >


  export type departmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    employees?: boolean | departments$employeesArgs<ExtArgs>
    _count?: boolean | DepartmentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departments"]>


  export type departmentsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type departmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | departments$employeesArgs<ExtArgs>
    _count?: boolean | DepartmentsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $departmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "departments"
    objects: {
      employees: Prisma.$employeesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["departments"]>
    composites: {}
  }

  type departmentsGetPayload<S extends boolean | null | undefined | departmentsDefaultArgs> = $Result.GetResult<Prisma.$departmentsPayload, S>

  type departmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<departmentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentsCountAggregateInputType | true
    }

  export interface departmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['departments'], meta: { name: 'departments' } }
    /**
     * Find zero or one Departments that matches the filter.
     * @param {departmentsFindUniqueArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends departmentsFindUniqueArgs>(args: SelectSubset<T, departmentsFindUniqueArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Departments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {departmentsFindUniqueOrThrowArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends departmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, departmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsFindFirstArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends departmentsFindFirstArgs>(args?: SelectSubset<T, departmentsFindFirstArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Departments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsFindFirstOrThrowArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends departmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, departmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.departments.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.departments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentsWithIdOnly = await prisma.departments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends departmentsFindManyArgs>(args?: SelectSubset<T, departmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Departments.
     * @param {departmentsCreateArgs} args - Arguments to create a Departments.
     * @example
     * // Create one Departments
     * const Departments = await prisma.departments.create({
     *   data: {
     *     // ... data to create a Departments
     *   }
     * })
     * 
     */
    create<T extends departmentsCreateArgs>(args: SelectSubset<T, departmentsCreateArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {departmentsCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const departments = await prisma.departments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends departmentsCreateManyArgs>(args?: SelectSubset<T, departmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Departments.
     * @param {departmentsDeleteArgs} args - Arguments to delete one Departments.
     * @example
     * // Delete one Departments
     * const Departments = await prisma.departments.delete({
     *   where: {
     *     // ... filter to delete one Departments
     *   }
     * })
     * 
     */
    delete<T extends departmentsDeleteArgs>(args: SelectSubset<T, departmentsDeleteArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Departments.
     * @param {departmentsUpdateArgs} args - Arguments to update one Departments.
     * @example
     * // Update one Departments
     * const departments = await prisma.departments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends departmentsUpdateArgs>(args: SelectSubset<T, departmentsUpdateArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {departmentsDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.departments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends departmentsDeleteManyArgs>(args?: SelectSubset<T, departmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const departments = await prisma.departments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends departmentsUpdateManyArgs>(args: SelectSubset<T, departmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Departments.
     * @param {departmentsUpsertArgs} args - Arguments to update or create a Departments.
     * @example
     * // Update or create a Departments
     * const departments = await prisma.departments.upsert({
     *   create: {
     *     // ... data to create a Departments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Departments we want to update
     *   }
     * })
     */
    upsert<T extends departmentsUpsertArgs>(args: SelectSubset<T, departmentsUpsertArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.departments.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends departmentsCountArgs>(
      args?: Subset<T, departmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentsAggregateArgs>(args: Subset<T, DepartmentsAggregateArgs>): Prisma.PrismaPromise<GetDepartmentsAggregateType<T>>

    /**
     * Group by Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends departmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: departmentsGroupByArgs['orderBy'] }
        : { orderBy?: departmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, departmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the departments model
   */
  readonly fields: departmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for departments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__departmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends departments$employeesArgs<ExtArgs> = {}>(args?: Subset<T, departments$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the departments model
   */ 
  interface departmentsFieldRefs {
    readonly id: FieldRef<"departments", 'Int'>
    readonly name: FieldRef<"departments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * departments findUnique
   */
  export type departmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments findUniqueOrThrow
   */
  export type departmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments findFirst
   */
  export type departmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * departments findFirstOrThrow
   */
  export type departmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * departments findMany
   */
  export type departmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing departments.
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * departments create
   */
  export type departmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a departments.
     */
    data: XOR<departmentsCreateInput, departmentsUncheckedCreateInput>
  }

  /**
   * departments createMany
   */
  export type departmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many departments.
     */
    data: departmentsCreateManyInput | departmentsCreateManyInput[]
  }

  /**
   * departments update
   */
  export type departmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a departments.
     */
    data: XOR<departmentsUpdateInput, departmentsUncheckedUpdateInput>
    /**
     * Choose, which departments to update.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments updateMany
   */
  export type departmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update departments.
     */
    data: XOR<departmentsUpdateManyMutationInput, departmentsUncheckedUpdateManyInput>
    /**
     * Filter which departments to update
     */
    where?: departmentsWhereInput
  }

  /**
   * departments upsert
   */
  export type departmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the departments to update in case it exists.
     */
    where: departmentsWhereUniqueInput
    /**
     * In case the departments found by the `where` argument doesn't exist, create a new departments with this data.
     */
    create: XOR<departmentsCreateInput, departmentsUncheckedCreateInput>
    /**
     * In case the departments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<departmentsUpdateInput, departmentsUncheckedUpdateInput>
  }

  /**
   * departments delete
   */
  export type departmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter which departments to delete.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments deleteMany
   */
  export type departmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departments to delete
     */
    where?: departmentsWhereInput
  }

  /**
   * departments.employees
   */
  export type departments$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    where?: employeesWhereInput
    orderBy?: employeesOrderByWithRelationInput | employeesOrderByWithRelationInput[]
    cursor?: employeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * departments without action
   */
  export type departmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type DocumentSumAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: number | null
    name: string | null
    filePath: string | null
    version: string | null
    permission: string | null
    createdAt: Date | null
    createdById: number | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    filePath: string | null
    version: string | null
    permission: string | null
    createdAt: Date | null
    createdById: number | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    name: number
    filePath: number
    version: number
    permission: number
    createdAt: number
    createdById: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type DocumentSumAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    name?: true
    filePath?: true
    version?: true
    permission?: true
    createdAt?: true
    createdById?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    name?: true
    filePath?: true
    version?: true
    permission?: true
    createdAt?: true
    createdById?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    name?: true
    filePath?: true
    version?: true
    permission?: true
    createdAt?: true
    createdById?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: number
    name: string
    filePath: string
    version: string
    permission: string
    createdAt: Date
    createdById: number
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    filePath?: boolean
    version?: boolean
    permission?: boolean
    createdAt?: boolean
    createdById?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>


  export type DocumentSelectScalar = {
    id?: boolean
    name?: boolean
    filePath?: boolean
    version?: boolean
    permission?: boolean
    createdAt?: boolean
    createdById?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      filePath: string
      version: string
      permission: string
      createdAt: Date
      createdById: number
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'Int'>
    readonly name: FieldRef<"Document", 'String'>
    readonly filePath: FieldRef<"Document", 'String'>
    readonly version: FieldRef<"Document", 'String'>
    readonly permission: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly createdById: FieldRef<"Document", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model employee_roles
   */

  export type AggregateEmployee_roles = {
    _count: Employee_rolesCountAggregateOutputType | null
    _avg: Employee_rolesAvgAggregateOutputType | null
    _sum: Employee_rolesSumAggregateOutputType | null
    _min: Employee_rolesMinAggregateOutputType | null
    _max: Employee_rolesMaxAggregateOutputType | null
  }

  export type Employee_rolesAvgAggregateOutputType = {
    employee_id: number | null
    role_id: number | null
  }

  export type Employee_rolesSumAggregateOutputType = {
    employee_id: number | null
    role_id: number | null
  }

  export type Employee_rolesMinAggregateOutputType = {
    employee_id: number | null
    role_id: number | null
  }

  export type Employee_rolesMaxAggregateOutputType = {
    employee_id: number | null
    role_id: number | null
  }

  export type Employee_rolesCountAggregateOutputType = {
    employee_id: number
    role_id: number
    _all: number
  }


  export type Employee_rolesAvgAggregateInputType = {
    employee_id?: true
    role_id?: true
  }

  export type Employee_rolesSumAggregateInputType = {
    employee_id?: true
    role_id?: true
  }

  export type Employee_rolesMinAggregateInputType = {
    employee_id?: true
    role_id?: true
  }

  export type Employee_rolesMaxAggregateInputType = {
    employee_id?: true
    role_id?: true
  }

  export type Employee_rolesCountAggregateInputType = {
    employee_id?: true
    role_id?: true
    _all?: true
  }

  export type Employee_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee_roles to aggregate.
     */
    where?: employee_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_roles to fetch.
     */
    orderBy?: employee_rolesOrderByWithRelationInput | employee_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employee_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employee_roles
    **/
    _count?: true | Employee_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Employee_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Employee_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Employee_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Employee_rolesMaxAggregateInputType
  }

  export type GetEmployee_rolesAggregateType<T extends Employee_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee_roles[P]>
      : GetScalarType<T[P], AggregateEmployee_roles[P]>
  }




  export type employee_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_rolesWhereInput
    orderBy?: employee_rolesOrderByWithAggregationInput | employee_rolesOrderByWithAggregationInput[]
    by: Employee_rolesScalarFieldEnum[] | Employee_rolesScalarFieldEnum
    having?: employee_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Employee_rolesCountAggregateInputType | true
    _avg?: Employee_rolesAvgAggregateInputType
    _sum?: Employee_rolesSumAggregateInputType
    _min?: Employee_rolesMinAggregateInputType
    _max?: Employee_rolesMaxAggregateInputType
  }

  export type Employee_rolesGroupByOutputType = {
    employee_id: number
    role_id: number
    _count: Employee_rolesCountAggregateOutputType | null
    _avg: Employee_rolesAvgAggregateOutputType | null
    _sum: Employee_rolesSumAggregateOutputType | null
    _min: Employee_rolesMinAggregateOutputType | null
    _max: Employee_rolesMaxAggregateOutputType | null
  }

  type GetEmployee_rolesGroupByPayload<T extends employee_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Employee_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Employee_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Employee_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], Employee_rolesGroupByOutputType[P]>
        }
      >
    >


  export type employee_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employee_id?: boolean
    role_id?: boolean
    employees?: boolean | employeesDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee_roles"]>


  export type employee_rolesSelectScalar = {
    employee_id?: boolean
    role_id?: boolean
  }

  export type employee_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | employeesDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $employee_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employee_roles"
    objects: {
      employees: Prisma.$employeesPayload<ExtArgs>
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      employee_id: number
      role_id: number
    }, ExtArgs["result"]["employee_roles"]>
    composites: {}
  }

  type employee_rolesGetPayload<S extends boolean | null | undefined | employee_rolesDefaultArgs> = $Result.GetResult<Prisma.$employee_rolesPayload, S>

  type employee_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<employee_rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Employee_rolesCountAggregateInputType | true
    }

  export interface employee_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employee_roles'], meta: { name: 'employee_roles' } }
    /**
     * Find zero or one Employee_roles that matches the filter.
     * @param {employee_rolesFindUniqueArgs} args - Arguments to find a Employee_roles
     * @example
     * // Get one Employee_roles
     * const employee_roles = await prisma.employee_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employee_rolesFindUniqueArgs>(args: SelectSubset<T, employee_rolesFindUniqueArgs<ExtArgs>>): Prisma__employee_rolesClient<$Result.GetResult<Prisma.$employee_rolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Employee_roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {employee_rolesFindUniqueOrThrowArgs} args - Arguments to find a Employee_roles
     * @example
     * // Get one Employee_roles
     * const employee_roles = await prisma.employee_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employee_rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, employee_rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employee_rolesClient<$Result.GetResult<Prisma.$employee_rolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Employee_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_rolesFindFirstArgs} args - Arguments to find a Employee_roles
     * @example
     * // Get one Employee_roles
     * const employee_roles = await prisma.employee_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employee_rolesFindFirstArgs>(args?: SelectSubset<T, employee_rolesFindFirstArgs<ExtArgs>>): Prisma__employee_rolesClient<$Result.GetResult<Prisma.$employee_rolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Employee_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_rolesFindFirstOrThrowArgs} args - Arguments to find a Employee_roles
     * @example
     * // Get one Employee_roles
     * const employee_roles = await prisma.employee_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employee_rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, employee_rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__employee_rolesClient<$Result.GetResult<Prisma.$employee_rolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Employee_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employee_roles
     * const employee_roles = await prisma.employee_roles.findMany()
     * 
     * // Get first 10 Employee_roles
     * const employee_roles = await prisma.employee_roles.findMany({ take: 10 })
     * 
     * // Only select the `employee_id`
     * const employee_rolesWithEmployee_idOnly = await prisma.employee_roles.findMany({ select: { employee_id: true } })
     * 
     */
    findMany<T extends employee_rolesFindManyArgs>(args?: SelectSubset<T, employee_rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_rolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Employee_roles.
     * @param {employee_rolesCreateArgs} args - Arguments to create a Employee_roles.
     * @example
     * // Create one Employee_roles
     * const Employee_roles = await prisma.employee_roles.create({
     *   data: {
     *     // ... data to create a Employee_roles
     *   }
     * })
     * 
     */
    create<T extends employee_rolesCreateArgs>(args: SelectSubset<T, employee_rolesCreateArgs<ExtArgs>>): Prisma__employee_rolesClient<$Result.GetResult<Prisma.$employee_rolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Employee_roles.
     * @param {employee_rolesCreateManyArgs} args - Arguments to create many Employee_roles.
     * @example
     * // Create many Employee_roles
     * const employee_roles = await prisma.employee_roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employee_rolesCreateManyArgs>(args?: SelectSubset<T, employee_rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employee_roles.
     * @param {employee_rolesDeleteArgs} args - Arguments to delete one Employee_roles.
     * @example
     * // Delete one Employee_roles
     * const Employee_roles = await prisma.employee_roles.delete({
     *   where: {
     *     // ... filter to delete one Employee_roles
     *   }
     * })
     * 
     */
    delete<T extends employee_rolesDeleteArgs>(args: SelectSubset<T, employee_rolesDeleteArgs<ExtArgs>>): Prisma__employee_rolesClient<$Result.GetResult<Prisma.$employee_rolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Employee_roles.
     * @param {employee_rolesUpdateArgs} args - Arguments to update one Employee_roles.
     * @example
     * // Update one Employee_roles
     * const employee_roles = await prisma.employee_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employee_rolesUpdateArgs>(args: SelectSubset<T, employee_rolesUpdateArgs<ExtArgs>>): Prisma__employee_rolesClient<$Result.GetResult<Prisma.$employee_rolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Employee_roles.
     * @param {employee_rolesDeleteManyArgs} args - Arguments to filter Employee_roles to delete.
     * @example
     * // Delete a few Employee_roles
     * const { count } = await prisma.employee_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employee_rolesDeleteManyArgs>(args?: SelectSubset<T, employee_rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employee_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employee_roles
     * const employee_roles = await prisma.employee_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employee_rolesUpdateManyArgs>(args: SelectSubset<T, employee_rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee_roles.
     * @param {employee_rolesUpsertArgs} args - Arguments to update or create a Employee_roles.
     * @example
     * // Update or create a Employee_roles
     * const employee_roles = await prisma.employee_roles.upsert({
     *   create: {
     *     // ... data to create a Employee_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee_roles we want to update
     *   }
     * })
     */
    upsert<T extends employee_rolesUpsertArgs>(args: SelectSubset<T, employee_rolesUpsertArgs<ExtArgs>>): Prisma__employee_rolesClient<$Result.GetResult<Prisma.$employee_rolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Employee_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_rolesCountArgs} args - Arguments to filter Employee_roles to count.
     * @example
     * // Count the number of Employee_roles
     * const count = await prisma.employee_roles.count({
     *   where: {
     *     // ... the filter for the Employee_roles we want to count
     *   }
     * })
    **/
    count<T extends employee_rolesCountArgs>(
      args?: Subset<T, employee_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Employee_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Employee_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Employee_rolesAggregateArgs>(args: Subset<T, Employee_rolesAggregateArgs>): Prisma.PrismaPromise<GetEmployee_rolesAggregateType<T>>

    /**
     * Group by Employee_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employee_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employee_rolesGroupByArgs['orderBy'] }
        : { orderBy?: employee_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employee_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployee_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employee_roles model
   */
  readonly fields: employee_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employee_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employee_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends employeesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeesDefaultArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employee_roles model
   */ 
  interface employee_rolesFieldRefs {
    readonly employee_id: FieldRef<"employee_roles", 'Int'>
    readonly role_id: FieldRef<"employee_roles", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * employee_roles findUnique
   */
  export type employee_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_roles
     */
    select?: employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_rolesInclude<ExtArgs> | null
    /**
     * Filter, which employee_roles to fetch.
     */
    where: employee_rolesWhereUniqueInput
  }

  /**
   * employee_roles findUniqueOrThrow
   */
  export type employee_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_roles
     */
    select?: employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_rolesInclude<ExtArgs> | null
    /**
     * Filter, which employee_roles to fetch.
     */
    where: employee_rolesWhereUniqueInput
  }

  /**
   * employee_roles findFirst
   */
  export type employee_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_roles
     */
    select?: employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_rolesInclude<ExtArgs> | null
    /**
     * Filter, which employee_roles to fetch.
     */
    where?: employee_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_roles to fetch.
     */
    orderBy?: employee_rolesOrderByWithRelationInput | employee_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employee_roles.
     */
    cursor?: employee_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employee_roles.
     */
    distinct?: Employee_rolesScalarFieldEnum | Employee_rolesScalarFieldEnum[]
  }

  /**
   * employee_roles findFirstOrThrow
   */
  export type employee_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_roles
     */
    select?: employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_rolesInclude<ExtArgs> | null
    /**
     * Filter, which employee_roles to fetch.
     */
    where?: employee_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_roles to fetch.
     */
    orderBy?: employee_rolesOrderByWithRelationInput | employee_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employee_roles.
     */
    cursor?: employee_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employee_roles.
     */
    distinct?: Employee_rolesScalarFieldEnum | Employee_rolesScalarFieldEnum[]
  }

  /**
   * employee_roles findMany
   */
  export type employee_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_roles
     */
    select?: employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_rolesInclude<ExtArgs> | null
    /**
     * Filter, which employee_roles to fetch.
     */
    where?: employee_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_roles to fetch.
     */
    orderBy?: employee_rolesOrderByWithRelationInput | employee_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employee_roles.
     */
    cursor?: employee_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_roles.
     */
    skip?: number
    distinct?: Employee_rolesScalarFieldEnum | Employee_rolesScalarFieldEnum[]
  }

  /**
   * employee_roles create
   */
  export type employee_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_roles
     */
    select?: employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a employee_roles.
     */
    data: XOR<employee_rolesCreateInput, employee_rolesUncheckedCreateInput>
  }

  /**
   * employee_roles createMany
   */
  export type employee_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employee_roles.
     */
    data: employee_rolesCreateManyInput | employee_rolesCreateManyInput[]
  }

  /**
   * employee_roles update
   */
  export type employee_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_roles
     */
    select?: employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a employee_roles.
     */
    data: XOR<employee_rolesUpdateInput, employee_rolesUncheckedUpdateInput>
    /**
     * Choose, which employee_roles to update.
     */
    where: employee_rolesWhereUniqueInput
  }

  /**
   * employee_roles updateMany
   */
  export type employee_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employee_roles.
     */
    data: XOR<employee_rolesUpdateManyMutationInput, employee_rolesUncheckedUpdateManyInput>
    /**
     * Filter which employee_roles to update
     */
    where?: employee_rolesWhereInput
  }

  /**
   * employee_roles upsert
   */
  export type employee_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_roles
     */
    select?: employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the employee_roles to update in case it exists.
     */
    where: employee_rolesWhereUniqueInput
    /**
     * In case the employee_roles found by the `where` argument doesn't exist, create a new employee_roles with this data.
     */
    create: XOR<employee_rolesCreateInput, employee_rolesUncheckedCreateInput>
    /**
     * In case the employee_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employee_rolesUpdateInput, employee_rolesUncheckedUpdateInput>
  }

  /**
   * employee_roles delete
   */
  export type employee_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_roles
     */
    select?: employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_rolesInclude<ExtArgs> | null
    /**
     * Filter which employee_roles to delete.
     */
    where: employee_rolesWhereUniqueInput
  }

  /**
   * employee_roles deleteMany
   */
  export type employee_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee_roles to delete
     */
    where?: employee_rolesWhereInput
  }

  /**
   * employee_roles without action
   */
  export type employee_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_roles
     */
    select?: employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_rolesInclude<ExtArgs> | null
  }


  /**
   * Model employees
   */

  export type AggregateEmployees = {
    _count: EmployeesCountAggregateOutputType | null
    _avg: EmployeesAvgAggregateOutputType | null
    _sum: EmployeesSumAggregateOutputType | null
    _min: EmployeesMinAggregateOutputType | null
    _max: EmployeesMaxAggregateOutputType | null
  }

  export type EmployeesAvgAggregateOutputType = {
    id: number | null
    department_id: number | null
  }

  export type EmployeesSumAggregateOutputType = {
    id: number | null
    department_id: number | null
  }

  export type EmployeesMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    employee_code: string | null
    department_id: number | null
    is_dept_head: boolean | null
    is_active: boolean | null
  }

  export type EmployeesMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    employee_code: string | null
    department_id: number | null
    is_dept_head: boolean | null
    is_active: boolean | null
  }

  export type EmployeesCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    employee_code: number
    department_id: number
    is_dept_head: number
    is_active: number
    _all: number
  }


  export type EmployeesAvgAggregateInputType = {
    id?: true
    department_id?: true
  }

  export type EmployeesSumAggregateInputType = {
    id?: true
    department_id?: true
  }

  export type EmployeesMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    employee_code?: true
    department_id?: true
    is_dept_head?: true
    is_active?: true
  }

  export type EmployeesMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    employee_code?: true
    department_id?: true
    is_dept_head?: true
    is_active?: true
  }

  export type EmployeesCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    employee_code?: true
    department_id?: true
    is_dept_head?: true
    is_active?: true
    _all?: true
  }

  export type EmployeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employees to aggregate.
     */
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeesOrderByWithRelationInput | employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employees
    **/
    _count?: true | EmployeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeesMaxAggregateInputType
  }

  export type GetEmployeesAggregateType<T extends EmployeesAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployees[P]>
      : GetScalarType<T[P], AggregateEmployees[P]>
  }




  export type employeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeesWhereInput
    orderBy?: employeesOrderByWithAggregationInput | employeesOrderByWithAggregationInput[]
    by: EmployeesScalarFieldEnum[] | EmployeesScalarFieldEnum
    having?: employeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeesCountAggregateInputType | true
    _avg?: EmployeesAvgAggregateInputType
    _sum?: EmployeesSumAggregateInputType
    _min?: EmployeesMinAggregateInputType
    _max?: EmployeesMaxAggregateInputType
  }

  export type EmployeesGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    employee_code: string
    department_id: number
    is_dept_head: boolean
    is_active: boolean
    _count: EmployeesCountAggregateOutputType | null
    _avg: EmployeesAvgAggregateOutputType | null
    _sum: EmployeesSumAggregateOutputType | null
    _min: EmployeesMinAggregateOutputType | null
    _max: EmployeesMaxAggregateOutputType | null
  }

  type GetEmployeesGroupByPayload<T extends employeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeesGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeesGroupByOutputType[P]>
        }
      >
    >


  export type employeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    employee_code?: boolean
    department_id?: boolean
    is_dept_head?: boolean
    is_active?: boolean
    employee_roles?: boolean | employees$employee_rolesArgs<ExtArgs>
    departments?: boolean | departmentsDefaultArgs<ExtArgs>
    _count?: boolean | EmployeesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employees"]>


  export type employeesSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    employee_code?: boolean
    department_id?: boolean
    is_dept_head?: boolean
    is_active?: boolean
  }

  export type employeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee_roles?: boolean | employees$employee_rolesArgs<ExtArgs>
    departments?: boolean | departmentsDefaultArgs<ExtArgs>
    _count?: boolean | EmployeesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $employeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employees"
    objects: {
      employee_roles: Prisma.$employee_rolesPayload<ExtArgs>[]
      departments: Prisma.$departmentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      employee_code: string
      department_id: number
      is_dept_head: boolean
      is_active: boolean
    }, ExtArgs["result"]["employees"]>
    composites: {}
  }

  type employeesGetPayload<S extends boolean | null | undefined | employeesDefaultArgs> = $Result.GetResult<Prisma.$employeesPayload, S>

  type employeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<employeesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeesCountAggregateInputType | true
    }

  export interface employeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employees'], meta: { name: 'employees' } }
    /**
     * Find zero or one Employees that matches the filter.
     * @param {employeesFindUniqueArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employeesFindUniqueArgs>(args: SelectSubset<T, employeesFindUniqueArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Employees that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {employeesFindUniqueOrThrowArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employeesFindUniqueOrThrowArgs>(args: SelectSubset<T, employeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesFindFirstArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employeesFindFirstArgs>(args?: SelectSubset<T, employeesFindFirstArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Employees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesFindFirstOrThrowArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employeesFindFirstOrThrowArgs>(args?: SelectSubset<T, employeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employees.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeesWithIdOnly = await prisma.employees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends employeesFindManyArgs>(args?: SelectSubset<T, employeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Employees.
     * @param {employeesCreateArgs} args - Arguments to create a Employees.
     * @example
     * // Create one Employees
     * const Employees = await prisma.employees.create({
     *   data: {
     *     // ... data to create a Employees
     *   }
     * })
     * 
     */
    create<T extends employeesCreateArgs>(args: SelectSubset<T, employeesCreateArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Employees.
     * @param {employeesCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employees = await prisma.employees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employeesCreateManyArgs>(args?: SelectSubset<T, employeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employees.
     * @param {employeesDeleteArgs} args - Arguments to delete one Employees.
     * @example
     * // Delete one Employees
     * const Employees = await prisma.employees.delete({
     *   where: {
     *     // ... filter to delete one Employees
     *   }
     * })
     * 
     */
    delete<T extends employeesDeleteArgs>(args: SelectSubset<T, employeesDeleteArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Employees.
     * @param {employeesUpdateArgs} args - Arguments to update one Employees.
     * @example
     * // Update one Employees
     * const employees = await prisma.employees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employeesUpdateArgs>(args: SelectSubset<T, employeesUpdateArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Employees.
     * @param {employeesDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employeesDeleteManyArgs>(args?: SelectSubset<T, employeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employees = await prisma.employees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employeesUpdateManyArgs>(args: SelectSubset<T, employeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employees.
     * @param {employeesUpsertArgs} args - Arguments to update or create a Employees.
     * @example
     * // Update or create a Employees
     * const employees = await prisma.employees.upsert({
     *   create: {
     *     // ... data to create a Employees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employees we want to update
     *   }
     * })
     */
    upsert<T extends employeesUpsertArgs>(args: SelectSubset<T, employeesUpsertArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employees.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends employeesCountArgs>(
      args?: Subset<T, employeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeesAggregateArgs>(args: Subset<T, EmployeesAggregateArgs>): Prisma.PrismaPromise<GetEmployeesAggregateType<T>>

    /**
     * Group by Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employeesGroupByArgs['orderBy'] }
        : { orderBy?: employeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employees model
   */
  readonly fields: employeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee_roles<T extends employees$employee_rolesArgs<ExtArgs> = {}>(args?: Subset<T, employees$employee_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_rolesPayload<ExtArgs>, T, "findMany"> | Null>
    departments<T extends departmentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, departmentsDefaultArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employees model
   */ 
  interface employeesFieldRefs {
    readonly id: FieldRef<"employees", 'Int'>
    readonly first_name: FieldRef<"employees", 'String'>
    readonly last_name: FieldRef<"employees", 'String'>
    readonly employee_code: FieldRef<"employees", 'String'>
    readonly department_id: FieldRef<"employees", 'Int'>
    readonly is_dept_head: FieldRef<"employees", 'Boolean'>
    readonly is_active: FieldRef<"employees", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * employees findUnique
   */
  export type employeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where: employeesWhereUniqueInput
  }

  /**
   * employees findUniqueOrThrow
   */
  export type employeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where: employeesWhereUniqueInput
  }

  /**
   * employees findFirst
   */
  export type employeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeesOrderByWithRelationInput | employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * employees findFirstOrThrow
   */
  export type employeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeesOrderByWithRelationInput | employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * employees findMany
   */
  export type employeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeesOrderByWithRelationInput | employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employees.
     */
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * employees create
   */
  export type employeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * The data needed to create a employees.
     */
    data: XOR<employeesCreateInput, employeesUncheckedCreateInput>
  }

  /**
   * employees createMany
   */
  export type employeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employees.
     */
    data: employeesCreateManyInput | employeesCreateManyInput[]
  }

  /**
   * employees update
   */
  export type employeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * The data needed to update a employees.
     */
    data: XOR<employeesUpdateInput, employeesUncheckedUpdateInput>
    /**
     * Choose, which employees to update.
     */
    where: employeesWhereUniqueInput
  }

  /**
   * employees updateMany
   */
  export type employeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employees.
     */
    data: XOR<employeesUpdateManyMutationInput, employeesUncheckedUpdateManyInput>
    /**
     * Filter which employees to update
     */
    where?: employeesWhereInput
  }

  /**
   * employees upsert
   */
  export type employeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * The filter to search for the employees to update in case it exists.
     */
    where: employeesWhereUniqueInput
    /**
     * In case the employees found by the `where` argument doesn't exist, create a new employees with this data.
     */
    create: XOR<employeesCreateInput, employeesUncheckedCreateInput>
    /**
     * In case the employees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employeesUpdateInput, employeesUncheckedUpdateInput>
  }

  /**
   * employees delete
   */
  export type employeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter which employees to delete.
     */
    where: employeesWhereUniqueInput
  }

  /**
   * employees deleteMany
   */
  export type employeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employees to delete
     */
    where?: employeesWhereInput
  }

  /**
   * employees.employee_roles
   */
  export type employees$employee_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_roles
     */
    select?: employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_rolesInclude<ExtArgs> | null
    where?: employee_rolesWhereInput
    orderBy?: employee_rolesOrderByWithRelationInput | employee_rolesOrderByWithRelationInput[]
    cursor?: employee_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Employee_rolesScalarFieldEnum | Employee_rolesScalarFieldEnum[]
  }

  /**
   * employees without action
   */
  export type employeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
  }


  /**
   * Model InventoryCategory
   */

  export type AggregateInventoryCategory = {
    _count: InventoryCategoryCountAggregateOutputType | null
    _avg: InventoryCategoryAvgAggregateOutputType | null
    _sum: InventoryCategorySumAggregateOutputType | null
    _min: InventoryCategoryMinAggregateOutputType | null
    _max: InventoryCategoryMaxAggregateOutputType | null
  }

  export type InventoryCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type InventoryCategorySumAggregateOutputType = {
    id: number | null
  }

  export type InventoryCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type InventoryCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type InventoryCategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type InventoryCategoryAvgAggregateInputType = {
    id?: true
  }

  export type InventoryCategorySumAggregateInputType = {
    id?: true
  }

  export type InventoryCategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type InventoryCategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type InventoryCategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type InventoryCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryCategory to aggregate.
     */
    where?: InventoryCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryCategories to fetch.
     */
    orderBy?: InventoryCategoryOrderByWithRelationInput | InventoryCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryCategories
    **/
    _count?: true | InventoryCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryCategoryMaxAggregateInputType
  }

  export type GetInventoryCategoryAggregateType<T extends InventoryCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryCategory[P]>
      : GetScalarType<T[P], AggregateInventoryCategory[P]>
  }




  export type InventoryCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryCategoryWhereInput
    orderBy?: InventoryCategoryOrderByWithAggregationInput | InventoryCategoryOrderByWithAggregationInput[]
    by: InventoryCategoryScalarFieldEnum[] | InventoryCategoryScalarFieldEnum
    having?: InventoryCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCategoryCountAggregateInputType | true
    _avg?: InventoryCategoryAvgAggregateInputType
    _sum?: InventoryCategorySumAggregateInputType
    _min?: InventoryCategoryMinAggregateInputType
    _max?: InventoryCategoryMaxAggregateInputType
  }

  export type InventoryCategoryGroupByOutputType = {
    id: number
    name: string
    _count: InventoryCategoryCountAggregateOutputType | null
    _avg: InventoryCategoryAvgAggregateOutputType | null
    _sum: InventoryCategorySumAggregateOutputType | null
    _min: InventoryCategoryMinAggregateOutputType | null
    _max: InventoryCategoryMaxAggregateOutputType | null
  }

  type GetInventoryCategoryGroupByPayload<T extends InventoryCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryCategoryGroupByOutputType[P]>
        }
      >
    >


  export type InventoryCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    InventoryItem?: boolean | InventoryCategory$InventoryItemArgs<ExtArgs>
    _count?: boolean | InventoryCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryCategory"]>


  export type InventoryCategorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type InventoryCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InventoryItem?: boolean | InventoryCategory$InventoryItemArgs<ExtArgs>
    _count?: boolean | InventoryCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InventoryCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryCategory"
    objects: {
      InventoryItem: Prisma.$InventoryItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["inventoryCategory"]>
    composites: {}
  }

  type InventoryCategoryGetPayload<S extends boolean | null | undefined | InventoryCategoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryCategoryPayload, S>

  type InventoryCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryCategoryCountAggregateInputType | true
    }

  export interface InventoryCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryCategory'], meta: { name: 'InventoryCategory' } }
    /**
     * Find zero or one InventoryCategory that matches the filter.
     * @param {InventoryCategoryFindUniqueArgs} args - Arguments to find a InventoryCategory
     * @example
     * // Get one InventoryCategory
     * const inventoryCategory = await prisma.inventoryCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryCategoryFindUniqueArgs>(args: SelectSubset<T, InventoryCategoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryCategoryClient<$Result.GetResult<Prisma.$InventoryCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryCategoryFindUniqueOrThrowArgs} args - Arguments to find a InventoryCategory
     * @example
     * // Get one InventoryCategory
     * const inventoryCategory = await prisma.inventoryCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryCategoryClient<$Result.GetResult<Prisma.$InventoryCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCategoryFindFirstArgs} args - Arguments to find a InventoryCategory
     * @example
     * // Get one InventoryCategory
     * const inventoryCategory = await prisma.inventoryCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryCategoryFindFirstArgs>(args?: SelectSubset<T, InventoryCategoryFindFirstArgs<ExtArgs>>): Prisma__InventoryCategoryClient<$Result.GetResult<Prisma.$InventoryCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCategoryFindFirstOrThrowArgs} args - Arguments to find a InventoryCategory
     * @example
     * // Get one InventoryCategory
     * const inventoryCategory = await prisma.inventoryCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryCategoryClient<$Result.GetResult<Prisma.$InventoryCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryCategories
     * const inventoryCategories = await prisma.inventoryCategory.findMany()
     * 
     * // Get first 10 InventoryCategories
     * const inventoryCategories = await prisma.inventoryCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryCategoryWithIdOnly = await prisma.inventoryCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryCategoryFindManyArgs>(args?: SelectSubset<T, InventoryCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryCategory.
     * @param {InventoryCategoryCreateArgs} args - Arguments to create a InventoryCategory.
     * @example
     * // Create one InventoryCategory
     * const InventoryCategory = await prisma.inventoryCategory.create({
     *   data: {
     *     // ... data to create a InventoryCategory
     *   }
     * })
     * 
     */
    create<T extends InventoryCategoryCreateArgs>(args: SelectSubset<T, InventoryCategoryCreateArgs<ExtArgs>>): Prisma__InventoryCategoryClient<$Result.GetResult<Prisma.$InventoryCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryCategories.
     * @param {InventoryCategoryCreateManyArgs} args - Arguments to create many InventoryCategories.
     * @example
     * // Create many InventoryCategories
     * const inventoryCategory = await prisma.inventoryCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCategoryCreateManyArgs>(args?: SelectSubset<T, InventoryCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryCategory.
     * @param {InventoryCategoryDeleteArgs} args - Arguments to delete one InventoryCategory.
     * @example
     * // Delete one InventoryCategory
     * const InventoryCategory = await prisma.inventoryCategory.delete({
     *   where: {
     *     // ... filter to delete one InventoryCategory
     *   }
     * })
     * 
     */
    delete<T extends InventoryCategoryDeleteArgs>(args: SelectSubset<T, InventoryCategoryDeleteArgs<ExtArgs>>): Prisma__InventoryCategoryClient<$Result.GetResult<Prisma.$InventoryCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryCategory.
     * @param {InventoryCategoryUpdateArgs} args - Arguments to update one InventoryCategory.
     * @example
     * // Update one InventoryCategory
     * const inventoryCategory = await prisma.inventoryCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryCategoryUpdateArgs>(args: SelectSubset<T, InventoryCategoryUpdateArgs<ExtArgs>>): Prisma__InventoryCategoryClient<$Result.GetResult<Prisma.$InventoryCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryCategories.
     * @param {InventoryCategoryDeleteManyArgs} args - Arguments to filter InventoryCategories to delete.
     * @example
     * // Delete a few InventoryCategories
     * const { count } = await prisma.inventoryCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryCategoryDeleteManyArgs>(args?: SelectSubset<T, InventoryCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryCategories
     * const inventoryCategory = await prisma.inventoryCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryCategoryUpdateManyArgs>(args: SelectSubset<T, InventoryCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryCategory.
     * @param {InventoryCategoryUpsertArgs} args - Arguments to update or create a InventoryCategory.
     * @example
     * // Update or create a InventoryCategory
     * const inventoryCategory = await prisma.inventoryCategory.upsert({
     *   create: {
     *     // ... data to create a InventoryCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryCategory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryCategoryUpsertArgs>(args: SelectSubset<T, InventoryCategoryUpsertArgs<ExtArgs>>): Prisma__InventoryCategoryClient<$Result.GetResult<Prisma.$InventoryCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCategoryCountArgs} args - Arguments to filter InventoryCategories to count.
     * @example
     * // Count the number of InventoryCategories
     * const count = await prisma.inventoryCategory.count({
     *   where: {
     *     // ... the filter for the InventoryCategories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCategoryCountArgs>(
      args?: Subset<T, InventoryCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryCategoryAggregateArgs>(args: Subset<T, InventoryCategoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryCategoryAggregateType<T>>

    /**
     * Group by InventoryCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryCategoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryCategory model
   */
  readonly fields: InventoryCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    InventoryItem<T extends InventoryCategory$InventoryItemArgs<ExtArgs> = {}>(args?: Subset<T, InventoryCategory$InventoryItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryCategory model
   */ 
  interface InventoryCategoryFieldRefs {
    readonly id: FieldRef<"InventoryCategory", 'Int'>
    readonly name: FieldRef<"InventoryCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventoryCategory findUnique
   */
  export type InventoryCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCategory
     */
    select?: InventoryCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCategoryInclude<ExtArgs> | null
    /**
     * Filter, which InventoryCategory to fetch.
     */
    where: InventoryCategoryWhereUniqueInput
  }

  /**
   * InventoryCategory findUniqueOrThrow
   */
  export type InventoryCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCategory
     */
    select?: InventoryCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCategoryInclude<ExtArgs> | null
    /**
     * Filter, which InventoryCategory to fetch.
     */
    where: InventoryCategoryWhereUniqueInput
  }

  /**
   * InventoryCategory findFirst
   */
  export type InventoryCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCategory
     */
    select?: InventoryCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCategoryInclude<ExtArgs> | null
    /**
     * Filter, which InventoryCategory to fetch.
     */
    where?: InventoryCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryCategories to fetch.
     */
    orderBy?: InventoryCategoryOrderByWithRelationInput | InventoryCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryCategories.
     */
    cursor?: InventoryCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryCategories.
     */
    distinct?: InventoryCategoryScalarFieldEnum | InventoryCategoryScalarFieldEnum[]
  }

  /**
   * InventoryCategory findFirstOrThrow
   */
  export type InventoryCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCategory
     */
    select?: InventoryCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCategoryInclude<ExtArgs> | null
    /**
     * Filter, which InventoryCategory to fetch.
     */
    where?: InventoryCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryCategories to fetch.
     */
    orderBy?: InventoryCategoryOrderByWithRelationInput | InventoryCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryCategories.
     */
    cursor?: InventoryCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryCategories.
     */
    distinct?: InventoryCategoryScalarFieldEnum | InventoryCategoryScalarFieldEnum[]
  }

  /**
   * InventoryCategory findMany
   */
  export type InventoryCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCategory
     */
    select?: InventoryCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCategoryInclude<ExtArgs> | null
    /**
     * Filter, which InventoryCategories to fetch.
     */
    where?: InventoryCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryCategories to fetch.
     */
    orderBy?: InventoryCategoryOrderByWithRelationInput | InventoryCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryCategories.
     */
    cursor?: InventoryCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryCategories.
     */
    skip?: number
    distinct?: InventoryCategoryScalarFieldEnum | InventoryCategoryScalarFieldEnum[]
  }

  /**
   * InventoryCategory create
   */
  export type InventoryCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCategory
     */
    select?: InventoryCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryCategory.
     */
    data: XOR<InventoryCategoryCreateInput, InventoryCategoryUncheckedCreateInput>
  }

  /**
   * InventoryCategory createMany
   */
  export type InventoryCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryCategories.
     */
    data: InventoryCategoryCreateManyInput | InventoryCategoryCreateManyInput[]
  }

  /**
   * InventoryCategory update
   */
  export type InventoryCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCategory
     */
    select?: InventoryCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryCategory.
     */
    data: XOR<InventoryCategoryUpdateInput, InventoryCategoryUncheckedUpdateInput>
    /**
     * Choose, which InventoryCategory to update.
     */
    where: InventoryCategoryWhereUniqueInput
  }

  /**
   * InventoryCategory updateMany
   */
  export type InventoryCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryCategories.
     */
    data: XOR<InventoryCategoryUpdateManyMutationInput, InventoryCategoryUncheckedUpdateManyInput>
    /**
     * Filter which InventoryCategories to update
     */
    where?: InventoryCategoryWhereInput
  }

  /**
   * InventoryCategory upsert
   */
  export type InventoryCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCategory
     */
    select?: InventoryCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryCategory to update in case it exists.
     */
    where: InventoryCategoryWhereUniqueInput
    /**
     * In case the InventoryCategory found by the `where` argument doesn't exist, create a new InventoryCategory with this data.
     */
    create: XOR<InventoryCategoryCreateInput, InventoryCategoryUncheckedCreateInput>
    /**
     * In case the InventoryCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryCategoryUpdateInput, InventoryCategoryUncheckedUpdateInput>
  }

  /**
   * InventoryCategory delete
   */
  export type InventoryCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCategory
     */
    select?: InventoryCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCategoryInclude<ExtArgs> | null
    /**
     * Filter which InventoryCategory to delete.
     */
    where: InventoryCategoryWhereUniqueInput
  }

  /**
   * InventoryCategory deleteMany
   */
  export type InventoryCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryCategories to delete
     */
    where?: InventoryCategoryWhereInput
  }

  /**
   * InventoryCategory.InventoryItem
   */
  export type InventoryCategory$InventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryCategory without action
   */
  export type InventoryCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCategory
     */
    select?: InventoryCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCategoryInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    supplierId: number | null
    stock: number | null
    minStock: number | null
  }

  export type InventoryItemSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    supplierId: number | null
    stock: number | null
    minStock: number | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    barcode: string | null
    serialNumber: string | null
    categoryId: number | null
    supplierId: number | null
    stock: number | null
    minStock: number | null
    unit: string | null
    imagePath: string | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    barcode: string | null
    serialNumber: string | null
    categoryId: number | null
    supplierId: number | null
    stock: number | null
    minStock: number | null
    unit: string | null
    imagePath: string | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    barcode: number
    serialNumber: number
    categoryId: number
    supplierId: number
    stock: number
    minStock: number
    unit: number
    imagePath: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    id?: true
    categoryId?: true
    supplierId?: true
    stock?: true
    minStock?: true
  }

  export type InventoryItemSumAggregateInputType = {
    id?: true
    categoryId?: true
    supplierId?: true
    stock?: true
    minStock?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    barcode?: true
    serialNumber?: true
    categoryId?: true
    supplierId?: true
    stock?: true
    minStock?: true
    unit?: true
    imagePath?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    barcode?: true
    serialNumber?: true
    categoryId?: true
    supplierId?: true
    stock?: true
    minStock?: true
    unit?: true
    imagePath?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    barcode?: true
    serialNumber?: true
    categoryId?: true
    supplierId?: true
    stock?: true
    minStock?: true
    unit?: true
    imagePath?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: number
    name: string
    description: string | null
    barcode: string | null
    serialNumber: string | null
    categoryId: number
    supplierId: number | null
    stock: number
    minStock: number
    unit: string | null
    imagePath: string | null
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    barcode?: boolean
    serialNumber?: boolean
    categoryId?: boolean
    supplierId?: boolean
    stock?: boolean
    minStock?: boolean
    unit?: boolean
    imagePath?: boolean
    InventoryCategory?: boolean | InventoryCategoryDefaultArgs<ExtArgs>
    InventorySupplier?: boolean | InventoryItem$InventorySupplierArgs<ExtArgs>
    InventoryTransaction?: boolean | InventoryItem$InventoryTransactionArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>


  export type InventoryItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    barcode?: boolean
    serialNumber?: boolean
    categoryId?: boolean
    supplierId?: boolean
    stock?: boolean
    minStock?: boolean
    unit?: boolean
    imagePath?: boolean
  }

  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InventoryCategory?: boolean | InventoryCategoryDefaultArgs<ExtArgs>
    InventorySupplier?: boolean | InventoryItem$InventorySupplierArgs<ExtArgs>
    InventoryTransaction?: boolean | InventoryItem$InventoryTransactionArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      InventoryCategory: Prisma.$InventoryCategoryPayload<ExtArgs>
      InventorySupplier: Prisma.$InventorySupplierPayload<ExtArgs> | null
      InventoryTransaction: Prisma.$InventoryTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      barcode: string | null
      serialNumber: string | null
      categoryId: number
      supplierId: number | null
      stock: number
      minStock: number
      unit: string | null
      imagePath: string | null
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    InventoryCategory<T extends InventoryCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryCategoryDefaultArgs<ExtArgs>>): Prisma__InventoryCategoryClient<$Result.GetResult<Prisma.$InventoryCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    InventorySupplier<T extends InventoryItem$InventorySupplierArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$InventorySupplierArgs<ExtArgs>>): Prisma__InventorySupplierClient<$Result.GetResult<Prisma.$InventorySupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    InventoryTransaction<T extends InventoryItem$InventoryTransactionArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$InventoryTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */ 
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'Int'>
    readonly name: FieldRef<"InventoryItem", 'String'>
    readonly description: FieldRef<"InventoryItem", 'String'>
    readonly barcode: FieldRef<"InventoryItem", 'String'>
    readonly serialNumber: FieldRef<"InventoryItem", 'String'>
    readonly categoryId: FieldRef<"InventoryItem", 'Int'>
    readonly supplierId: FieldRef<"InventoryItem", 'Int'>
    readonly stock: FieldRef<"InventoryItem", 'Int'>
    readonly minStock: FieldRef<"InventoryItem", 'Int'>
    readonly unit: FieldRef<"InventoryItem", 'String'>
    readonly imagePath: FieldRef<"InventoryItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
  }

  /**
   * InventoryItem.InventorySupplier
   */
  export type InventoryItem$InventorySupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySupplier
     */
    select?: InventorySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySupplierInclude<ExtArgs> | null
    where?: InventorySupplierWhereInput
  }

  /**
   * InventoryItem.InventoryTransaction
   */
  export type InventoryItem$InventoryTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    cursor?: InventoryTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model InventorySupplier
   */

  export type AggregateInventorySupplier = {
    _count: InventorySupplierCountAggregateOutputType | null
    _avg: InventorySupplierAvgAggregateOutputType | null
    _sum: InventorySupplierSumAggregateOutputType | null
    _min: InventorySupplierMinAggregateOutputType | null
    _max: InventorySupplierMaxAggregateOutputType | null
  }

  export type InventorySupplierAvgAggregateOutputType = {
    id: number | null
  }

  export type InventorySupplierSumAggregateOutputType = {
    id: number | null
  }

  export type InventorySupplierMinAggregateOutputType = {
    id: number | null
    name: string | null
    contact: string | null
    email: string | null
    phone: string | null
  }

  export type InventorySupplierMaxAggregateOutputType = {
    id: number | null
    name: string | null
    contact: string | null
    email: string | null
    phone: string | null
  }

  export type InventorySupplierCountAggregateOutputType = {
    id: number
    name: number
    contact: number
    email: number
    phone: number
    _all: number
  }


  export type InventorySupplierAvgAggregateInputType = {
    id?: true
  }

  export type InventorySupplierSumAggregateInputType = {
    id?: true
  }

  export type InventorySupplierMinAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    email?: true
    phone?: true
  }

  export type InventorySupplierMaxAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    email?: true
    phone?: true
  }

  export type InventorySupplierCountAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    email?: true
    phone?: true
    _all?: true
  }

  export type InventorySupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventorySupplier to aggregate.
     */
    where?: InventorySupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySuppliers to fetch.
     */
    orderBy?: InventorySupplierOrderByWithRelationInput | InventorySupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventorySupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventorySuppliers
    **/
    _count?: true | InventorySupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventorySupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventorySupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventorySupplierMaxAggregateInputType
  }

  export type GetInventorySupplierAggregateType<T extends InventorySupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateInventorySupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventorySupplier[P]>
      : GetScalarType<T[P], AggregateInventorySupplier[P]>
  }




  export type InventorySupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventorySupplierWhereInput
    orderBy?: InventorySupplierOrderByWithAggregationInput | InventorySupplierOrderByWithAggregationInput[]
    by: InventorySupplierScalarFieldEnum[] | InventorySupplierScalarFieldEnum
    having?: InventorySupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventorySupplierCountAggregateInputType | true
    _avg?: InventorySupplierAvgAggregateInputType
    _sum?: InventorySupplierSumAggregateInputType
    _min?: InventorySupplierMinAggregateInputType
    _max?: InventorySupplierMaxAggregateInputType
  }

  export type InventorySupplierGroupByOutputType = {
    id: number
    name: string
    contact: string | null
    email: string | null
    phone: string | null
    _count: InventorySupplierCountAggregateOutputType | null
    _avg: InventorySupplierAvgAggregateOutputType | null
    _sum: InventorySupplierSumAggregateOutputType | null
    _min: InventorySupplierMinAggregateOutputType | null
    _max: InventorySupplierMaxAggregateOutputType | null
  }

  type GetInventorySupplierGroupByPayload<T extends InventorySupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventorySupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventorySupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventorySupplierGroupByOutputType[P]>
            : GetScalarType<T[P], InventorySupplierGroupByOutputType[P]>
        }
      >
    >


  export type InventorySupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    phone?: boolean
    InventoryItem?: boolean | InventorySupplier$InventoryItemArgs<ExtArgs>
    _count?: boolean | InventorySupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventorySupplier"]>


  export type InventorySupplierSelectScalar = {
    id?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    phone?: boolean
  }

  export type InventorySupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InventoryItem?: boolean | InventorySupplier$InventoryItemArgs<ExtArgs>
    _count?: boolean | InventorySupplierCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InventorySupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventorySupplier"
    objects: {
      InventoryItem: Prisma.$InventoryItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      contact: string | null
      email: string | null
      phone: string | null
    }, ExtArgs["result"]["inventorySupplier"]>
    composites: {}
  }

  type InventorySupplierGetPayload<S extends boolean | null | undefined | InventorySupplierDefaultArgs> = $Result.GetResult<Prisma.$InventorySupplierPayload, S>

  type InventorySupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventorySupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventorySupplierCountAggregateInputType | true
    }

  export interface InventorySupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventorySupplier'], meta: { name: 'InventorySupplier' } }
    /**
     * Find zero or one InventorySupplier that matches the filter.
     * @param {InventorySupplierFindUniqueArgs} args - Arguments to find a InventorySupplier
     * @example
     * // Get one InventorySupplier
     * const inventorySupplier = await prisma.inventorySupplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventorySupplierFindUniqueArgs>(args: SelectSubset<T, InventorySupplierFindUniqueArgs<ExtArgs>>): Prisma__InventorySupplierClient<$Result.GetResult<Prisma.$InventorySupplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventorySupplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventorySupplierFindUniqueOrThrowArgs} args - Arguments to find a InventorySupplier
     * @example
     * // Get one InventorySupplier
     * const inventorySupplier = await prisma.inventorySupplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventorySupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, InventorySupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventorySupplierClient<$Result.GetResult<Prisma.$InventorySupplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventorySupplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySupplierFindFirstArgs} args - Arguments to find a InventorySupplier
     * @example
     * // Get one InventorySupplier
     * const inventorySupplier = await prisma.inventorySupplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventorySupplierFindFirstArgs>(args?: SelectSubset<T, InventorySupplierFindFirstArgs<ExtArgs>>): Prisma__InventorySupplierClient<$Result.GetResult<Prisma.$InventorySupplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventorySupplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySupplierFindFirstOrThrowArgs} args - Arguments to find a InventorySupplier
     * @example
     * // Get one InventorySupplier
     * const inventorySupplier = await prisma.inventorySupplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventorySupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, InventorySupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventorySupplierClient<$Result.GetResult<Prisma.$InventorySupplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventorySuppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventorySuppliers
     * const inventorySuppliers = await prisma.inventorySupplier.findMany()
     * 
     * // Get first 10 InventorySuppliers
     * const inventorySuppliers = await prisma.inventorySupplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventorySupplierWithIdOnly = await prisma.inventorySupplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventorySupplierFindManyArgs>(args?: SelectSubset<T, InventorySupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySupplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventorySupplier.
     * @param {InventorySupplierCreateArgs} args - Arguments to create a InventorySupplier.
     * @example
     * // Create one InventorySupplier
     * const InventorySupplier = await prisma.inventorySupplier.create({
     *   data: {
     *     // ... data to create a InventorySupplier
     *   }
     * })
     * 
     */
    create<T extends InventorySupplierCreateArgs>(args: SelectSubset<T, InventorySupplierCreateArgs<ExtArgs>>): Prisma__InventorySupplierClient<$Result.GetResult<Prisma.$InventorySupplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventorySuppliers.
     * @param {InventorySupplierCreateManyArgs} args - Arguments to create many InventorySuppliers.
     * @example
     * // Create many InventorySuppliers
     * const inventorySupplier = await prisma.inventorySupplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventorySupplierCreateManyArgs>(args?: SelectSubset<T, InventorySupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventorySupplier.
     * @param {InventorySupplierDeleteArgs} args - Arguments to delete one InventorySupplier.
     * @example
     * // Delete one InventorySupplier
     * const InventorySupplier = await prisma.inventorySupplier.delete({
     *   where: {
     *     // ... filter to delete one InventorySupplier
     *   }
     * })
     * 
     */
    delete<T extends InventorySupplierDeleteArgs>(args: SelectSubset<T, InventorySupplierDeleteArgs<ExtArgs>>): Prisma__InventorySupplierClient<$Result.GetResult<Prisma.$InventorySupplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventorySupplier.
     * @param {InventorySupplierUpdateArgs} args - Arguments to update one InventorySupplier.
     * @example
     * // Update one InventorySupplier
     * const inventorySupplier = await prisma.inventorySupplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventorySupplierUpdateArgs>(args: SelectSubset<T, InventorySupplierUpdateArgs<ExtArgs>>): Prisma__InventorySupplierClient<$Result.GetResult<Prisma.$InventorySupplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventorySuppliers.
     * @param {InventorySupplierDeleteManyArgs} args - Arguments to filter InventorySuppliers to delete.
     * @example
     * // Delete a few InventorySuppliers
     * const { count } = await prisma.inventorySupplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventorySupplierDeleteManyArgs>(args?: SelectSubset<T, InventorySupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventorySuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventorySuppliers
     * const inventorySupplier = await prisma.inventorySupplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventorySupplierUpdateManyArgs>(args: SelectSubset<T, InventorySupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventorySupplier.
     * @param {InventorySupplierUpsertArgs} args - Arguments to update or create a InventorySupplier.
     * @example
     * // Update or create a InventorySupplier
     * const inventorySupplier = await prisma.inventorySupplier.upsert({
     *   create: {
     *     // ... data to create a InventorySupplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventorySupplier we want to update
     *   }
     * })
     */
    upsert<T extends InventorySupplierUpsertArgs>(args: SelectSubset<T, InventorySupplierUpsertArgs<ExtArgs>>): Prisma__InventorySupplierClient<$Result.GetResult<Prisma.$InventorySupplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventorySuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySupplierCountArgs} args - Arguments to filter InventorySuppliers to count.
     * @example
     * // Count the number of InventorySuppliers
     * const count = await prisma.inventorySupplier.count({
     *   where: {
     *     // ... the filter for the InventorySuppliers we want to count
     *   }
     * })
    **/
    count<T extends InventorySupplierCountArgs>(
      args?: Subset<T, InventorySupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventorySupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventorySupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventorySupplierAggregateArgs>(args: Subset<T, InventorySupplierAggregateArgs>): Prisma.PrismaPromise<GetInventorySupplierAggregateType<T>>

    /**
     * Group by InventorySupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventorySupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventorySupplierGroupByArgs['orderBy'] }
        : { orderBy?: InventorySupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventorySupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventorySupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventorySupplier model
   */
  readonly fields: InventorySupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventorySupplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventorySupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    InventoryItem<T extends InventorySupplier$InventoryItemArgs<ExtArgs> = {}>(args?: Subset<T, InventorySupplier$InventoryItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventorySupplier model
   */ 
  interface InventorySupplierFieldRefs {
    readonly id: FieldRef<"InventorySupplier", 'Int'>
    readonly name: FieldRef<"InventorySupplier", 'String'>
    readonly contact: FieldRef<"InventorySupplier", 'String'>
    readonly email: FieldRef<"InventorySupplier", 'String'>
    readonly phone: FieldRef<"InventorySupplier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventorySupplier findUnique
   */
  export type InventorySupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySupplier
     */
    select?: InventorySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySupplierInclude<ExtArgs> | null
    /**
     * Filter, which InventorySupplier to fetch.
     */
    where: InventorySupplierWhereUniqueInput
  }

  /**
   * InventorySupplier findUniqueOrThrow
   */
  export type InventorySupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySupplier
     */
    select?: InventorySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySupplierInclude<ExtArgs> | null
    /**
     * Filter, which InventorySupplier to fetch.
     */
    where: InventorySupplierWhereUniqueInput
  }

  /**
   * InventorySupplier findFirst
   */
  export type InventorySupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySupplier
     */
    select?: InventorySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySupplierInclude<ExtArgs> | null
    /**
     * Filter, which InventorySupplier to fetch.
     */
    where?: InventorySupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySuppliers to fetch.
     */
    orderBy?: InventorySupplierOrderByWithRelationInput | InventorySupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventorySuppliers.
     */
    cursor?: InventorySupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventorySuppliers.
     */
    distinct?: InventorySupplierScalarFieldEnum | InventorySupplierScalarFieldEnum[]
  }

  /**
   * InventorySupplier findFirstOrThrow
   */
  export type InventorySupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySupplier
     */
    select?: InventorySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySupplierInclude<ExtArgs> | null
    /**
     * Filter, which InventorySupplier to fetch.
     */
    where?: InventorySupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySuppliers to fetch.
     */
    orderBy?: InventorySupplierOrderByWithRelationInput | InventorySupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventorySuppliers.
     */
    cursor?: InventorySupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventorySuppliers.
     */
    distinct?: InventorySupplierScalarFieldEnum | InventorySupplierScalarFieldEnum[]
  }

  /**
   * InventorySupplier findMany
   */
  export type InventorySupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySupplier
     */
    select?: InventorySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySupplierInclude<ExtArgs> | null
    /**
     * Filter, which InventorySuppliers to fetch.
     */
    where?: InventorySupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySuppliers to fetch.
     */
    orderBy?: InventorySupplierOrderByWithRelationInput | InventorySupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventorySuppliers.
     */
    cursor?: InventorySupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySuppliers.
     */
    skip?: number
    distinct?: InventorySupplierScalarFieldEnum | InventorySupplierScalarFieldEnum[]
  }

  /**
   * InventorySupplier create
   */
  export type InventorySupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySupplier
     */
    select?: InventorySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a InventorySupplier.
     */
    data: XOR<InventorySupplierCreateInput, InventorySupplierUncheckedCreateInput>
  }

  /**
   * InventorySupplier createMany
   */
  export type InventorySupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventorySuppliers.
     */
    data: InventorySupplierCreateManyInput | InventorySupplierCreateManyInput[]
  }

  /**
   * InventorySupplier update
   */
  export type InventorySupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySupplier
     */
    select?: InventorySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a InventorySupplier.
     */
    data: XOR<InventorySupplierUpdateInput, InventorySupplierUncheckedUpdateInput>
    /**
     * Choose, which InventorySupplier to update.
     */
    where: InventorySupplierWhereUniqueInput
  }

  /**
   * InventorySupplier updateMany
   */
  export type InventorySupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventorySuppliers.
     */
    data: XOR<InventorySupplierUpdateManyMutationInput, InventorySupplierUncheckedUpdateManyInput>
    /**
     * Filter which InventorySuppliers to update
     */
    where?: InventorySupplierWhereInput
  }

  /**
   * InventorySupplier upsert
   */
  export type InventorySupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySupplier
     */
    select?: InventorySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the InventorySupplier to update in case it exists.
     */
    where: InventorySupplierWhereUniqueInput
    /**
     * In case the InventorySupplier found by the `where` argument doesn't exist, create a new InventorySupplier with this data.
     */
    create: XOR<InventorySupplierCreateInput, InventorySupplierUncheckedCreateInput>
    /**
     * In case the InventorySupplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventorySupplierUpdateInput, InventorySupplierUncheckedUpdateInput>
  }

  /**
   * InventorySupplier delete
   */
  export type InventorySupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySupplier
     */
    select?: InventorySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySupplierInclude<ExtArgs> | null
    /**
     * Filter which InventorySupplier to delete.
     */
    where: InventorySupplierWhereUniqueInput
  }

  /**
   * InventorySupplier deleteMany
   */
  export type InventorySupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventorySuppliers to delete
     */
    where?: InventorySupplierWhereInput
  }

  /**
   * InventorySupplier.InventoryItem
   */
  export type InventorySupplier$InventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventorySupplier without action
   */
  export type InventorySupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySupplier
     */
    select?: InventorySupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySupplierInclude<ExtArgs> | null
  }


  /**
   * Model InventoryTransaction
   */

  export type AggregateInventoryTransaction = {
    _count: InventoryTransactionCountAggregateOutputType | null
    _avg: InventoryTransactionAvgAggregateOutputType | null
    _sum: InventoryTransactionSumAggregateOutputType | null
    _min: InventoryTransactionMinAggregateOutputType | null
    _max: InventoryTransactionMaxAggregateOutputType | null
  }

  export type InventoryTransactionAvgAggregateOutputType = {
    id: number | null
    itemId: number | null
    qty: number | null
    userId: number | null
  }

  export type InventoryTransactionSumAggregateOutputType = {
    id: number | null
    itemId: number | null
    qty: number | null
    userId: number | null
  }

  export type InventoryTransactionMinAggregateOutputType = {
    id: number | null
    itemId: number | null
    type: string | null
    qty: number | null
    userId: number | null
    date: Date | null
    note: string | null
    barcode: string | null
  }

  export type InventoryTransactionMaxAggregateOutputType = {
    id: number | null
    itemId: number | null
    type: string | null
    qty: number | null
    userId: number | null
    date: Date | null
    note: string | null
    barcode: string | null
  }

  export type InventoryTransactionCountAggregateOutputType = {
    id: number
    itemId: number
    type: number
    qty: number
    userId: number
    date: number
    note: number
    barcode: number
    _all: number
  }


  export type InventoryTransactionAvgAggregateInputType = {
    id?: true
    itemId?: true
    qty?: true
    userId?: true
  }

  export type InventoryTransactionSumAggregateInputType = {
    id?: true
    itemId?: true
    qty?: true
    userId?: true
  }

  export type InventoryTransactionMinAggregateInputType = {
    id?: true
    itemId?: true
    type?: true
    qty?: true
    userId?: true
    date?: true
    note?: true
    barcode?: true
  }

  export type InventoryTransactionMaxAggregateInputType = {
    id?: true
    itemId?: true
    type?: true
    qty?: true
    userId?: true
    date?: true
    note?: true
    barcode?: true
  }

  export type InventoryTransactionCountAggregateInputType = {
    id?: true
    itemId?: true
    type?: true
    qty?: true
    userId?: true
    date?: true
    note?: true
    barcode?: true
    _all?: true
  }

  export type InventoryTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryTransaction to aggregate.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryTransactions
    **/
    _count?: true | InventoryTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryTransactionMaxAggregateInputType
  }

  export type GetInventoryTransactionAggregateType<T extends InventoryTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryTransaction[P]>
      : GetScalarType<T[P], AggregateInventoryTransaction[P]>
  }




  export type InventoryTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithAggregationInput | InventoryTransactionOrderByWithAggregationInput[]
    by: InventoryTransactionScalarFieldEnum[] | InventoryTransactionScalarFieldEnum
    having?: InventoryTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryTransactionCountAggregateInputType | true
    _avg?: InventoryTransactionAvgAggregateInputType
    _sum?: InventoryTransactionSumAggregateInputType
    _min?: InventoryTransactionMinAggregateInputType
    _max?: InventoryTransactionMaxAggregateInputType
  }

  export type InventoryTransactionGroupByOutputType = {
    id: number
    itemId: number
    type: string
    qty: number
    userId: number | null
    date: Date
    note: string | null
    barcode: string | null
    _count: InventoryTransactionCountAggregateOutputType | null
    _avg: InventoryTransactionAvgAggregateOutputType | null
    _sum: InventoryTransactionSumAggregateOutputType | null
    _min: InventoryTransactionMinAggregateOutputType | null
    _max: InventoryTransactionMaxAggregateOutputType | null
  }

  type GetInventoryTransactionGroupByPayload<T extends InventoryTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryTransactionGroupByOutputType[P]>
        }
      >
    >


  export type InventoryTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    type?: boolean
    qty?: boolean
    userId?: boolean
    date?: boolean
    note?: boolean
    barcode?: boolean
    InventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    User?: boolean | InventoryTransaction$UserArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryTransaction"]>


  export type InventoryTransactionSelectScalar = {
    id?: boolean
    itemId?: boolean
    type?: boolean
    qty?: boolean
    userId?: boolean
    date?: boolean
    note?: boolean
    barcode?: boolean
  }

  export type InventoryTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    User?: boolean | InventoryTransaction$UserArgs<ExtArgs>
  }

  export type $InventoryTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryTransaction"
    objects: {
      InventoryItem: Prisma.$InventoryItemPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemId: number
      type: string
      qty: number
      userId: number | null
      date: Date
      note: string | null
      barcode: string | null
    }, ExtArgs["result"]["inventoryTransaction"]>
    composites: {}
  }

  type InventoryTransactionGetPayload<S extends boolean | null | undefined | InventoryTransactionDefaultArgs> = $Result.GetResult<Prisma.$InventoryTransactionPayload, S>

  type InventoryTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryTransactionCountAggregateInputType | true
    }

  export interface InventoryTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryTransaction'], meta: { name: 'InventoryTransaction' } }
    /**
     * Find zero or one InventoryTransaction that matches the filter.
     * @param {InventoryTransactionFindUniqueArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryTransactionFindUniqueArgs>(args: SelectSubset<T, InventoryTransactionFindUniqueArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryTransactionFindUniqueOrThrowArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindFirstArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryTransactionFindFirstArgs>(args?: SelectSubset<T, InventoryTransactionFindFirstArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindFirstOrThrowArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryTransactions
     * const inventoryTransactions = await prisma.inventoryTransaction.findMany()
     * 
     * // Get first 10 InventoryTransactions
     * const inventoryTransactions = await prisma.inventoryTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryTransactionWithIdOnly = await prisma.inventoryTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryTransactionFindManyArgs>(args?: SelectSubset<T, InventoryTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryTransaction.
     * @param {InventoryTransactionCreateArgs} args - Arguments to create a InventoryTransaction.
     * @example
     * // Create one InventoryTransaction
     * const InventoryTransaction = await prisma.inventoryTransaction.create({
     *   data: {
     *     // ... data to create a InventoryTransaction
     *   }
     * })
     * 
     */
    create<T extends InventoryTransactionCreateArgs>(args: SelectSubset<T, InventoryTransactionCreateArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryTransactions.
     * @param {InventoryTransactionCreateManyArgs} args - Arguments to create many InventoryTransactions.
     * @example
     * // Create many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryTransactionCreateManyArgs>(args?: SelectSubset<T, InventoryTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryTransaction.
     * @param {InventoryTransactionDeleteArgs} args - Arguments to delete one InventoryTransaction.
     * @example
     * // Delete one InventoryTransaction
     * const InventoryTransaction = await prisma.inventoryTransaction.delete({
     *   where: {
     *     // ... filter to delete one InventoryTransaction
     *   }
     * })
     * 
     */
    delete<T extends InventoryTransactionDeleteArgs>(args: SelectSubset<T, InventoryTransactionDeleteArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryTransaction.
     * @param {InventoryTransactionUpdateArgs} args - Arguments to update one InventoryTransaction.
     * @example
     * // Update one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryTransactionUpdateArgs>(args: SelectSubset<T, InventoryTransactionUpdateArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryTransactions.
     * @param {InventoryTransactionDeleteManyArgs} args - Arguments to filter InventoryTransactions to delete.
     * @example
     * // Delete a few InventoryTransactions
     * const { count } = await prisma.inventoryTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryTransactionDeleteManyArgs>(args?: SelectSubset<T, InventoryTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryTransactionUpdateManyArgs>(args: SelectSubset<T, InventoryTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryTransaction.
     * @param {InventoryTransactionUpsertArgs} args - Arguments to update or create a InventoryTransaction.
     * @example
     * // Update or create a InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.upsert({
     *   create: {
     *     // ... data to create a InventoryTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryTransaction we want to update
     *   }
     * })
     */
    upsert<T extends InventoryTransactionUpsertArgs>(args: SelectSubset<T, InventoryTransactionUpsertArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionCountArgs} args - Arguments to filter InventoryTransactions to count.
     * @example
     * // Count the number of InventoryTransactions
     * const count = await prisma.inventoryTransaction.count({
     *   where: {
     *     // ... the filter for the InventoryTransactions we want to count
     *   }
     * })
    **/
    count<T extends InventoryTransactionCountArgs>(
      args?: Subset<T, InventoryTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryTransactionAggregateArgs>(args: Subset<T, InventoryTransactionAggregateArgs>): Prisma.PrismaPromise<GetInventoryTransactionAggregateType<T>>

    /**
     * Group by InventoryTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryTransactionGroupByArgs['orderBy'] }
        : { orderBy?: InventoryTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryTransaction model
   */
  readonly fields: InventoryTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    InventoryItem<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    User<T extends InventoryTransaction$UserArgs<ExtArgs> = {}>(args?: Subset<T, InventoryTransaction$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryTransaction model
   */ 
  interface InventoryTransactionFieldRefs {
    readonly id: FieldRef<"InventoryTransaction", 'Int'>
    readonly itemId: FieldRef<"InventoryTransaction", 'Int'>
    readonly type: FieldRef<"InventoryTransaction", 'String'>
    readonly qty: FieldRef<"InventoryTransaction", 'Int'>
    readonly userId: FieldRef<"InventoryTransaction", 'Int'>
    readonly date: FieldRef<"InventoryTransaction", 'DateTime'>
    readonly note: FieldRef<"InventoryTransaction", 'String'>
    readonly barcode: FieldRef<"InventoryTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventoryTransaction findUnique
   */
  export type InventoryTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction findUniqueOrThrow
   */
  export type InventoryTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction findFirst
   */
  export type InventoryTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryTransactions.
     */
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction findFirstOrThrow
   */
  export type InventoryTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryTransactions.
     */
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction findMany
   */
  export type InventoryTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransactions to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction create
   */
  export type InventoryTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryTransaction.
     */
    data: XOR<InventoryTransactionCreateInput, InventoryTransactionUncheckedCreateInput>
  }

  /**
   * InventoryTransaction createMany
   */
  export type InventoryTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryTransactions.
     */
    data: InventoryTransactionCreateManyInput | InventoryTransactionCreateManyInput[]
  }

  /**
   * InventoryTransaction update
   */
  export type InventoryTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryTransaction.
     */
    data: XOR<InventoryTransactionUpdateInput, InventoryTransactionUncheckedUpdateInput>
    /**
     * Choose, which InventoryTransaction to update.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction updateMany
   */
  export type InventoryTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryTransactions.
     */
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyInput>
    /**
     * Filter which InventoryTransactions to update
     */
    where?: InventoryTransactionWhereInput
  }

  /**
   * InventoryTransaction upsert
   */
  export type InventoryTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryTransaction to update in case it exists.
     */
    where: InventoryTransactionWhereUniqueInput
    /**
     * In case the InventoryTransaction found by the `where` argument doesn't exist, create a new InventoryTransaction with this data.
     */
    create: XOR<InventoryTransactionCreateInput, InventoryTransactionUncheckedCreateInput>
    /**
     * In case the InventoryTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryTransactionUpdateInput, InventoryTransactionUncheckedUpdateInput>
  }

  /**
   * InventoryTransaction delete
   */
  export type InventoryTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter which InventoryTransaction to delete.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction deleteMany
   */
  export type InventoryTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryTransactions to delete
     */
    where?: InventoryTransactionWhereInput
  }

  /**
   * InventoryTransaction.User
   */
  export type InventoryTransaction$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * InventoryTransaction without action
   */
  export type InventoryTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
  }


  /**
   * Model it_departments
   */

  export type AggregateIt_departments = {
    _count: It_departmentsCountAggregateOutputType | null
    _avg: It_departmentsAvgAggregateOutputType | null
    _sum: It_departmentsSumAggregateOutputType | null
    _min: It_departmentsMinAggregateOutputType | null
    _max: It_departmentsMaxAggregateOutputType | null
  }

  export type It_departmentsAvgAggregateOutputType = {
    id: number | null
  }

  export type It_departmentsSumAggregateOutputType = {
    id: number | null
  }

  export type It_departmentsMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type It_departmentsMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type It_departmentsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type It_departmentsAvgAggregateInputType = {
    id?: true
  }

  export type It_departmentsSumAggregateInputType = {
    id?: true
  }

  export type It_departmentsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type It_departmentsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type It_departmentsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type It_departmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which it_departments to aggregate.
     */
    where?: it_departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_departments to fetch.
     */
    orderBy?: it_departmentsOrderByWithRelationInput | it_departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: it_departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned it_departments
    **/
    _count?: true | It_departmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: It_departmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: It_departmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: It_departmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: It_departmentsMaxAggregateInputType
  }

  export type GetIt_departmentsAggregateType<T extends It_departmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateIt_departments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIt_departments[P]>
      : GetScalarType<T[P], AggregateIt_departments[P]>
  }




  export type it_departmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: it_departmentsWhereInput
    orderBy?: it_departmentsOrderByWithAggregationInput | it_departmentsOrderByWithAggregationInput[]
    by: It_departmentsScalarFieldEnum[] | It_departmentsScalarFieldEnum
    having?: it_departmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: It_departmentsCountAggregateInputType | true
    _avg?: It_departmentsAvgAggregateInputType
    _sum?: It_departmentsSumAggregateInputType
    _min?: It_departmentsMinAggregateInputType
    _max?: It_departmentsMaxAggregateInputType
  }

  export type It_departmentsGroupByOutputType = {
    id: number
    name: string
    _count: It_departmentsCountAggregateOutputType | null
    _avg: It_departmentsAvgAggregateOutputType | null
    _sum: It_departmentsSumAggregateOutputType | null
    _min: It_departmentsMinAggregateOutputType | null
    _max: It_departmentsMaxAggregateOutputType | null
  }

  type GetIt_departmentsGroupByPayload<T extends it_departmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<It_departmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof It_departmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], It_departmentsGroupByOutputType[P]>
            : GetScalarType<T[P], It_departmentsGroupByOutputType[P]>
        }
      >
    >


  export type it_departmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    it_employees?: boolean | it_departments$it_employeesArgs<ExtArgs>
    _count?: boolean | It_departmentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["it_departments"]>


  export type it_departmentsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type it_departmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    it_employees?: boolean | it_departments$it_employeesArgs<ExtArgs>
    _count?: boolean | It_departmentsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $it_departmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "it_departments"
    objects: {
      it_employees: Prisma.$it_employeesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["it_departments"]>
    composites: {}
  }

  type it_departmentsGetPayload<S extends boolean | null | undefined | it_departmentsDefaultArgs> = $Result.GetResult<Prisma.$it_departmentsPayload, S>

  type it_departmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<it_departmentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: It_departmentsCountAggregateInputType | true
    }

  export interface it_departmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['it_departments'], meta: { name: 'it_departments' } }
    /**
     * Find zero or one It_departments that matches the filter.
     * @param {it_departmentsFindUniqueArgs} args - Arguments to find a It_departments
     * @example
     * // Get one It_departments
     * const it_departments = await prisma.it_departments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends it_departmentsFindUniqueArgs>(args: SelectSubset<T, it_departmentsFindUniqueArgs<ExtArgs>>): Prisma__it_departmentsClient<$Result.GetResult<Prisma.$it_departmentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one It_departments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {it_departmentsFindUniqueOrThrowArgs} args - Arguments to find a It_departments
     * @example
     * // Get one It_departments
     * const it_departments = await prisma.it_departments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends it_departmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, it_departmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__it_departmentsClient<$Result.GetResult<Prisma.$it_departmentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first It_departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_departmentsFindFirstArgs} args - Arguments to find a It_departments
     * @example
     * // Get one It_departments
     * const it_departments = await prisma.it_departments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends it_departmentsFindFirstArgs>(args?: SelectSubset<T, it_departmentsFindFirstArgs<ExtArgs>>): Prisma__it_departmentsClient<$Result.GetResult<Prisma.$it_departmentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first It_departments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_departmentsFindFirstOrThrowArgs} args - Arguments to find a It_departments
     * @example
     * // Get one It_departments
     * const it_departments = await prisma.it_departments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends it_departmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, it_departmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__it_departmentsClient<$Result.GetResult<Prisma.$it_departmentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more It_departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_departmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all It_departments
     * const it_departments = await prisma.it_departments.findMany()
     * 
     * // Get first 10 It_departments
     * const it_departments = await prisma.it_departments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const it_departmentsWithIdOnly = await prisma.it_departments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends it_departmentsFindManyArgs>(args?: SelectSubset<T, it_departmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$it_departmentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a It_departments.
     * @param {it_departmentsCreateArgs} args - Arguments to create a It_departments.
     * @example
     * // Create one It_departments
     * const It_departments = await prisma.it_departments.create({
     *   data: {
     *     // ... data to create a It_departments
     *   }
     * })
     * 
     */
    create<T extends it_departmentsCreateArgs>(args: SelectSubset<T, it_departmentsCreateArgs<ExtArgs>>): Prisma__it_departmentsClient<$Result.GetResult<Prisma.$it_departmentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many It_departments.
     * @param {it_departmentsCreateManyArgs} args - Arguments to create many It_departments.
     * @example
     * // Create many It_departments
     * const it_departments = await prisma.it_departments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends it_departmentsCreateManyArgs>(args?: SelectSubset<T, it_departmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a It_departments.
     * @param {it_departmentsDeleteArgs} args - Arguments to delete one It_departments.
     * @example
     * // Delete one It_departments
     * const It_departments = await prisma.it_departments.delete({
     *   where: {
     *     // ... filter to delete one It_departments
     *   }
     * })
     * 
     */
    delete<T extends it_departmentsDeleteArgs>(args: SelectSubset<T, it_departmentsDeleteArgs<ExtArgs>>): Prisma__it_departmentsClient<$Result.GetResult<Prisma.$it_departmentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one It_departments.
     * @param {it_departmentsUpdateArgs} args - Arguments to update one It_departments.
     * @example
     * // Update one It_departments
     * const it_departments = await prisma.it_departments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends it_departmentsUpdateArgs>(args: SelectSubset<T, it_departmentsUpdateArgs<ExtArgs>>): Prisma__it_departmentsClient<$Result.GetResult<Prisma.$it_departmentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more It_departments.
     * @param {it_departmentsDeleteManyArgs} args - Arguments to filter It_departments to delete.
     * @example
     * // Delete a few It_departments
     * const { count } = await prisma.it_departments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends it_departmentsDeleteManyArgs>(args?: SelectSubset<T, it_departmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more It_departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_departmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many It_departments
     * const it_departments = await prisma.it_departments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends it_departmentsUpdateManyArgs>(args: SelectSubset<T, it_departmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one It_departments.
     * @param {it_departmentsUpsertArgs} args - Arguments to update or create a It_departments.
     * @example
     * // Update or create a It_departments
     * const it_departments = await prisma.it_departments.upsert({
     *   create: {
     *     // ... data to create a It_departments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the It_departments we want to update
     *   }
     * })
     */
    upsert<T extends it_departmentsUpsertArgs>(args: SelectSubset<T, it_departmentsUpsertArgs<ExtArgs>>): Prisma__it_departmentsClient<$Result.GetResult<Prisma.$it_departmentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of It_departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_departmentsCountArgs} args - Arguments to filter It_departments to count.
     * @example
     * // Count the number of It_departments
     * const count = await prisma.it_departments.count({
     *   where: {
     *     // ... the filter for the It_departments we want to count
     *   }
     * })
    **/
    count<T extends it_departmentsCountArgs>(
      args?: Subset<T, it_departmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], It_departmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a It_departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {It_departmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends It_departmentsAggregateArgs>(args: Subset<T, It_departmentsAggregateArgs>): Prisma.PrismaPromise<GetIt_departmentsAggregateType<T>>

    /**
     * Group by It_departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_departmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends it_departmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: it_departmentsGroupByArgs['orderBy'] }
        : { orderBy?: it_departmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, it_departmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIt_departmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the it_departments model
   */
  readonly fields: it_departmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for it_departments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__it_departmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    it_employees<T extends it_departments$it_employeesArgs<ExtArgs> = {}>(args?: Subset<T, it_departments$it_employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$it_employeesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the it_departments model
   */ 
  interface it_departmentsFieldRefs {
    readonly id: FieldRef<"it_departments", 'Int'>
    readonly name: FieldRef<"it_departments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * it_departments findUnique
   */
  export type it_departmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_departments
     */
    select?: it_departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_departmentsInclude<ExtArgs> | null
    /**
     * Filter, which it_departments to fetch.
     */
    where: it_departmentsWhereUniqueInput
  }

  /**
   * it_departments findUniqueOrThrow
   */
  export type it_departmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_departments
     */
    select?: it_departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_departmentsInclude<ExtArgs> | null
    /**
     * Filter, which it_departments to fetch.
     */
    where: it_departmentsWhereUniqueInput
  }

  /**
   * it_departments findFirst
   */
  export type it_departmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_departments
     */
    select?: it_departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_departmentsInclude<ExtArgs> | null
    /**
     * Filter, which it_departments to fetch.
     */
    where?: it_departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_departments to fetch.
     */
    orderBy?: it_departmentsOrderByWithRelationInput | it_departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for it_departments.
     */
    cursor?: it_departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of it_departments.
     */
    distinct?: It_departmentsScalarFieldEnum | It_departmentsScalarFieldEnum[]
  }

  /**
   * it_departments findFirstOrThrow
   */
  export type it_departmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_departments
     */
    select?: it_departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_departmentsInclude<ExtArgs> | null
    /**
     * Filter, which it_departments to fetch.
     */
    where?: it_departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_departments to fetch.
     */
    orderBy?: it_departmentsOrderByWithRelationInput | it_departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for it_departments.
     */
    cursor?: it_departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of it_departments.
     */
    distinct?: It_departmentsScalarFieldEnum | It_departmentsScalarFieldEnum[]
  }

  /**
   * it_departments findMany
   */
  export type it_departmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_departments
     */
    select?: it_departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_departmentsInclude<ExtArgs> | null
    /**
     * Filter, which it_departments to fetch.
     */
    where?: it_departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_departments to fetch.
     */
    orderBy?: it_departmentsOrderByWithRelationInput | it_departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing it_departments.
     */
    cursor?: it_departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_departments.
     */
    skip?: number
    distinct?: It_departmentsScalarFieldEnum | It_departmentsScalarFieldEnum[]
  }

  /**
   * it_departments create
   */
  export type it_departmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_departments
     */
    select?: it_departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_departmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a it_departments.
     */
    data: XOR<it_departmentsCreateInput, it_departmentsUncheckedCreateInput>
  }

  /**
   * it_departments createMany
   */
  export type it_departmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many it_departments.
     */
    data: it_departmentsCreateManyInput | it_departmentsCreateManyInput[]
  }

  /**
   * it_departments update
   */
  export type it_departmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_departments
     */
    select?: it_departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_departmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a it_departments.
     */
    data: XOR<it_departmentsUpdateInput, it_departmentsUncheckedUpdateInput>
    /**
     * Choose, which it_departments to update.
     */
    where: it_departmentsWhereUniqueInput
  }

  /**
   * it_departments updateMany
   */
  export type it_departmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update it_departments.
     */
    data: XOR<it_departmentsUpdateManyMutationInput, it_departmentsUncheckedUpdateManyInput>
    /**
     * Filter which it_departments to update
     */
    where?: it_departmentsWhereInput
  }

  /**
   * it_departments upsert
   */
  export type it_departmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_departments
     */
    select?: it_departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_departmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the it_departments to update in case it exists.
     */
    where: it_departmentsWhereUniqueInput
    /**
     * In case the it_departments found by the `where` argument doesn't exist, create a new it_departments with this data.
     */
    create: XOR<it_departmentsCreateInput, it_departmentsUncheckedCreateInput>
    /**
     * In case the it_departments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<it_departmentsUpdateInput, it_departmentsUncheckedUpdateInput>
  }

  /**
   * it_departments delete
   */
  export type it_departmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_departments
     */
    select?: it_departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_departmentsInclude<ExtArgs> | null
    /**
     * Filter which it_departments to delete.
     */
    where: it_departmentsWhereUniqueInput
  }

  /**
   * it_departments deleteMany
   */
  export type it_departmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which it_departments to delete
     */
    where?: it_departmentsWhereInput
  }

  /**
   * it_departments.it_employees
   */
  export type it_departments$it_employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employees
     */
    select?: it_employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employeesInclude<ExtArgs> | null
    where?: it_employeesWhereInput
    orderBy?: it_employeesOrderByWithRelationInput | it_employeesOrderByWithRelationInput[]
    cursor?: it_employeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: It_employeesScalarFieldEnum | It_employeesScalarFieldEnum[]
  }

  /**
   * it_departments without action
   */
  export type it_departmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_departments
     */
    select?: it_departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_departmentsInclude<ExtArgs> | null
  }


  /**
   * Model it_employee_roles
   */

  export type AggregateIt_employee_roles = {
    _count: It_employee_rolesCountAggregateOutputType | null
    _avg: It_employee_rolesAvgAggregateOutputType | null
    _sum: It_employee_rolesSumAggregateOutputType | null
    _min: It_employee_rolesMinAggregateOutputType | null
    _max: It_employee_rolesMaxAggregateOutputType | null
  }

  export type It_employee_rolesAvgAggregateOutputType = {
    employee_id: number | null
    role_id: number | null
  }

  export type It_employee_rolesSumAggregateOutputType = {
    employee_id: number | null
    role_id: number | null
  }

  export type It_employee_rolesMinAggregateOutputType = {
    employee_id: number | null
    role_id: number | null
  }

  export type It_employee_rolesMaxAggregateOutputType = {
    employee_id: number | null
    role_id: number | null
  }

  export type It_employee_rolesCountAggregateOutputType = {
    employee_id: number
    role_id: number
    _all: number
  }


  export type It_employee_rolesAvgAggregateInputType = {
    employee_id?: true
    role_id?: true
  }

  export type It_employee_rolesSumAggregateInputType = {
    employee_id?: true
    role_id?: true
  }

  export type It_employee_rolesMinAggregateInputType = {
    employee_id?: true
    role_id?: true
  }

  export type It_employee_rolesMaxAggregateInputType = {
    employee_id?: true
    role_id?: true
  }

  export type It_employee_rolesCountAggregateInputType = {
    employee_id?: true
    role_id?: true
    _all?: true
  }

  export type It_employee_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which it_employee_roles to aggregate.
     */
    where?: it_employee_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_employee_roles to fetch.
     */
    orderBy?: it_employee_rolesOrderByWithRelationInput | it_employee_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: it_employee_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_employee_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_employee_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned it_employee_roles
    **/
    _count?: true | It_employee_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: It_employee_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: It_employee_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: It_employee_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: It_employee_rolesMaxAggregateInputType
  }

  export type GetIt_employee_rolesAggregateType<T extends It_employee_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateIt_employee_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIt_employee_roles[P]>
      : GetScalarType<T[P], AggregateIt_employee_roles[P]>
  }




  export type it_employee_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: it_employee_rolesWhereInput
    orderBy?: it_employee_rolesOrderByWithAggregationInput | it_employee_rolesOrderByWithAggregationInput[]
    by: It_employee_rolesScalarFieldEnum[] | It_employee_rolesScalarFieldEnum
    having?: it_employee_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: It_employee_rolesCountAggregateInputType | true
    _avg?: It_employee_rolesAvgAggregateInputType
    _sum?: It_employee_rolesSumAggregateInputType
    _min?: It_employee_rolesMinAggregateInputType
    _max?: It_employee_rolesMaxAggregateInputType
  }

  export type It_employee_rolesGroupByOutputType = {
    employee_id: number
    role_id: number
    _count: It_employee_rolesCountAggregateOutputType | null
    _avg: It_employee_rolesAvgAggregateOutputType | null
    _sum: It_employee_rolesSumAggregateOutputType | null
    _min: It_employee_rolesMinAggregateOutputType | null
    _max: It_employee_rolesMaxAggregateOutputType | null
  }

  type GetIt_employee_rolesGroupByPayload<T extends it_employee_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<It_employee_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof It_employee_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], It_employee_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], It_employee_rolesGroupByOutputType[P]>
        }
      >
    >


  export type it_employee_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employee_id?: boolean
    role_id?: boolean
    it_employees?: boolean | it_employeesDefaultArgs<ExtArgs>
    it_roles?: boolean | it_rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["it_employee_roles"]>


  export type it_employee_rolesSelectScalar = {
    employee_id?: boolean
    role_id?: boolean
  }

  export type it_employee_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    it_employees?: boolean | it_employeesDefaultArgs<ExtArgs>
    it_roles?: boolean | it_rolesDefaultArgs<ExtArgs>
  }

  export type $it_employee_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "it_employee_roles"
    objects: {
      it_employees: Prisma.$it_employeesPayload<ExtArgs>
      it_roles: Prisma.$it_rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      employee_id: number
      role_id: number
    }, ExtArgs["result"]["it_employee_roles"]>
    composites: {}
  }

  type it_employee_rolesGetPayload<S extends boolean | null | undefined | it_employee_rolesDefaultArgs> = $Result.GetResult<Prisma.$it_employee_rolesPayload, S>

  type it_employee_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<it_employee_rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: It_employee_rolesCountAggregateInputType | true
    }

  export interface it_employee_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['it_employee_roles'], meta: { name: 'it_employee_roles' } }
    /**
     * Find zero or one It_employee_roles that matches the filter.
     * @param {it_employee_rolesFindUniqueArgs} args - Arguments to find a It_employee_roles
     * @example
     * // Get one It_employee_roles
     * const it_employee_roles = await prisma.it_employee_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends it_employee_rolesFindUniqueArgs>(args: SelectSubset<T, it_employee_rolesFindUniqueArgs<ExtArgs>>): Prisma__it_employee_rolesClient<$Result.GetResult<Prisma.$it_employee_rolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one It_employee_roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {it_employee_rolesFindUniqueOrThrowArgs} args - Arguments to find a It_employee_roles
     * @example
     * // Get one It_employee_roles
     * const it_employee_roles = await prisma.it_employee_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends it_employee_rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, it_employee_rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__it_employee_rolesClient<$Result.GetResult<Prisma.$it_employee_rolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first It_employee_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_employee_rolesFindFirstArgs} args - Arguments to find a It_employee_roles
     * @example
     * // Get one It_employee_roles
     * const it_employee_roles = await prisma.it_employee_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends it_employee_rolesFindFirstArgs>(args?: SelectSubset<T, it_employee_rolesFindFirstArgs<ExtArgs>>): Prisma__it_employee_rolesClient<$Result.GetResult<Prisma.$it_employee_rolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first It_employee_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_employee_rolesFindFirstOrThrowArgs} args - Arguments to find a It_employee_roles
     * @example
     * // Get one It_employee_roles
     * const it_employee_roles = await prisma.it_employee_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends it_employee_rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, it_employee_rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__it_employee_rolesClient<$Result.GetResult<Prisma.$it_employee_rolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more It_employee_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_employee_rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all It_employee_roles
     * const it_employee_roles = await prisma.it_employee_roles.findMany()
     * 
     * // Get first 10 It_employee_roles
     * const it_employee_roles = await prisma.it_employee_roles.findMany({ take: 10 })
     * 
     * // Only select the `employee_id`
     * const it_employee_rolesWithEmployee_idOnly = await prisma.it_employee_roles.findMany({ select: { employee_id: true } })
     * 
     */
    findMany<T extends it_employee_rolesFindManyArgs>(args?: SelectSubset<T, it_employee_rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$it_employee_rolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a It_employee_roles.
     * @param {it_employee_rolesCreateArgs} args - Arguments to create a It_employee_roles.
     * @example
     * // Create one It_employee_roles
     * const It_employee_roles = await prisma.it_employee_roles.create({
     *   data: {
     *     // ... data to create a It_employee_roles
     *   }
     * })
     * 
     */
    create<T extends it_employee_rolesCreateArgs>(args: SelectSubset<T, it_employee_rolesCreateArgs<ExtArgs>>): Prisma__it_employee_rolesClient<$Result.GetResult<Prisma.$it_employee_rolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many It_employee_roles.
     * @param {it_employee_rolesCreateManyArgs} args - Arguments to create many It_employee_roles.
     * @example
     * // Create many It_employee_roles
     * const it_employee_roles = await prisma.it_employee_roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends it_employee_rolesCreateManyArgs>(args?: SelectSubset<T, it_employee_rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a It_employee_roles.
     * @param {it_employee_rolesDeleteArgs} args - Arguments to delete one It_employee_roles.
     * @example
     * // Delete one It_employee_roles
     * const It_employee_roles = await prisma.it_employee_roles.delete({
     *   where: {
     *     // ... filter to delete one It_employee_roles
     *   }
     * })
     * 
     */
    delete<T extends it_employee_rolesDeleteArgs>(args: SelectSubset<T, it_employee_rolesDeleteArgs<ExtArgs>>): Prisma__it_employee_rolesClient<$Result.GetResult<Prisma.$it_employee_rolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one It_employee_roles.
     * @param {it_employee_rolesUpdateArgs} args - Arguments to update one It_employee_roles.
     * @example
     * // Update one It_employee_roles
     * const it_employee_roles = await prisma.it_employee_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends it_employee_rolesUpdateArgs>(args: SelectSubset<T, it_employee_rolesUpdateArgs<ExtArgs>>): Prisma__it_employee_rolesClient<$Result.GetResult<Prisma.$it_employee_rolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more It_employee_roles.
     * @param {it_employee_rolesDeleteManyArgs} args - Arguments to filter It_employee_roles to delete.
     * @example
     * // Delete a few It_employee_roles
     * const { count } = await prisma.it_employee_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends it_employee_rolesDeleteManyArgs>(args?: SelectSubset<T, it_employee_rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more It_employee_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_employee_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many It_employee_roles
     * const it_employee_roles = await prisma.it_employee_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends it_employee_rolesUpdateManyArgs>(args: SelectSubset<T, it_employee_rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one It_employee_roles.
     * @param {it_employee_rolesUpsertArgs} args - Arguments to update or create a It_employee_roles.
     * @example
     * // Update or create a It_employee_roles
     * const it_employee_roles = await prisma.it_employee_roles.upsert({
     *   create: {
     *     // ... data to create a It_employee_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the It_employee_roles we want to update
     *   }
     * })
     */
    upsert<T extends it_employee_rolesUpsertArgs>(args: SelectSubset<T, it_employee_rolesUpsertArgs<ExtArgs>>): Prisma__it_employee_rolesClient<$Result.GetResult<Prisma.$it_employee_rolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of It_employee_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_employee_rolesCountArgs} args - Arguments to filter It_employee_roles to count.
     * @example
     * // Count the number of It_employee_roles
     * const count = await prisma.it_employee_roles.count({
     *   where: {
     *     // ... the filter for the It_employee_roles we want to count
     *   }
     * })
    **/
    count<T extends it_employee_rolesCountArgs>(
      args?: Subset<T, it_employee_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], It_employee_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a It_employee_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {It_employee_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends It_employee_rolesAggregateArgs>(args: Subset<T, It_employee_rolesAggregateArgs>): Prisma.PrismaPromise<GetIt_employee_rolesAggregateType<T>>

    /**
     * Group by It_employee_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_employee_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends it_employee_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: it_employee_rolesGroupByArgs['orderBy'] }
        : { orderBy?: it_employee_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, it_employee_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIt_employee_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the it_employee_roles model
   */
  readonly fields: it_employee_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for it_employee_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__it_employee_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    it_employees<T extends it_employeesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, it_employeesDefaultArgs<ExtArgs>>): Prisma__it_employeesClient<$Result.GetResult<Prisma.$it_employeesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    it_roles<T extends it_rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, it_rolesDefaultArgs<ExtArgs>>): Prisma__it_rolesClient<$Result.GetResult<Prisma.$it_rolesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the it_employee_roles model
   */ 
  interface it_employee_rolesFieldRefs {
    readonly employee_id: FieldRef<"it_employee_roles", 'Int'>
    readonly role_id: FieldRef<"it_employee_roles", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * it_employee_roles findUnique
   */
  export type it_employee_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employee_roles
     */
    select?: it_employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employee_rolesInclude<ExtArgs> | null
    /**
     * Filter, which it_employee_roles to fetch.
     */
    where: it_employee_rolesWhereUniqueInput
  }

  /**
   * it_employee_roles findUniqueOrThrow
   */
  export type it_employee_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employee_roles
     */
    select?: it_employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employee_rolesInclude<ExtArgs> | null
    /**
     * Filter, which it_employee_roles to fetch.
     */
    where: it_employee_rolesWhereUniqueInput
  }

  /**
   * it_employee_roles findFirst
   */
  export type it_employee_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employee_roles
     */
    select?: it_employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employee_rolesInclude<ExtArgs> | null
    /**
     * Filter, which it_employee_roles to fetch.
     */
    where?: it_employee_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_employee_roles to fetch.
     */
    orderBy?: it_employee_rolesOrderByWithRelationInput | it_employee_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for it_employee_roles.
     */
    cursor?: it_employee_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_employee_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_employee_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of it_employee_roles.
     */
    distinct?: It_employee_rolesScalarFieldEnum | It_employee_rolesScalarFieldEnum[]
  }

  /**
   * it_employee_roles findFirstOrThrow
   */
  export type it_employee_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employee_roles
     */
    select?: it_employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employee_rolesInclude<ExtArgs> | null
    /**
     * Filter, which it_employee_roles to fetch.
     */
    where?: it_employee_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_employee_roles to fetch.
     */
    orderBy?: it_employee_rolesOrderByWithRelationInput | it_employee_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for it_employee_roles.
     */
    cursor?: it_employee_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_employee_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_employee_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of it_employee_roles.
     */
    distinct?: It_employee_rolesScalarFieldEnum | It_employee_rolesScalarFieldEnum[]
  }

  /**
   * it_employee_roles findMany
   */
  export type it_employee_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employee_roles
     */
    select?: it_employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employee_rolesInclude<ExtArgs> | null
    /**
     * Filter, which it_employee_roles to fetch.
     */
    where?: it_employee_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_employee_roles to fetch.
     */
    orderBy?: it_employee_rolesOrderByWithRelationInput | it_employee_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing it_employee_roles.
     */
    cursor?: it_employee_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_employee_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_employee_roles.
     */
    skip?: number
    distinct?: It_employee_rolesScalarFieldEnum | It_employee_rolesScalarFieldEnum[]
  }

  /**
   * it_employee_roles create
   */
  export type it_employee_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employee_roles
     */
    select?: it_employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employee_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a it_employee_roles.
     */
    data: XOR<it_employee_rolesCreateInput, it_employee_rolesUncheckedCreateInput>
  }

  /**
   * it_employee_roles createMany
   */
  export type it_employee_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many it_employee_roles.
     */
    data: it_employee_rolesCreateManyInput | it_employee_rolesCreateManyInput[]
  }

  /**
   * it_employee_roles update
   */
  export type it_employee_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employee_roles
     */
    select?: it_employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employee_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a it_employee_roles.
     */
    data: XOR<it_employee_rolesUpdateInput, it_employee_rolesUncheckedUpdateInput>
    /**
     * Choose, which it_employee_roles to update.
     */
    where: it_employee_rolesWhereUniqueInput
  }

  /**
   * it_employee_roles updateMany
   */
  export type it_employee_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update it_employee_roles.
     */
    data: XOR<it_employee_rolesUpdateManyMutationInput, it_employee_rolesUncheckedUpdateManyInput>
    /**
     * Filter which it_employee_roles to update
     */
    where?: it_employee_rolesWhereInput
  }

  /**
   * it_employee_roles upsert
   */
  export type it_employee_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employee_roles
     */
    select?: it_employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employee_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the it_employee_roles to update in case it exists.
     */
    where: it_employee_rolesWhereUniqueInput
    /**
     * In case the it_employee_roles found by the `where` argument doesn't exist, create a new it_employee_roles with this data.
     */
    create: XOR<it_employee_rolesCreateInput, it_employee_rolesUncheckedCreateInput>
    /**
     * In case the it_employee_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<it_employee_rolesUpdateInput, it_employee_rolesUncheckedUpdateInput>
  }

  /**
   * it_employee_roles delete
   */
  export type it_employee_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employee_roles
     */
    select?: it_employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employee_rolesInclude<ExtArgs> | null
    /**
     * Filter which it_employee_roles to delete.
     */
    where: it_employee_rolesWhereUniqueInput
  }

  /**
   * it_employee_roles deleteMany
   */
  export type it_employee_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which it_employee_roles to delete
     */
    where?: it_employee_rolesWhereInput
  }

  /**
   * it_employee_roles without action
   */
  export type it_employee_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employee_roles
     */
    select?: it_employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employee_rolesInclude<ExtArgs> | null
  }


  /**
   * Model it_employees
   */

  export type AggregateIt_employees = {
    _count: It_employeesCountAggregateOutputType | null
    _avg: It_employeesAvgAggregateOutputType | null
    _sum: It_employeesSumAggregateOutputType | null
    _min: It_employeesMinAggregateOutputType | null
    _max: It_employeesMaxAggregateOutputType | null
  }

  export type It_employeesAvgAggregateOutputType = {
    id: number | null
    department_id: number | null
  }

  export type It_employeesSumAggregateOutputType = {
    id: number | null
    department_id: number | null
  }

  export type It_employeesMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    employee_code: string | null
    department_id: number | null
    is_dept_head: boolean | null
    is_active: boolean | null
  }

  export type It_employeesMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    employee_code: string | null
    department_id: number | null
    is_dept_head: boolean | null
    is_active: boolean | null
  }

  export type It_employeesCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    employee_code: number
    department_id: number
    is_dept_head: number
    is_active: number
    _all: number
  }


  export type It_employeesAvgAggregateInputType = {
    id?: true
    department_id?: true
  }

  export type It_employeesSumAggregateInputType = {
    id?: true
    department_id?: true
  }

  export type It_employeesMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    employee_code?: true
    department_id?: true
    is_dept_head?: true
    is_active?: true
  }

  export type It_employeesMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    employee_code?: true
    department_id?: true
    is_dept_head?: true
    is_active?: true
  }

  export type It_employeesCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    employee_code?: true
    department_id?: true
    is_dept_head?: true
    is_active?: true
    _all?: true
  }

  export type It_employeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which it_employees to aggregate.
     */
    where?: it_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_employees to fetch.
     */
    orderBy?: it_employeesOrderByWithRelationInput | it_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: it_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned it_employees
    **/
    _count?: true | It_employeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: It_employeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: It_employeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: It_employeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: It_employeesMaxAggregateInputType
  }

  export type GetIt_employeesAggregateType<T extends It_employeesAggregateArgs> = {
        [P in keyof T & keyof AggregateIt_employees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIt_employees[P]>
      : GetScalarType<T[P], AggregateIt_employees[P]>
  }




  export type it_employeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: it_employeesWhereInput
    orderBy?: it_employeesOrderByWithAggregationInput | it_employeesOrderByWithAggregationInput[]
    by: It_employeesScalarFieldEnum[] | It_employeesScalarFieldEnum
    having?: it_employeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: It_employeesCountAggregateInputType | true
    _avg?: It_employeesAvgAggregateInputType
    _sum?: It_employeesSumAggregateInputType
    _min?: It_employeesMinAggregateInputType
    _max?: It_employeesMaxAggregateInputType
  }

  export type It_employeesGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    employee_code: string
    department_id: number
    is_dept_head: boolean
    is_active: boolean
    _count: It_employeesCountAggregateOutputType | null
    _avg: It_employeesAvgAggregateOutputType | null
    _sum: It_employeesSumAggregateOutputType | null
    _min: It_employeesMinAggregateOutputType | null
    _max: It_employeesMaxAggregateOutputType | null
  }

  type GetIt_employeesGroupByPayload<T extends it_employeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<It_employeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof It_employeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], It_employeesGroupByOutputType[P]>
            : GetScalarType<T[P], It_employeesGroupByOutputType[P]>
        }
      >
    >


  export type it_employeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    employee_code?: boolean
    department_id?: boolean
    is_dept_head?: boolean
    is_active?: boolean
    it_employee_roles?: boolean | it_employees$it_employee_rolesArgs<ExtArgs>
    it_departments?: boolean | it_departmentsDefaultArgs<ExtArgs>
    _count?: boolean | It_employeesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["it_employees"]>


  export type it_employeesSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    employee_code?: boolean
    department_id?: boolean
    is_dept_head?: boolean
    is_active?: boolean
  }

  export type it_employeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    it_employee_roles?: boolean | it_employees$it_employee_rolesArgs<ExtArgs>
    it_departments?: boolean | it_departmentsDefaultArgs<ExtArgs>
    _count?: boolean | It_employeesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $it_employeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "it_employees"
    objects: {
      it_employee_roles: Prisma.$it_employee_rolesPayload<ExtArgs>[]
      it_departments: Prisma.$it_departmentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      employee_code: string
      department_id: number
      is_dept_head: boolean
      is_active: boolean
    }, ExtArgs["result"]["it_employees"]>
    composites: {}
  }

  type it_employeesGetPayload<S extends boolean | null | undefined | it_employeesDefaultArgs> = $Result.GetResult<Prisma.$it_employeesPayload, S>

  type it_employeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<it_employeesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: It_employeesCountAggregateInputType | true
    }

  export interface it_employeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['it_employees'], meta: { name: 'it_employees' } }
    /**
     * Find zero or one It_employees that matches the filter.
     * @param {it_employeesFindUniqueArgs} args - Arguments to find a It_employees
     * @example
     * // Get one It_employees
     * const it_employees = await prisma.it_employees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends it_employeesFindUniqueArgs>(args: SelectSubset<T, it_employeesFindUniqueArgs<ExtArgs>>): Prisma__it_employeesClient<$Result.GetResult<Prisma.$it_employeesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one It_employees that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {it_employeesFindUniqueOrThrowArgs} args - Arguments to find a It_employees
     * @example
     * // Get one It_employees
     * const it_employees = await prisma.it_employees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends it_employeesFindUniqueOrThrowArgs>(args: SelectSubset<T, it_employeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__it_employeesClient<$Result.GetResult<Prisma.$it_employeesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first It_employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_employeesFindFirstArgs} args - Arguments to find a It_employees
     * @example
     * // Get one It_employees
     * const it_employees = await prisma.it_employees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends it_employeesFindFirstArgs>(args?: SelectSubset<T, it_employeesFindFirstArgs<ExtArgs>>): Prisma__it_employeesClient<$Result.GetResult<Prisma.$it_employeesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first It_employees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_employeesFindFirstOrThrowArgs} args - Arguments to find a It_employees
     * @example
     * // Get one It_employees
     * const it_employees = await prisma.it_employees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends it_employeesFindFirstOrThrowArgs>(args?: SelectSubset<T, it_employeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__it_employeesClient<$Result.GetResult<Prisma.$it_employeesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more It_employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_employeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all It_employees
     * const it_employees = await prisma.it_employees.findMany()
     * 
     * // Get first 10 It_employees
     * const it_employees = await prisma.it_employees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const it_employeesWithIdOnly = await prisma.it_employees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends it_employeesFindManyArgs>(args?: SelectSubset<T, it_employeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$it_employeesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a It_employees.
     * @param {it_employeesCreateArgs} args - Arguments to create a It_employees.
     * @example
     * // Create one It_employees
     * const It_employees = await prisma.it_employees.create({
     *   data: {
     *     // ... data to create a It_employees
     *   }
     * })
     * 
     */
    create<T extends it_employeesCreateArgs>(args: SelectSubset<T, it_employeesCreateArgs<ExtArgs>>): Prisma__it_employeesClient<$Result.GetResult<Prisma.$it_employeesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many It_employees.
     * @param {it_employeesCreateManyArgs} args - Arguments to create many It_employees.
     * @example
     * // Create many It_employees
     * const it_employees = await prisma.it_employees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends it_employeesCreateManyArgs>(args?: SelectSubset<T, it_employeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a It_employees.
     * @param {it_employeesDeleteArgs} args - Arguments to delete one It_employees.
     * @example
     * // Delete one It_employees
     * const It_employees = await prisma.it_employees.delete({
     *   where: {
     *     // ... filter to delete one It_employees
     *   }
     * })
     * 
     */
    delete<T extends it_employeesDeleteArgs>(args: SelectSubset<T, it_employeesDeleteArgs<ExtArgs>>): Prisma__it_employeesClient<$Result.GetResult<Prisma.$it_employeesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one It_employees.
     * @param {it_employeesUpdateArgs} args - Arguments to update one It_employees.
     * @example
     * // Update one It_employees
     * const it_employees = await prisma.it_employees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends it_employeesUpdateArgs>(args: SelectSubset<T, it_employeesUpdateArgs<ExtArgs>>): Prisma__it_employeesClient<$Result.GetResult<Prisma.$it_employeesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more It_employees.
     * @param {it_employeesDeleteManyArgs} args - Arguments to filter It_employees to delete.
     * @example
     * // Delete a few It_employees
     * const { count } = await prisma.it_employees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends it_employeesDeleteManyArgs>(args?: SelectSubset<T, it_employeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more It_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_employeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many It_employees
     * const it_employees = await prisma.it_employees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends it_employeesUpdateManyArgs>(args: SelectSubset<T, it_employeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one It_employees.
     * @param {it_employeesUpsertArgs} args - Arguments to update or create a It_employees.
     * @example
     * // Update or create a It_employees
     * const it_employees = await prisma.it_employees.upsert({
     *   create: {
     *     // ... data to create a It_employees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the It_employees we want to update
     *   }
     * })
     */
    upsert<T extends it_employeesUpsertArgs>(args: SelectSubset<T, it_employeesUpsertArgs<ExtArgs>>): Prisma__it_employeesClient<$Result.GetResult<Prisma.$it_employeesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of It_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_employeesCountArgs} args - Arguments to filter It_employees to count.
     * @example
     * // Count the number of It_employees
     * const count = await prisma.it_employees.count({
     *   where: {
     *     // ... the filter for the It_employees we want to count
     *   }
     * })
    **/
    count<T extends it_employeesCountArgs>(
      args?: Subset<T, it_employeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], It_employeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a It_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {It_employeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends It_employeesAggregateArgs>(args: Subset<T, It_employeesAggregateArgs>): Prisma.PrismaPromise<GetIt_employeesAggregateType<T>>

    /**
     * Group by It_employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_employeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends it_employeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: it_employeesGroupByArgs['orderBy'] }
        : { orderBy?: it_employeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, it_employeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIt_employeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the it_employees model
   */
  readonly fields: it_employeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for it_employees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__it_employeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    it_employee_roles<T extends it_employees$it_employee_rolesArgs<ExtArgs> = {}>(args?: Subset<T, it_employees$it_employee_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$it_employee_rolesPayload<ExtArgs>, T, "findMany"> | Null>
    it_departments<T extends it_departmentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, it_departmentsDefaultArgs<ExtArgs>>): Prisma__it_departmentsClient<$Result.GetResult<Prisma.$it_departmentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the it_employees model
   */ 
  interface it_employeesFieldRefs {
    readonly id: FieldRef<"it_employees", 'Int'>
    readonly first_name: FieldRef<"it_employees", 'String'>
    readonly last_name: FieldRef<"it_employees", 'String'>
    readonly employee_code: FieldRef<"it_employees", 'String'>
    readonly department_id: FieldRef<"it_employees", 'Int'>
    readonly is_dept_head: FieldRef<"it_employees", 'Boolean'>
    readonly is_active: FieldRef<"it_employees", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * it_employees findUnique
   */
  export type it_employeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employees
     */
    select?: it_employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employeesInclude<ExtArgs> | null
    /**
     * Filter, which it_employees to fetch.
     */
    where: it_employeesWhereUniqueInput
  }

  /**
   * it_employees findUniqueOrThrow
   */
  export type it_employeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employees
     */
    select?: it_employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employeesInclude<ExtArgs> | null
    /**
     * Filter, which it_employees to fetch.
     */
    where: it_employeesWhereUniqueInput
  }

  /**
   * it_employees findFirst
   */
  export type it_employeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employees
     */
    select?: it_employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employeesInclude<ExtArgs> | null
    /**
     * Filter, which it_employees to fetch.
     */
    where?: it_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_employees to fetch.
     */
    orderBy?: it_employeesOrderByWithRelationInput | it_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for it_employees.
     */
    cursor?: it_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of it_employees.
     */
    distinct?: It_employeesScalarFieldEnum | It_employeesScalarFieldEnum[]
  }

  /**
   * it_employees findFirstOrThrow
   */
  export type it_employeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employees
     */
    select?: it_employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employeesInclude<ExtArgs> | null
    /**
     * Filter, which it_employees to fetch.
     */
    where?: it_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_employees to fetch.
     */
    orderBy?: it_employeesOrderByWithRelationInput | it_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for it_employees.
     */
    cursor?: it_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of it_employees.
     */
    distinct?: It_employeesScalarFieldEnum | It_employeesScalarFieldEnum[]
  }

  /**
   * it_employees findMany
   */
  export type it_employeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employees
     */
    select?: it_employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employeesInclude<ExtArgs> | null
    /**
     * Filter, which it_employees to fetch.
     */
    where?: it_employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_employees to fetch.
     */
    orderBy?: it_employeesOrderByWithRelationInput | it_employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing it_employees.
     */
    cursor?: it_employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_employees.
     */
    skip?: number
    distinct?: It_employeesScalarFieldEnum | It_employeesScalarFieldEnum[]
  }

  /**
   * it_employees create
   */
  export type it_employeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employees
     */
    select?: it_employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employeesInclude<ExtArgs> | null
    /**
     * The data needed to create a it_employees.
     */
    data: XOR<it_employeesCreateInput, it_employeesUncheckedCreateInput>
  }

  /**
   * it_employees createMany
   */
  export type it_employeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many it_employees.
     */
    data: it_employeesCreateManyInput | it_employeesCreateManyInput[]
  }

  /**
   * it_employees update
   */
  export type it_employeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employees
     */
    select?: it_employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employeesInclude<ExtArgs> | null
    /**
     * The data needed to update a it_employees.
     */
    data: XOR<it_employeesUpdateInput, it_employeesUncheckedUpdateInput>
    /**
     * Choose, which it_employees to update.
     */
    where: it_employeesWhereUniqueInput
  }

  /**
   * it_employees updateMany
   */
  export type it_employeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update it_employees.
     */
    data: XOR<it_employeesUpdateManyMutationInput, it_employeesUncheckedUpdateManyInput>
    /**
     * Filter which it_employees to update
     */
    where?: it_employeesWhereInput
  }

  /**
   * it_employees upsert
   */
  export type it_employeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employees
     */
    select?: it_employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employeesInclude<ExtArgs> | null
    /**
     * The filter to search for the it_employees to update in case it exists.
     */
    where: it_employeesWhereUniqueInput
    /**
     * In case the it_employees found by the `where` argument doesn't exist, create a new it_employees with this data.
     */
    create: XOR<it_employeesCreateInput, it_employeesUncheckedCreateInput>
    /**
     * In case the it_employees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<it_employeesUpdateInput, it_employeesUncheckedUpdateInput>
  }

  /**
   * it_employees delete
   */
  export type it_employeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employees
     */
    select?: it_employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employeesInclude<ExtArgs> | null
    /**
     * Filter which it_employees to delete.
     */
    where: it_employeesWhereUniqueInput
  }

  /**
   * it_employees deleteMany
   */
  export type it_employeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which it_employees to delete
     */
    where?: it_employeesWhereInput
  }

  /**
   * it_employees.it_employee_roles
   */
  export type it_employees$it_employee_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employee_roles
     */
    select?: it_employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employee_rolesInclude<ExtArgs> | null
    where?: it_employee_rolesWhereInput
    orderBy?: it_employee_rolesOrderByWithRelationInput | it_employee_rolesOrderByWithRelationInput[]
    cursor?: it_employee_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: It_employee_rolesScalarFieldEnum | It_employee_rolesScalarFieldEnum[]
  }

  /**
   * it_employees without action
   */
  export type it_employeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employees
     */
    select?: it_employeesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employeesInclude<ExtArgs> | null
  }


  /**
   * Model it_roles
   */

  export type AggregateIt_roles = {
    _count: It_rolesCountAggregateOutputType | null
    _avg: It_rolesAvgAggregateOutputType | null
    _sum: It_rolesSumAggregateOutputType | null
    _min: It_rolesMinAggregateOutputType | null
    _max: It_rolesMaxAggregateOutputType | null
  }

  export type It_rolesAvgAggregateOutputType = {
    id: number | null
  }

  export type It_rolesSumAggregateOutputType = {
    id: number | null
  }

  export type It_rolesMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type It_rolesMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type It_rolesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type It_rolesAvgAggregateInputType = {
    id?: true
  }

  export type It_rolesSumAggregateInputType = {
    id?: true
  }

  export type It_rolesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type It_rolesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type It_rolesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type It_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which it_roles to aggregate.
     */
    where?: it_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_roles to fetch.
     */
    orderBy?: it_rolesOrderByWithRelationInput | it_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: it_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned it_roles
    **/
    _count?: true | It_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: It_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: It_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: It_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: It_rolesMaxAggregateInputType
  }

  export type GetIt_rolesAggregateType<T extends It_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateIt_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIt_roles[P]>
      : GetScalarType<T[P], AggregateIt_roles[P]>
  }




  export type it_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: it_rolesWhereInput
    orderBy?: it_rolesOrderByWithAggregationInput | it_rolesOrderByWithAggregationInput[]
    by: It_rolesScalarFieldEnum[] | It_rolesScalarFieldEnum
    having?: it_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: It_rolesCountAggregateInputType | true
    _avg?: It_rolesAvgAggregateInputType
    _sum?: It_rolesSumAggregateInputType
    _min?: It_rolesMinAggregateInputType
    _max?: It_rolesMaxAggregateInputType
  }

  export type It_rolesGroupByOutputType = {
    id: number
    name: string
    _count: It_rolesCountAggregateOutputType | null
    _avg: It_rolesAvgAggregateOutputType | null
    _sum: It_rolesSumAggregateOutputType | null
    _min: It_rolesMinAggregateOutputType | null
    _max: It_rolesMaxAggregateOutputType | null
  }

  type GetIt_rolesGroupByPayload<T extends it_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<It_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof It_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], It_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], It_rolesGroupByOutputType[P]>
        }
      >
    >


  export type it_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    it_employee_roles?: boolean | it_roles$it_employee_rolesArgs<ExtArgs>
    _count?: boolean | It_rolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["it_roles"]>


  export type it_rolesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type it_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    it_employee_roles?: boolean | it_roles$it_employee_rolesArgs<ExtArgs>
    _count?: boolean | It_rolesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $it_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "it_roles"
    objects: {
      it_employee_roles: Prisma.$it_employee_rolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["it_roles"]>
    composites: {}
  }

  type it_rolesGetPayload<S extends boolean | null | undefined | it_rolesDefaultArgs> = $Result.GetResult<Prisma.$it_rolesPayload, S>

  type it_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<it_rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: It_rolesCountAggregateInputType | true
    }

  export interface it_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['it_roles'], meta: { name: 'it_roles' } }
    /**
     * Find zero or one It_roles that matches the filter.
     * @param {it_rolesFindUniqueArgs} args - Arguments to find a It_roles
     * @example
     * // Get one It_roles
     * const it_roles = await prisma.it_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends it_rolesFindUniqueArgs>(args: SelectSubset<T, it_rolesFindUniqueArgs<ExtArgs>>): Prisma__it_rolesClient<$Result.GetResult<Prisma.$it_rolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one It_roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {it_rolesFindUniqueOrThrowArgs} args - Arguments to find a It_roles
     * @example
     * // Get one It_roles
     * const it_roles = await prisma.it_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends it_rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, it_rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__it_rolesClient<$Result.GetResult<Prisma.$it_rolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first It_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_rolesFindFirstArgs} args - Arguments to find a It_roles
     * @example
     * // Get one It_roles
     * const it_roles = await prisma.it_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends it_rolesFindFirstArgs>(args?: SelectSubset<T, it_rolesFindFirstArgs<ExtArgs>>): Prisma__it_rolesClient<$Result.GetResult<Prisma.$it_rolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first It_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_rolesFindFirstOrThrowArgs} args - Arguments to find a It_roles
     * @example
     * // Get one It_roles
     * const it_roles = await prisma.it_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends it_rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, it_rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__it_rolesClient<$Result.GetResult<Prisma.$it_rolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more It_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all It_roles
     * const it_roles = await prisma.it_roles.findMany()
     * 
     * // Get first 10 It_roles
     * const it_roles = await prisma.it_roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const it_rolesWithIdOnly = await prisma.it_roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends it_rolesFindManyArgs>(args?: SelectSubset<T, it_rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$it_rolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a It_roles.
     * @param {it_rolesCreateArgs} args - Arguments to create a It_roles.
     * @example
     * // Create one It_roles
     * const It_roles = await prisma.it_roles.create({
     *   data: {
     *     // ... data to create a It_roles
     *   }
     * })
     * 
     */
    create<T extends it_rolesCreateArgs>(args: SelectSubset<T, it_rolesCreateArgs<ExtArgs>>): Prisma__it_rolesClient<$Result.GetResult<Prisma.$it_rolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many It_roles.
     * @param {it_rolesCreateManyArgs} args - Arguments to create many It_roles.
     * @example
     * // Create many It_roles
     * const it_roles = await prisma.it_roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends it_rolesCreateManyArgs>(args?: SelectSubset<T, it_rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a It_roles.
     * @param {it_rolesDeleteArgs} args - Arguments to delete one It_roles.
     * @example
     * // Delete one It_roles
     * const It_roles = await prisma.it_roles.delete({
     *   where: {
     *     // ... filter to delete one It_roles
     *   }
     * })
     * 
     */
    delete<T extends it_rolesDeleteArgs>(args: SelectSubset<T, it_rolesDeleteArgs<ExtArgs>>): Prisma__it_rolesClient<$Result.GetResult<Prisma.$it_rolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one It_roles.
     * @param {it_rolesUpdateArgs} args - Arguments to update one It_roles.
     * @example
     * // Update one It_roles
     * const it_roles = await prisma.it_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends it_rolesUpdateArgs>(args: SelectSubset<T, it_rolesUpdateArgs<ExtArgs>>): Prisma__it_rolesClient<$Result.GetResult<Prisma.$it_rolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more It_roles.
     * @param {it_rolesDeleteManyArgs} args - Arguments to filter It_roles to delete.
     * @example
     * // Delete a few It_roles
     * const { count } = await prisma.it_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends it_rolesDeleteManyArgs>(args?: SelectSubset<T, it_rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more It_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many It_roles
     * const it_roles = await prisma.it_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends it_rolesUpdateManyArgs>(args: SelectSubset<T, it_rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one It_roles.
     * @param {it_rolesUpsertArgs} args - Arguments to update or create a It_roles.
     * @example
     * // Update or create a It_roles
     * const it_roles = await prisma.it_roles.upsert({
     *   create: {
     *     // ... data to create a It_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the It_roles we want to update
     *   }
     * })
     */
    upsert<T extends it_rolesUpsertArgs>(args: SelectSubset<T, it_rolesUpsertArgs<ExtArgs>>): Prisma__it_rolesClient<$Result.GetResult<Prisma.$it_rolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of It_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_rolesCountArgs} args - Arguments to filter It_roles to count.
     * @example
     * // Count the number of It_roles
     * const count = await prisma.it_roles.count({
     *   where: {
     *     // ... the filter for the It_roles we want to count
     *   }
     * })
    **/
    count<T extends it_rolesCountArgs>(
      args?: Subset<T, it_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], It_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a It_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {It_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends It_rolesAggregateArgs>(args: Subset<T, It_rolesAggregateArgs>): Prisma.PrismaPromise<GetIt_rolesAggregateType<T>>

    /**
     * Group by It_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {it_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends it_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: it_rolesGroupByArgs['orderBy'] }
        : { orderBy?: it_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, it_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIt_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the it_roles model
   */
  readonly fields: it_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for it_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__it_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    it_employee_roles<T extends it_roles$it_employee_rolesArgs<ExtArgs> = {}>(args?: Subset<T, it_roles$it_employee_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$it_employee_rolesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the it_roles model
   */ 
  interface it_rolesFieldRefs {
    readonly id: FieldRef<"it_roles", 'Int'>
    readonly name: FieldRef<"it_roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * it_roles findUnique
   */
  export type it_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_roles
     */
    select?: it_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_rolesInclude<ExtArgs> | null
    /**
     * Filter, which it_roles to fetch.
     */
    where: it_rolesWhereUniqueInput
  }

  /**
   * it_roles findUniqueOrThrow
   */
  export type it_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_roles
     */
    select?: it_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_rolesInclude<ExtArgs> | null
    /**
     * Filter, which it_roles to fetch.
     */
    where: it_rolesWhereUniqueInput
  }

  /**
   * it_roles findFirst
   */
  export type it_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_roles
     */
    select?: it_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_rolesInclude<ExtArgs> | null
    /**
     * Filter, which it_roles to fetch.
     */
    where?: it_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_roles to fetch.
     */
    orderBy?: it_rolesOrderByWithRelationInput | it_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for it_roles.
     */
    cursor?: it_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of it_roles.
     */
    distinct?: It_rolesScalarFieldEnum | It_rolesScalarFieldEnum[]
  }

  /**
   * it_roles findFirstOrThrow
   */
  export type it_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_roles
     */
    select?: it_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_rolesInclude<ExtArgs> | null
    /**
     * Filter, which it_roles to fetch.
     */
    where?: it_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_roles to fetch.
     */
    orderBy?: it_rolesOrderByWithRelationInput | it_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for it_roles.
     */
    cursor?: it_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of it_roles.
     */
    distinct?: It_rolesScalarFieldEnum | It_rolesScalarFieldEnum[]
  }

  /**
   * it_roles findMany
   */
  export type it_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_roles
     */
    select?: it_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_rolesInclude<ExtArgs> | null
    /**
     * Filter, which it_roles to fetch.
     */
    where?: it_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of it_roles to fetch.
     */
    orderBy?: it_rolesOrderByWithRelationInput | it_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing it_roles.
     */
    cursor?: it_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` it_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` it_roles.
     */
    skip?: number
    distinct?: It_rolesScalarFieldEnum | It_rolesScalarFieldEnum[]
  }

  /**
   * it_roles create
   */
  export type it_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_roles
     */
    select?: it_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a it_roles.
     */
    data: XOR<it_rolesCreateInput, it_rolesUncheckedCreateInput>
  }

  /**
   * it_roles createMany
   */
  export type it_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many it_roles.
     */
    data: it_rolesCreateManyInput | it_rolesCreateManyInput[]
  }

  /**
   * it_roles update
   */
  export type it_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_roles
     */
    select?: it_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a it_roles.
     */
    data: XOR<it_rolesUpdateInput, it_rolesUncheckedUpdateInput>
    /**
     * Choose, which it_roles to update.
     */
    where: it_rolesWhereUniqueInput
  }

  /**
   * it_roles updateMany
   */
  export type it_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update it_roles.
     */
    data: XOR<it_rolesUpdateManyMutationInput, it_rolesUncheckedUpdateManyInput>
    /**
     * Filter which it_roles to update
     */
    where?: it_rolesWhereInput
  }

  /**
   * it_roles upsert
   */
  export type it_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_roles
     */
    select?: it_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the it_roles to update in case it exists.
     */
    where: it_rolesWhereUniqueInput
    /**
     * In case the it_roles found by the `where` argument doesn't exist, create a new it_roles with this data.
     */
    create: XOR<it_rolesCreateInput, it_rolesUncheckedCreateInput>
    /**
     * In case the it_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<it_rolesUpdateInput, it_rolesUncheckedUpdateInput>
  }

  /**
   * it_roles delete
   */
  export type it_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_roles
     */
    select?: it_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_rolesInclude<ExtArgs> | null
    /**
     * Filter which it_roles to delete.
     */
    where: it_rolesWhereUniqueInput
  }

  /**
   * it_roles deleteMany
   */
  export type it_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which it_roles to delete
     */
    where?: it_rolesWhereInput
  }

  /**
   * it_roles.it_employee_roles
   */
  export type it_roles$it_employee_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_employee_roles
     */
    select?: it_employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_employee_rolesInclude<ExtArgs> | null
    where?: it_employee_rolesWhereInput
    orderBy?: it_employee_rolesOrderByWithRelationInput | it_employee_rolesOrderByWithRelationInput[]
    cursor?: it_employee_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: It_employee_rolesScalarFieldEnum | It_employee_rolesScalarFieldEnum[]
  }

  /**
   * it_roles without action
   */
  export type it_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the it_roles
     */
    select?: it_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: it_rolesInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeBase
   */

  export type AggregateKnowledgeBase = {
    _count: KnowledgeBaseCountAggregateOutputType | null
    _avg: KnowledgeBaseAvgAggregateOutputType | null
    _sum: KnowledgeBaseSumAggregateOutputType | null
    _min: KnowledgeBaseMinAggregateOutputType | null
    _max: KnowledgeBaseMaxAggregateOutputType | null
  }

  export type KnowledgeBaseAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
    linkedTicketId: number | null
  }

  export type KnowledgeBaseSumAggregateOutputType = {
    id: number | null
    createdById: number | null
    linkedTicketId: number | null
  }

  export type KnowledgeBaseMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    category: string | null
    tags: string | null
    isPublic: boolean | null
    createdById: number | null
    linkedTicketId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeBaseMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    category: string | null
    tags: string | null
    isPublic: boolean | null
    createdById: number | null
    linkedTicketId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeBaseCountAggregateOutputType = {
    id: number
    title: number
    content: number
    category: number
    tags: number
    isPublic: number
    createdById: number
    linkedTicketId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KnowledgeBaseAvgAggregateInputType = {
    id?: true
    createdById?: true
    linkedTicketId?: true
  }

  export type KnowledgeBaseSumAggregateInputType = {
    id?: true
    createdById?: true
    linkedTicketId?: true
  }

  export type KnowledgeBaseMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    category?: true
    tags?: true
    isPublic?: true
    createdById?: true
    linkedTicketId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeBaseMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    category?: true
    tags?: true
    isPublic?: true
    createdById?: true
    linkedTicketId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeBaseCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    category?: true
    tags?: true
    isPublic?: true
    createdById?: true
    linkedTicketId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KnowledgeBaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBase to aggregate.
     */
    where?: KnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBases to fetch.
     */
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeBases
    **/
    _count?: true | KnowledgeBaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeBaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeBaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeBaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeBaseMaxAggregateInputType
  }

  export type GetKnowledgeBaseAggregateType<T extends KnowledgeBaseAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeBase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeBase[P]>
      : GetScalarType<T[P], AggregateKnowledgeBase[P]>
  }




  export type KnowledgeBaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseWhereInput
    orderBy?: KnowledgeBaseOrderByWithAggregationInput | KnowledgeBaseOrderByWithAggregationInput[]
    by: KnowledgeBaseScalarFieldEnum[] | KnowledgeBaseScalarFieldEnum
    having?: KnowledgeBaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeBaseCountAggregateInputType | true
    _avg?: KnowledgeBaseAvgAggregateInputType
    _sum?: KnowledgeBaseSumAggregateInputType
    _min?: KnowledgeBaseMinAggregateInputType
    _max?: KnowledgeBaseMaxAggregateInputType
  }

  export type KnowledgeBaseGroupByOutputType = {
    id: number
    title: string
    content: string
    category: string | null
    tags: string | null
    isPublic: boolean
    createdById: number
    linkedTicketId: number | null
    createdAt: Date
    updatedAt: Date
    _count: KnowledgeBaseCountAggregateOutputType | null
    _avg: KnowledgeBaseAvgAggregateOutputType | null
    _sum: KnowledgeBaseSumAggregateOutputType | null
    _min: KnowledgeBaseMinAggregateOutputType | null
    _max: KnowledgeBaseMaxAggregateOutputType | null
  }

  type GetKnowledgeBaseGroupByPayload<T extends KnowledgeBaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeBaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeBaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeBaseGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeBaseGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeBaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    tags?: boolean
    isPublic?: boolean
    createdById?: boolean
    linkedTicketId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Ticket?: boolean | KnowledgeBase$TicketArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeBase"]>


  export type KnowledgeBaseSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    tags?: boolean
    isPublic?: boolean
    createdById?: boolean
    linkedTicketId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KnowledgeBaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Ticket?: boolean | KnowledgeBase$TicketArgs<ExtArgs>
  }

  export type $KnowledgeBasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeBase"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Ticket: Prisma.$TicketPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      category: string | null
      tags: string | null
      isPublic: boolean
      createdById: number
      linkedTicketId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["knowledgeBase"]>
    composites: {}
  }

  type KnowledgeBaseGetPayload<S extends boolean | null | undefined | KnowledgeBaseDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeBasePayload, S>

  type KnowledgeBaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KnowledgeBaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KnowledgeBaseCountAggregateInputType | true
    }

  export interface KnowledgeBaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeBase'], meta: { name: 'KnowledgeBase' } }
    /**
     * Find zero or one KnowledgeBase that matches the filter.
     * @param {KnowledgeBaseFindUniqueArgs} args - Arguments to find a KnowledgeBase
     * @example
     * // Get one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeBaseFindUniqueArgs>(args: SelectSubset<T, KnowledgeBaseFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KnowledgeBase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KnowledgeBaseFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeBase
     * @example
     * // Get one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeBaseFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeBaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KnowledgeBase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseFindFirstArgs} args - Arguments to find a KnowledgeBase
     * @example
     * // Get one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeBaseFindFirstArgs>(args?: SelectSubset<T, KnowledgeBaseFindFirstArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KnowledgeBase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseFindFirstOrThrowArgs} args - Arguments to find a KnowledgeBase
     * @example
     * // Get one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeBaseFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeBaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KnowledgeBases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeBases
     * const knowledgeBases = await prisma.knowledgeBase.findMany()
     * 
     * // Get first 10 KnowledgeBases
     * const knowledgeBases = await prisma.knowledgeBase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeBaseWithIdOnly = await prisma.knowledgeBase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeBaseFindManyArgs>(args?: SelectSubset<T, KnowledgeBaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KnowledgeBase.
     * @param {KnowledgeBaseCreateArgs} args - Arguments to create a KnowledgeBase.
     * @example
     * // Create one KnowledgeBase
     * const KnowledgeBase = await prisma.knowledgeBase.create({
     *   data: {
     *     // ... data to create a KnowledgeBase
     *   }
     * })
     * 
     */
    create<T extends KnowledgeBaseCreateArgs>(args: SelectSubset<T, KnowledgeBaseCreateArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KnowledgeBases.
     * @param {KnowledgeBaseCreateManyArgs} args - Arguments to create many KnowledgeBases.
     * @example
     * // Create many KnowledgeBases
     * const knowledgeBase = await prisma.knowledgeBase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeBaseCreateManyArgs>(args?: SelectSubset<T, KnowledgeBaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KnowledgeBase.
     * @param {KnowledgeBaseDeleteArgs} args - Arguments to delete one KnowledgeBase.
     * @example
     * // Delete one KnowledgeBase
     * const KnowledgeBase = await prisma.knowledgeBase.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeBase
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeBaseDeleteArgs>(args: SelectSubset<T, KnowledgeBaseDeleteArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KnowledgeBase.
     * @param {KnowledgeBaseUpdateArgs} args - Arguments to update one KnowledgeBase.
     * @example
     * // Update one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeBaseUpdateArgs>(args: SelectSubset<T, KnowledgeBaseUpdateArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KnowledgeBases.
     * @param {KnowledgeBaseDeleteManyArgs} args - Arguments to filter KnowledgeBases to delete.
     * @example
     * // Delete a few KnowledgeBases
     * const { count } = await prisma.knowledgeBase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeBaseDeleteManyArgs>(args?: SelectSubset<T, KnowledgeBaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeBases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeBases
     * const knowledgeBase = await prisma.knowledgeBase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeBaseUpdateManyArgs>(args: SelectSubset<T, KnowledgeBaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KnowledgeBase.
     * @param {KnowledgeBaseUpsertArgs} args - Arguments to update or create a KnowledgeBase.
     * @example
     * // Update or create a KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.upsert({
     *   create: {
     *     // ... data to create a KnowledgeBase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeBase we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeBaseUpsertArgs>(args: SelectSubset<T, KnowledgeBaseUpsertArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KnowledgeBases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseCountArgs} args - Arguments to filter KnowledgeBases to count.
     * @example
     * // Count the number of KnowledgeBases
     * const count = await prisma.knowledgeBase.count({
     *   where: {
     *     // ... the filter for the KnowledgeBases we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeBaseCountArgs>(
      args?: Subset<T, KnowledgeBaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeBaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeBase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeBaseAggregateArgs>(args: Subset<T, KnowledgeBaseAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeBaseAggregateType<T>>

    /**
     * Group by KnowledgeBase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeBaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeBaseGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeBaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeBaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeBaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeBase model
   */
  readonly fields: KnowledgeBaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeBase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeBaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Ticket<T extends KnowledgeBase$TicketArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeBase$TicketArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeBase model
   */ 
  interface KnowledgeBaseFieldRefs {
    readonly id: FieldRef<"KnowledgeBase", 'Int'>
    readonly title: FieldRef<"KnowledgeBase", 'String'>
    readonly content: FieldRef<"KnowledgeBase", 'String'>
    readonly category: FieldRef<"KnowledgeBase", 'String'>
    readonly tags: FieldRef<"KnowledgeBase", 'String'>
    readonly isPublic: FieldRef<"KnowledgeBase", 'Boolean'>
    readonly createdById: FieldRef<"KnowledgeBase", 'Int'>
    readonly linkedTicketId: FieldRef<"KnowledgeBase", 'Int'>
    readonly createdAt: FieldRef<"KnowledgeBase", 'DateTime'>
    readonly updatedAt: FieldRef<"KnowledgeBase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeBase findUnique
   */
  export type KnowledgeBaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBase to fetch.
     */
    where: KnowledgeBaseWhereUniqueInput
  }

  /**
   * KnowledgeBase findUniqueOrThrow
   */
  export type KnowledgeBaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBase to fetch.
     */
    where: KnowledgeBaseWhereUniqueInput
  }

  /**
   * KnowledgeBase findFirst
   */
  export type KnowledgeBaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBase to fetch.
     */
    where?: KnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBases to fetch.
     */
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBases.
     */
    cursor?: KnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBases.
     */
    distinct?: KnowledgeBaseScalarFieldEnum | KnowledgeBaseScalarFieldEnum[]
  }

  /**
   * KnowledgeBase findFirstOrThrow
   */
  export type KnowledgeBaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBase to fetch.
     */
    where?: KnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBases to fetch.
     */
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBases.
     */
    cursor?: KnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBases.
     */
    distinct?: KnowledgeBaseScalarFieldEnum | KnowledgeBaseScalarFieldEnum[]
  }

  /**
   * KnowledgeBase findMany
   */
  export type KnowledgeBaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBases to fetch.
     */
    where?: KnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBases to fetch.
     */
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeBases.
     */
    cursor?: KnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBases.
     */
    skip?: number
    distinct?: KnowledgeBaseScalarFieldEnum | KnowledgeBaseScalarFieldEnum[]
  }

  /**
   * KnowledgeBase create
   */
  export type KnowledgeBaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeBase.
     */
    data: XOR<KnowledgeBaseCreateInput, KnowledgeBaseUncheckedCreateInput>
  }

  /**
   * KnowledgeBase createMany
   */
  export type KnowledgeBaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeBases.
     */
    data: KnowledgeBaseCreateManyInput | KnowledgeBaseCreateManyInput[]
  }

  /**
   * KnowledgeBase update
   */
  export type KnowledgeBaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeBase.
     */
    data: XOR<KnowledgeBaseUpdateInput, KnowledgeBaseUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeBase to update.
     */
    where: KnowledgeBaseWhereUniqueInput
  }

  /**
   * KnowledgeBase updateMany
   */
  export type KnowledgeBaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeBases.
     */
    data: XOR<KnowledgeBaseUpdateManyMutationInput, KnowledgeBaseUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeBases to update
     */
    where?: KnowledgeBaseWhereInput
  }

  /**
   * KnowledgeBase upsert
   */
  export type KnowledgeBaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeBase to update in case it exists.
     */
    where: KnowledgeBaseWhereUniqueInput
    /**
     * In case the KnowledgeBase found by the `where` argument doesn't exist, create a new KnowledgeBase with this data.
     */
    create: XOR<KnowledgeBaseCreateInput, KnowledgeBaseUncheckedCreateInput>
    /**
     * In case the KnowledgeBase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeBaseUpdateInput, KnowledgeBaseUncheckedUpdateInput>
  }

  /**
   * KnowledgeBase delete
   */
  export type KnowledgeBaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeBase to delete.
     */
    where: KnowledgeBaseWhereUniqueInput
  }

  /**
   * KnowledgeBase deleteMany
   */
  export type KnowledgeBaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBases to delete
     */
    where?: KnowledgeBaseWhereInput
  }

  /**
   * KnowledgeBase.Ticket
   */
  export type KnowledgeBase$TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
  }

  /**
   * KnowledgeBase without action
   */
  export type KnowledgeBaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
  }


  /**
   * Model License
   */

  export type AggregateLicense = {
    _count: LicenseCountAggregateOutputType | null
    _avg: LicenseAvgAggregateOutputType | null
    _sum: LicenseSumAggregateOutputType | null
    _min: LicenseMinAggregateOutputType | null
    _max: LicenseMaxAggregateOutputType | null
  }

  export type LicenseAvgAggregateOutputType = {
    id: number | null
    assetId: number | null
  }

  export type LicenseSumAggregateOutputType = {
    id: number | null
    assetId: number | null
  }

  export type LicenseMinAggregateOutputType = {
    id: number | null
    softwareName: string | null
    licenseKey: string | null
    expireDate: Date | null
    assetId: number | null
  }

  export type LicenseMaxAggregateOutputType = {
    id: number | null
    softwareName: string | null
    licenseKey: string | null
    expireDate: Date | null
    assetId: number | null
  }

  export type LicenseCountAggregateOutputType = {
    id: number
    softwareName: number
    licenseKey: number
    expireDate: number
    assetId: number
    _all: number
  }


  export type LicenseAvgAggregateInputType = {
    id?: true
    assetId?: true
  }

  export type LicenseSumAggregateInputType = {
    id?: true
    assetId?: true
  }

  export type LicenseMinAggregateInputType = {
    id?: true
    softwareName?: true
    licenseKey?: true
    expireDate?: true
    assetId?: true
  }

  export type LicenseMaxAggregateInputType = {
    id?: true
    softwareName?: true
    licenseKey?: true
    expireDate?: true
    assetId?: true
  }

  export type LicenseCountAggregateInputType = {
    id?: true
    softwareName?: true
    licenseKey?: true
    expireDate?: true
    assetId?: true
    _all?: true
  }

  export type LicenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which License to aggregate.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Licenses
    **/
    _count?: true | LicenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LicenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LicenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LicenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LicenseMaxAggregateInputType
  }

  export type GetLicenseAggregateType<T extends LicenseAggregateArgs> = {
        [P in keyof T & keyof AggregateLicense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLicense[P]>
      : GetScalarType<T[P], AggregateLicense[P]>
  }




  export type LicenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseWhereInput
    orderBy?: LicenseOrderByWithAggregationInput | LicenseOrderByWithAggregationInput[]
    by: LicenseScalarFieldEnum[] | LicenseScalarFieldEnum
    having?: LicenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LicenseCountAggregateInputType | true
    _avg?: LicenseAvgAggregateInputType
    _sum?: LicenseSumAggregateInputType
    _min?: LicenseMinAggregateInputType
    _max?: LicenseMaxAggregateInputType
  }

  export type LicenseGroupByOutputType = {
    id: number
    softwareName: string
    licenseKey: string
    expireDate: Date
    assetId: number
    _count: LicenseCountAggregateOutputType | null
    _avg: LicenseAvgAggregateOutputType | null
    _sum: LicenseSumAggregateOutputType | null
    _min: LicenseMinAggregateOutputType | null
    _max: LicenseMaxAggregateOutputType | null
  }

  type GetLicenseGroupByPayload<T extends LicenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LicenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LicenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LicenseGroupByOutputType[P]>
            : GetScalarType<T[P], LicenseGroupByOutputType[P]>
        }
      >
    >


  export type LicenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    softwareName?: boolean
    licenseKey?: boolean
    expireDate?: boolean
    assetId?: boolean
    Asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["license"]>


  export type LicenseSelectScalar = {
    id?: boolean
    softwareName?: boolean
    licenseKey?: boolean
    expireDate?: boolean
    assetId?: boolean
  }

  export type LicenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Asset?: boolean | AssetDefaultArgs<ExtArgs>
  }

  export type $LicensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "License"
    objects: {
      Asset: Prisma.$AssetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      softwareName: string
      licenseKey: string
      expireDate: Date
      assetId: number
    }, ExtArgs["result"]["license"]>
    composites: {}
  }

  type LicenseGetPayload<S extends boolean | null | undefined | LicenseDefaultArgs> = $Result.GetResult<Prisma.$LicensePayload, S>

  type LicenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LicenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LicenseCountAggregateInputType | true
    }

  export interface LicenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['License'], meta: { name: 'License' } }
    /**
     * Find zero or one License that matches the filter.
     * @param {LicenseFindUniqueArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LicenseFindUniqueArgs>(args: SelectSubset<T, LicenseFindUniqueArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one License that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LicenseFindUniqueOrThrowArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LicenseFindUniqueOrThrowArgs>(args: SelectSubset<T, LicenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first License that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindFirstArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LicenseFindFirstArgs>(args?: SelectSubset<T, LicenseFindFirstArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first License that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindFirstOrThrowArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LicenseFindFirstOrThrowArgs>(args?: SelectSubset<T, LicenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Licenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Licenses
     * const licenses = await prisma.license.findMany()
     * 
     * // Get first 10 Licenses
     * const licenses = await prisma.license.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const licenseWithIdOnly = await prisma.license.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LicenseFindManyArgs>(args?: SelectSubset<T, LicenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a License.
     * @param {LicenseCreateArgs} args - Arguments to create a License.
     * @example
     * // Create one License
     * const License = await prisma.license.create({
     *   data: {
     *     // ... data to create a License
     *   }
     * })
     * 
     */
    create<T extends LicenseCreateArgs>(args: SelectSubset<T, LicenseCreateArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Licenses.
     * @param {LicenseCreateManyArgs} args - Arguments to create many Licenses.
     * @example
     * // Create many Licenses
     * const license = await prisma.license.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LicenseCreateManyArgs>(args?: SelectSubset<T, LicenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a License.
     * @param {LicenseDeleteArgs} args - Arguments to delete one License.
     * @example
     * // Delete one License
     * const License = await prisma.license.delete({
     *   where: {
     *     // ... filter to delete one License
     *   }
     * })
     * 
     */
    delete<T extends LicenseDeleteArgs>(args: SelectSubset<T, LicenseDeleteArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one License.
     * @param {LicenseUpdateArgs} args - Arguments to update one License.
     * @example
     * // Update one License
     * const license = await prisma.license.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LicenseUpdateArgs>(args: SelectSubset<T, LicenseUpdateArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Licenses.
     * @param {LicenseDeleteManyArgs} args - Arguments to filter Licenses to delete.
     * @example
     * // Delete a few Licenses
     * const { count } = await prisma.license.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LicenseDeleteManyArgs>(args?: SelectSubset<T, LicenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Licenses
     * const license = await prisma.license.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LicenseUpdateManyArgs>(args: SelectSubset<T, LicenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one License.
     * @param {LicenseUpsertArgs} args - Arguments to update or create a License.
     * @example
     * // Update or create a License
     * const license = await prisma.license.upsert({
     *   create: {
     *     // ... data to create a License
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the License we want to update
     *   }
     * })
     */
    upsert<T extends LicenseUpsertArgs>(args: SelectSubset<T, LicenseUpsertArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseCountArgs} args - Arguments to filter Licenses to count.
     * @example
     * // Count the number of Licenses
     * const count = await prisma.license.count({
     *   where: {
     *     // ... the filter for the Licenses we want to count
     *   }
     * })
    **/
    count<T extends LicenseCountArgs>(
      args?: Subset<T, LicenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LicenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a License.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LicenseAggregateArgs>(args: Subset<T, LicenseAggregateArgs>): Prisma.PrismaPromise<GetLicenseAggregateType<T>>

    /**
     * Group by License.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LicenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LicenseGroupByArgs['orderBy'] }
        : { orderBy?: LicenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LicenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLicenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the License model
   */
  readonly fields: LicenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for License.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LicenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the License model
   */ 
  interface LicenseFieldRefs {
    readonly id: FieldRef<"License", 'Int'>
    readonly softwareName: FieldRef<"License", 'String'>
    readonly licenseKey: FieldRef<"License", 'String'>
    readonly expireDate: FieldRef<"License", 'DateTime'>
    readonly assetId: FieldRef<"License", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * License findUnique
   */
  export type LicenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License findUniqueOrThrow
   */
  export type LicenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License findFirst
   */
  export type LicenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License findFirstOrThrow
   */
  export type LicenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License findMany
   */
  export type LicenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which Licenses to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License create
   */
  export type LicenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The data needed to create a License.
     */
    data: XOR<LicenseCreateInput, LicenseUncheckedCreateInput>
  }

  /**
   * License createMany
   */
  export type LicenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Licenses.
     */
    data: LicenseCreateManyInput | LicenseCreateManyInput[]
  }

  /**
   * License update
   */
  export type LicenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The data needed to update a License.
     */
    data: XOR<LicenseUpdateInput, LicenseUncheckedUpdateInput>
    /**
     * Choose, which License to update.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License updateMany
   */
  export type LicenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Licenses.
     */
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyInput>
    /**
     * Filter which Licenses to update
     */
    where?: LicenseWhereInput
  }

  /**
   * License upsert
   */
  export type LicenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The filter to search for the License to update in case it exists.
     */
    where: LicenseWhereUniqueInput
    /**
     * In case the License found by the `where` argument doesn't exist, create a new License with this data.
     */
    create: XOR<LicenseCreateInput, LicenseUncheckedCreateInput>
    /**
     * In case the License was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LicenseUpdateInput, LicenseUncheckedUpdateInput>
  }

  /**
   * License delete
   */
  export type LicenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter which License to delete.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License deleteMany
   */
  export type LicenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Licenses to delete
     */
    where?: LicenseWhereInput
  }

  /**
   * License without action
   */
  export type LicenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
  }


  /**
   * Model Monitor
   */

  export type AggregateMonitor = {
    _count: MonitorCountAggregateOutputType | null
    _avg: MonitorAvgAggregateOutputType | null
    _sum: MonitorSumAggregateOutputType | null
    _min: MonitorMinAggregateOutputType | null
    _max: MonitorMaxAggregateOutputType | null
  }

  export type MonitorAvgAggregateOutputType = {
    id: number | null
    assetId: number | null
  }

  export type MonitorSumAggregateOutputType = {
    id: number | null
    assetId: number | null
  }

  export type MonitorMinAggregateOutputType = {
    id: number | null
    targetName: string | null
    ipAddress: string | null
    status: string | null
    lastCheck: Date | null
    assetId: number | null
  }

  export type MonitorMaxAggregateOutputType = {
    id: number | null
    targetName: string | null
    ipAddress: string | null
    status: string | null
    lastCheck: Date | null
    assetId: number | null
  }

  export type MonitorCountAggregateOutputType = {
    id: number
    targetName: number
    ipAddress: number
    status: number
    lastCheck: number
    assetId: number
    _all: number
  }


  export type MonitorAvgAggregateInputType = {
    id?: true
    assetId?: true
  }

  export type MonitorSumAggregateInputType = {
    id?: true
    assetId?: true
  }

  export type MonitorMinAggregateInputType = {
    id?: true
    targetName?: true
    ipAddress?: true
    status?: true
    lastCheck?: true
    assetId?: true
  }

  export type MonitorMaxAggregateInputType = {
    id?: true
    targetName?: true
    ipAddress?: true
    status?: true
    lastCheck?: true
    assetId?: true
  }

  export type MonitorCountAggregateInputType = {
    id?: true
    targetName?: true
    ipAddress?: true
    status?: true
    lastCheck?: true
    assetId?: true
    _all?: true
  }

  export type MonitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Monitor to aggregate.
     */
    where?: MonitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitors to fetch.
     */
    orderBy?: MonitorOrderByWithRelationInput | MonitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Monitors
    **/
    _count?: true | MonitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonitorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonitorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonitorMaxAggregateInputType
  }

  export type GetMonitorAggregateType<T extends MonitorAggregateArgs> = {
        [P in keyof T & keyof AggregateMonitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonitor[P]>
      : GetScalarType<T[P], AggregateMonitor[P]>
  }




  export type MonitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonitorWhereInput
    orderBy?: MonitorOrderByWithAggregationInput | MonitorOrderByWithAggregationInput[]
    by: MonitorScalarFieldEnum[] | MonitorScalarFieldEnum
    having?: MonitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonitorCountAggregateInputType | true
    _avg?: MonitorAvgAggregateInputType
    _sum?: MonitorSumAggregateInputType
    _min?: MonitorMinAggregateInputType
    _max?: MonitorMaxAggregateInputType
  }

  export type MonitorGroupByOutputType = {
    id: number
    targetName: string
    ipAddress: string
    status: string
    lastCheck: Date
    assetId: number
    _count: MonitorCountAggregateOutputType | null
    _avg: MonitorAvgAggregateOutputType | null
    _sum: MonitorSumAggregateOutputType | null
    _min: MonitorMinAggregateOutputType | null
    _max: MonitorMaxAggregateOutputType | null
  }

  type GetMonitorGroupByPayload<T extends MonitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonitorGroupByOutputType[P]>
            : GetScalarType<T[P], MonitorGroupByOutputType[P]>
        }
      >
    >


  export type MonitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetName?: boolean
    ipAddress?: boolean
    status?: boolean
    lastCheck?: boolean
    assetId?: boolean
    Asset?: boolean | AssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitor"]>


  export type MonitorSelectScalar = {
    id?: boolean
    targetName?: boolean
    ipAddress?: boolean
    status?: boolean
    lastCheck?: boolean
    assetId?: boolean
  }

  export type MonitorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Asset?: boolean | AssetDefaultArgs<ExtArgs>
  }

  export type $MonitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Monitor"
    objects: {
      Asset: Prisma.$AssetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      targetName: string
      ipAddress: string
      status: string
      lastCheck: Date
      assetId: number
    }, ExtArgs["result"]["monitor"]>
    composites: {}
  }

  type MonitorGetPayload<S extends boolean | null | undefined | MonitorDefaultArgs> = $Result.GetResult<Prisma.$MonitorPayload, S>

  type MonitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MonitorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MonitorCountAggregateInputType | true
    }

  export interface MonitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Monitor'], meta: { name: 'Monitor' } }
    /**
     * Find zero or one Monitor that matches the filter.
     * @param {MonitorFindUniqueArgs} args - Arguments to find a Monitor
     * @example
     * // Get one Monitor
     * const monitor = await prisma.monitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonitorFindUniqueArgs>(args: SelectSubset<T, MonitorFindUniqueArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monitor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MonitorFindUniqueOrThrowArgs} args - Arguments to find a Monitor
     * @example
     * // Get one Monitor
     * const monitor = await prisma.monitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonitorFindUniqueOrThrowArgs>(args: SelectSubset<T, MonitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorFindFirstArgs} args - Arguments to find a Monitor
     * @example
     * // Get one Monitor
     * const monitor = await prisma.monitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonitorFindFirstArgs>(args?: SelectSubset<T, MonitorFindFirstArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorFindFirstOrThrowArgs} args - Arguments to find a Monitor
     * @example
     * // Get one Monitor
     * const monitor = await prisma.monitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonitorFindFirstOrThrowArgs>(args?: SelectSubset<T, MonitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monitors
     * const monitors = await prisma.monitor.findMany()
     * 
     * // Get first 10 Monitors
     * const monitors = await prisma.monitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monitorWithIdOnly = await prisma.monitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonitorFindManyArgs>(args?: SelectSubset<T, MonitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monitor.
     * @param {MonitorCreateArgs} args - Arguments to create a Monitor.
     * @example
     * // Create one Monitor
     * const Monitor = await prisma.monitor.create({
     *   data: {
     *     // ... data to create a Monitor
     *   }
     * })
     * 
     */
    create<T extends MonitorCreateArgs>(args: SelectSubset<T, MonitorCreateArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monitors.
     * @param {MonitorCreateManyArgs} args - Arguments to create many Monitors.
     * @example
     * // Create many Monitors
     * const monitor = await prisma.monitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonitorCreateManyArgs>(args?: SelectSubset<T, MonitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monitor.
     * @param {MonitorDeleteArgs} args - Arguments to delete one Monitor.
     * @example
     * // Delete one Monitor
     * const Monitor = await prisma.monitor.delete({
     *   where: {
     *     // ... filter to delete one Monitor
     *   }
     * })
     * 
     */
    delete<T extends MonitorDeleteArgs>(args: SelectSubset<T, MonitorDeleteArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monitor.
     * @param {MonitorUpdateArgs} args - Arguments to update one Monitor.
     * @example
     * // Update one Monitor
     * const monitor = await prisma.monitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonitorUpdateArgs>(args: SelectSubset<T, MonitorUpdateArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monitors.
     * @param {MonitorDeleteManyArgs} args - Arguments to filter Monitors to delete.
     * @example
     * // Delete a few Monitors
     * const { count } = await prisma.monitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonitorDeleteManyArgs>(args?: SelectSubset<T, MonitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monitors
     * const monitor = await prisma.monitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonitorUpdateManyArgs>(args: SelectSubset<T, MonitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monitor.
     * @param {MonitorUpsertArgs} args - Arguments to update or create a Monitor.
     * @example
     * // Update or create a Monitor
     * const monitor = await prisma.monitor.upsert({
     *   create: {
     *     // ... data to create a Monitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monitor we want to update
     *   }
     * })
     */
    upsert<T extends MonitorUpsertArgs>(args: SelectSubset<T, MonitorUpsertArgs<ExtArgs>>): Prisma__MonitorClient<$Result.GetResult<Prisma.$MonitorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Monitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorCountArgs} args - Arguments to filter Monitors to count.
     * @example
     * // Count the number of Monitors
     * const count = await prisma.monitor.count({
     *   where: {
     *     // ... the filter for the Monitors we want to count
     *   }
     * })
    **/
    count<T extends MonitorCountArgs>(
      args?: Subset<T, MonitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonitorAggregateArgs>(args: Subset<T, MonitorAggregateArgs>): Prisma.PrismaPromise<GetMonitorAggregateType<T>>

    /**
     * Group by Monitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonitorGroupByArgs['orderBy'] }
        : { orderBy?: MonitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Monitor model
   */
  readonly fields: MonitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Monitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Monitor model
   */ 
  interface MonitorFieldRefs {
    readonly id: FieldRef<"Monitor", 'Int'>
    readonly targetName: FieldRef<"Monitor", 'String'>
    readonly ipAddress: FieldRef<"Monitor", 'String'>
    readonly status: FieldRef<"Monitor", 'String'>
    readonly lastCheck: FieldRef<"Monitor", 'DateTime'>
    readonly assetId: FieldRef<"Monitor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Monitor findUnique
   */
  export type MonitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * Filter, which Monitor to fetch.
     */
    where: MonitorWhereUniqueInput
  }

  /**
   * Monitor findUniqueOrThrow
   */
  export type MonitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * Filter, which Monitor to fetch.
     */
    where: MonitorWhereUniqueInput
  }

  /**
   * Monitor findFirst
   */
  export type MonitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * Filter, which Monitor to fetch.
     */
    where?: MonitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitors to fetch.
     */
    orderBy?: MonitorOrderByWithRelationInput | MonitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Monitors.
     */
    cursor?: MonitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Monitors.
     */
    distinct?: MonitorScalarFieldEnum | MonitorScalarFieldEnum[]
  }

  /**
   * Monitor findFirstOrThrow
   */
  export type MonitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * Filter, which Monitor to fetch.
     */
    where?: MonitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitors to fetch.
     */
    orderBy?: MonitorOrderByWithRelationInput | MonitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Monitors.
     */
    cursor?: MonitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Monitors.
     */
    distinct?: MonitorScalarFieldEnum | MonitorScalarFieldEnum[]
  }

  /**
   * Monitor findMany
   */
  export type MonitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * Filter, which Monitors to fetch.
     */
    where?: MonitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitors to fetch.
     */
    orderBy?: MonitorOrderByWithRelationInput | MonitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Monitors.
     */
    cursor?: MonitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitors.
     */
    skip?: number
    distinct?: MonitorScalarFieldEnum | MonitorScalarFieldEnum[]
  }

  /**
   * Monitor create
   */
  export type MonitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * The data needed to create a Monitor.
     */
    data: XOR<MonitorCreateInput, MonitorUncheckedCreateInput>
  }

  /**
   * Monitor createMany
   */
  export type MonitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Monitors.
     */
    data: MonitorCreateManyInput | MonitorCreateManyInput[]
  }

  /**
   * Monitor update
   */
  export type MonitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * The data needed to update a Monitor.
     */
    data: XOR<MonitorUpdateInput, MonitorUncheckedUpdateInput>
    /**
     * Choose, which Monitor to update.
     */
    where: MonitorWhereUniqueInput
  }

  /**
   * Monitor updateMany
   */
  export type MonitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Monitors.
     */
    data: XOR<MonitorUpdateManyMutationInput, MonitorUncheckedUpdateManyInput>
    /**
     * Filter which Monitors to update
     */
    where?: MonitorWhereInput
  }

  /**
   * Monitor upsert
   */
  export type MonitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * The filter to search for the Monitor to update in case it exists.
     */
    where: MonitorWhereUniqueInput
    /**
     * In case the Monitor found by the `where` argument doesn't exist, create a new Monitor with this data.
     */
    create: XOR<MonitorCreateInput, MonitorUncheckedCreateInput>
    /**
     * In case the Monitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonitorUpdateInput, MonitorUncheckedUpdateInput>
  }

  /**
   * Monitor delete
   */
  export type MonitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
    /**
     * Filter which Monitor to delete.
     */
    where: MonitorWhereUniqueInput
  }

  /**
   * Monitor deleteMany
   */
  export type MonitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Monitors to delete
     */
    where?: MonitorWhereInput
  }

  /**
   * Monitor without action
   */
  export type MonitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor
     */
    select?: MonitorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitorInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    name: string
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    employee_roles?: boolean | roles$employee_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>


  export type rolesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee_roles?: boolean | roles$employee_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      employee_roles: Prisma.$employee_rolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee_roles<T extends roles$employee_rolesArgs<ExtArgs> = {}>(args?: Subset<T, roles$employee_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_rolesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */ 
  interface rolesFieldRefs {
    readonly id: FieldRef<"roles", 'Int'>
    readonly name: FieldRef<"roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
  }

  /**
   * roles.employee_roles
   */
  export type roles$employee_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_roles
     */
    select?: employee_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_rolesInclude<ExtArgs> | null
    where?: employee_rolesWhereInput
    orderBy?: employee_rolesOrderByWithRelationInput | employee_rolesOrderByWithRelationInput[]
    cursor?: employee_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Employee_rolesScalarFieldEnum | Employee_rolesScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketAvgAggregateOutputType = {
    id: number | null
    assetId: number | null
    requestedById: number | null
    assignedToId: number | null
  }

  export type TicketSumAggregateOutputType = {
    id: number | null
    assetId: number | null
    requestedById: number | null
    assignedToId: number | null
  }

  export type TicketMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    resolutionNote: string | null
    status: string | null
    createdAt: Date | null
    assetId: number | null
    requestedById: number | null
    assignedToId: number | null
  }

  export type TicketMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    resolutionNote: string | null
    status: string | null
    createdAt: Date | null
    assetId: number | null
    requestedById: number | null
    assignedToId: number | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    title: number
    description: number
    resolutionNote: number
    status: number
    createdAt: number
    assetId: number
    requestedById: number
    assignedToId: number
    _all: number
  }


  export type TicketAvgAggregateInputType = {
    id?: true
    assetId?: true
    requestedById?: true
    assignedToId?: true
  }

  export type TicketSumAggregateInputType = {
    id?: true
    assetId?: true
    requestedById?: true
    assignedToId?: true
  }

  export type TicketMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    resolutionNote?: true
    status?: true
    createdAt?: true
    assetId?: true
    requestedById?: true
    assignedToId?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    resolutionNote?: true
    status?: true
    createdAt?: true
    assetId?: true
    requestedById?: true
    assignedToId?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    resolutionNote?: true
    status?: true
    createdAt?: true
    assetId?: true
    requestedById?: true
    assignedToId?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _avg?: TicketAvgAggregateInputType
    _sum?: TicketSumAggregateInputType
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: number
    title: string
    description: string
    resolutionNote: string | null
    status: string
    createdAt: Date
    assetId: number | null
    requestedById: number
    assignedToId: number | null
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    resolutionNote?: boolean
    status?: boolean
    createdAt?: boolean
    assetId?: boolean
    requestedById?: boolean
    assignedToId?: boolean
    KnowledgeBase?: boolean | Ticket$KnowledgeBaseArgs<ExtArgs>
    Asset?: boolean | Ticket$AssetArgs<ExtArgs>
    User_Ticket_assignedToIdToUser?: boolean | Ticket$User_Ticket_assignedToIdToUserArgs<ExtArgs>
    User_Ticket_requestedByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    TicketAttachment?: boolean | Ticket$TicketAttachmentArgs<ExtArgs>
    TicketComment?: boolean | Ticket$TicketCommentArgs<ExtArgs>
    TicketHistory?: boolean | Ticket$TicketHistoryArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>


  export type TicketSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    resolutionNote?: boolean
    status?: boolean
    createdAt?: boolean
    assetId?: boolean
    requestedById?: boolean
    assignedToId?: boolean
  }

  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KnowledgeBase?: boolean | Ticket$KnowledgeBaseArgs<ExtArgs>
    Asset?: boolean | Ticket$AssetArgs<ExtArgs>
    User_Ticket_assignedToIdToUser?: boolean | Ticket$User_Ticket_assignedToIdToUserArgs<ExtArgs>
    User_Ticket_requestedByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    TicketAttachment?: boolean | Ticket$TicketAttachmentArgs<ExtArgs>
    TicketComment?: boolean | Ticket$TicketCommentArgs<ExtArgs>
    TicketHistory?: boolean | Ticket$TicketHistoryArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      KnowledgeBase: Prisma.$KnowledgeBasePayload<ExtArgs>[]
      Asset: Prisma.$AssetPayload<ExtArgs> | null
      User_Ticket_assignedToIdToUser: Prisma.$UserPayload<ExtArgs> | null
      User_Ticket_requestedByIdToUser: Prisma.$UserPayload<ExtArgs>
      TicketAttachment: Prisma.$TicketAttachmentPayload<ExtArgs>[]
      TicketComment: Prisma.$TicketCommentPayload<ExtArgs>[]
      TicketHistory: Prisma.$TicketHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      resolutionNote: string | null
      status: string
      createdAt: Date
      assetId: number | null
      requestedById: number
      assignedToId: number | null
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KnowledgeBase<T extends Ticket$KnowledgeBaseArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$KnowledgeBaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findMany"> | Null>
    Asset<T extends Ticket$AssetArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$AssetArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    User_Ticket_assignedToIdToUser<T extends Ticket$User_Ticket_assignedToIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$User_Ticket_assignedToIdToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    User_Ticket_requestedByIdToUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    TicketAttachment<T extends Ticket$TicketAttachmentArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$TicketAttachmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    TicketComment<T extends Ticket$TicketCommentArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$TicketCommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany"> | Null>
    TicketHistory<T extends Ticket$TicketHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$TicketHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */ 
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'Int'>
    readonly title: FieldRef<"Ticket", 'String'>
    readonly description: FieldRef<"Ticket", 'String'>
    readonly resolutionNote: FieldRef<"Ticket", 'String'>
    readonly status: FieldRef<"Ticket", 'String'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly assetId: FieldRef<"Ticket", 'Int'>
    readonly requestedById: FieldRef<"Ticket", 'Int'>
    readonly assignedToId: FieldRef<"Ticket", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
  }

  /**
   * Ticket.KnowledgeBase
   */
  export type Ticket$KnowledgeBaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    where?: KnowledgeBaseWhereInput
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    cursor?: KnowledgeBaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeBaseScalarFieldEnum | KnowledgeBaseScalarFieldEnum[]
  }

  /**
   * Ticket.Asset
   */
  export type Ticket$AssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
  }

  /**
   * Ticket.User_Ticket_assignedToIdToUser
   */
  export type Ticket$User_Ticket_assignedToIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket.TicketAttachment
   */
  export type Ticket$TicketAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    cursor?: TicketAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * Ticket.TicketComment
   */
  export type Ticket$TicketCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * Ticket.TicketHistory
   */
  export type Ticket$TicketHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    where?: TicketHistoryWhereInput
    orderBy?: TicketHistoryOrderByWithRelationInput | TicketHistoryOrderByWithRelationInput[]
    cursor?: TicketHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketHistoryScalarFieldEnum | TicketHistoryScalarFieldEnum[]
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketAttachment
   */

  export type AggregateTicketAttachment = {
    _count: TicketAttachmentCountAggregateOutputType | null
    _avg: TicketAttachmentAvgAggregateOutputType | null
    _sum: TicketAttachmentSumAggregateOutputType | null
    _min: TicketAttachmentMinAggregateOutputType | null
    _max: TicketAttachmentMaxAggregateOutputType | null
  }

  export type TicketAttachmentAvgAggregateOutputType = {
    id: number | null
    ticketId: number | null
    uploadedById: number | null
  }

  export type TicketAttachmentSumAggregateOutputType = {
    id: number | null
    ticketId: number | null
    uploadedById: number | null
  }

  export type TicketAttachmentMinAggregateOutputType = {
    id: number | null
    fileName: string | null
    filePath: string | null
    uploadedAt: Date | null
    ticketId: number | null
    uploadedById: number | null
  }

  export type TicketAttachmentMaxAggregateOutputType = {
    id: number | null
    fileName: string | null
    filePath: string | null
    uploadedAt: Date | null
    ticketId: number | null
    uploadedById: number | null
  }

  export type TicketAttachmentCountAggregateOutputType = {
    id: number
    fileName: number
    filePath: number
    uploadedAt: number
    ticketId: number
    uploadedById: number
    _all: number
  }


  export type TicketAttachmentAvgAggregateInputType = {
    id?: true
    ticketId?: true
    uploadedById?: true
  }

  export type TicketAttachmentSumAggregateInputType = {
    id?: true
    ticketId?: true
    uploadedById?: true
  }

  export type TicketAttachmentMinAggregateInputType = {
    id?: true
    fileName?: true
    filePath?: true
    uploadedAt?: true
    ticketId?: true
    uploadedById?: true
  }

  export type TicketAttachmentMaxAggregateInputType = {
    id?: true
    fileName?: true
    filePath?: true
    uploadedAt?: true
    ticketId?: true
    uploadedById?: true
  }

  export type TicketAttachmentCountAggregateInputType = {
    id?: true
    fileName?: true
    filePath?: true
    uploadedAt?: true
    ticketId?: true
    uploadedById?: true
    _all?: true
  }

  export type TicketAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketAttachment to aggregate.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketAttachments
    **/
    _count?: true | TicketAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketAttachmentMaxAggregateInputType
  }

  export type GetTicketAttachmentAggregateType<T extends TicketAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketAttachment[P]>
      : GetScalarType<T[P], AggregateTicketAttachment[P]>
  }




  export type TicketAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithAggregationInput | TicketAttachmentOrderByWithAggregationInput[]
    by: TicketAttachmentScalarFieldEnum[] | TicketAttachmentScalarFieldEnum
    having?: TicketAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketAttachmentCountAggregateInputType | true
    _avg?: TicketAttachmentAvgAggregateInputType
    _sum?: TicketAttachmentSumAggregateInputType
    _min?: TicketAttachmentMinAggregateInputType
    _max?: TicketAttachmentMaxAggregateInputType
  }

  export type TicketAttachmentGroupByOutputType = {
    id: number
    fileName: string
    filePath: string
    uploadedAt: Date
    ticketId: number
    uploadedById: number
    _count: TicketAttachmentCountAggregateOutputType | null
    _avg: TicketAttachmentAvgAggregateOutputType | null
    _sum: TicketAttachmentSumAggregateOutputType | null
    _min: TicketAttachmentMinAggregateOutputType | null
    _max: TicketAttachmentMaxAggregateOutputType | null
  }

  type GetTicketAttachmentGroupByPayload<T extends TicketAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type TicketAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    filePath?: boolean
    uploadedAt?: boolean
    ticketId?: boolean
    uploadedById?: boolean
    Ticket?: boolean | TicketDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAttachment"]>


  export type TicketAttachmentSelectScalar = {
    id?: boolean
    fileName?: boolean
    filePath?: boolean
    uploadedAt?: boolean
    ticketId?: boolean
    uploadedById?: boolean
  }

  export type TicketAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ticket?: boolean | TicketDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketAttachment"
    objects: {
      Ticket: Prisma.$TicketPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fileName: string
      filePath: string
      uploadedAt: Date
      ticketId: number
      uploadedById: number
    }, ExtArgs["result"]["ticketAttachment"]>
    composites: {}
  }

  type TicketAttachmentGetPayload<S extends boolean | null | undefined | TicketAttachmentDefaultArgs> = $Result.GetResult<Prisma.$TicketAttachmentPayload, S>

  type TicketAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketAttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketAttachmentCountAggregateInputType | true
    }

  export interface TicketAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketAttachment'], meta: { name: 'TicketAttachment' } }
    /**
     * Find zero or one TicketAttachment that matches the filter.
     * @param {TicketAttachmentFindUniqueArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketAttachmentFindUniqueArgs>(args: SelectSubset<T, TicketAttachmentFindUniqueArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketAttachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketAttachmentFindUniqueOrThrowArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindFirstArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketAttachmentFindFirstArgs>(args?: SelectSubset<T, TicketAttachmentFindFirstArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindFirstOrThrowArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketAttachments
     * const ticketAttachments = await prisma.ticketAttachment.findMany()
     * 
     * // Get first 10 TicketAttachments
     * const ticketAttachments = await prisma.ticketAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketAttachmentWithIdOnly = await prisma.ticketAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketAttachmentFindManyArgs>(args?: SelectSubset<T, TicketAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketAttachment.
     * @param {TicketAttachmentCreateArgs} args - Arguments to create a TicketAttachment.
     * @example
     * // Create one TicketAttachment
     * const TicketAttachment = await prisma.ticketAttachment.create({
     *   data: {
     *     // ... data to create a TicketAttachment
     *   }
     * })
     * 
     */
    create<T extends TicketAttachmentCreateArgs>(args: SelectSubset<T, TicketAttachmentCreateArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketAttachments.
     * @param {TicketAttachmentCreateManyArgs} args - Arguments to create many TicketAttachments.
     * @example
     * // Create many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketAttachmentCreateManyArgs>(args?: SelectSubset<T, TicketAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TicketAttachment.
     * @param {TicketAttachmentDeleteArgs} args - Arguments to delete one TicketAttachment.
     * @example
     * // Delete one TicketAttachment
     * const TicketAttachment = await prisma.ticketAttachment.delete({
     *   where: {
     *     // ... filter to delete one TicketAttachment
     *   }
     * })
     * 
     */
    delete<T extends TicketAttachmentDeleteArgs>(args: SelectSubset<T, TicketAttachmentDeleteArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketAttachment.
     * @param {TicketAttachmentUpdateArgs} args - Arguments to update one TicketAttachment.
     * @example
     * // Update one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketAttachmentUpdateArgs>(args: SelectSubset<T, TicketAttachmentUpdateArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketAttachments.
     * @param {TicketAttachmentDeleteManyArgs} args - Arguments to filter TicketAttachments to delete.
     * @example
     * // Delete a few TicketAttachments
     * const { count } = await prisma.ticketAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketAttachmentDeleteManyArgs>(args?: SelectSubset<T, TicketAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketAttachmentUpdateManyArgs>(args: SelectSubset<T, TicketAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketAttachment.
     * @param {TicketAttachmentUpsertArgs} args - Arguments to update or create a TicketAttachment.
     * @example
     * // Update or create a TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.upsert({
     *   create: {
     *     // ... data to create a TicketAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketAttachment we want to update
     *   }
     * })
     */
    upsert<T extends TicketAttachmentUpsertArgs>(args: SelectSubset<T, TicketAttachmentUpsertArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentCountArgs} args - Arguments to filter TicketAttachments to count.
     * @example
     * // Count the number of TicketAttachments
     * const count = await prisma.ticketAttachment.count({
     *   where: {
     *     // ... the filter for the TicketAttachments we want to count
     *   }
     * })
    **/
    count<T extends TicketAttachmentCountArgs>(
      args?: Subset<T, TicketAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAttachmentAggregateArgs>(args: Subset<T, TicketAttachmentAggregateArgs>): Prisma.PrismaPromise<GetTicketAttachmentAggregateType<T>>

    /**
     * Group by TicketAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: TicketAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketAttachment model
   */
  readonly fields: TicketAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketAttachment model
   */ 
  interface TicketAttachmentFieldRefs {
    readonly id: FieldRef<"TicketAttachment", 'Int'>
    readonly fileName: FieldRef<"TicketAttachment", 'String'>
    readonly filePath: FieldRef<"TicketAttachment", 'String'>
    readonly uploadedAt: FieldRef<"TicketAttachment", 'DateTime'>
    readonly ticketId: FieldRef<"TicketAttachment", 'Int'>
    readonly uploadedById: FieldRef<"TicketAttachment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TicketAttachment findUnique
   */
  export type TicketAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment findUniqueOrThrow
   */
  export type TicketAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment findFirst
   */
  export type TicketAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketAttachments.
     */
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment findFirstOrThrow
   */
  export type TicketAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketAttachments.
     */
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment findMany
   */
  export type TicketAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachments to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment create
   */
  export type TicketAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketAttachment.
     */
    data: XOR<TicketAttachmentCreateInput, TicketAttachmentUncheckedCreateInput>
  }

  /**
   * TicketAttachment createMany
   */
  export type TicketAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketAttachments.
     */
    data: TicketAttachmentCreateManyInput | TicketAttachmentCreateManyInput[]
  }

  /**
   * TicketAttachment update
   */
  export type TicketAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketAttachment.
     */
    data: XOR<TicketAttachmentUpdateInput, TicketAttachmentUncheckedUpdateInput>
    /**
     * Choose, which TicketAttachment to update.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment updateMany
   */
  export type TicketAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketAttachments.
     */
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TicketAttachments to update
     */
    where?: TicketAttachmentWhereInput
  }

  /**
   * TicketAttachment upsert
   */
  export type TicketAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketAttachment to update in case it exists.
     */
    where: TicketAttachmentWhereUniqueInput
    /**
     * In case the TicketAttachment found by the `where` argument doesn't exist, create a new TicketAttachment with this data.
     */
    create: XOR<TicketAttachmentCreateInput, TicketAttachmentUncheckedCreateInput>
    /**
     * In case the TicketAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketAttachmentUpdateInput, TicketAttachmentUncheckedUpdateInput>
  }

  /**
   * TicketAttachment delete
   */
  export type TicketAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter which TicketAttachment to delete.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment deleteMany
   */
  export type TicketAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketAttachments to delete
     */
    where?: TicketAttachmentWhereInput
  }

  /**
   * TicketAttachment without action
   */
  export type TicketAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model TicketComment
   */

  export type AggregateTicketComment = {
    _count: TicketCommentCountAggregateOutputType | null
    _avg: TicketCommentAvgAggregateOutputType | null
    _sum: TicketCommentSumAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  export type TicketCommentAvgAggregateOutputType = {
    id: number | null
    ticketId: number | null
    createdById: number | null
  }

  export type TicketCommentSumAggregateOutputType = {
    id: number | null
    ticketId: number | null
    createdById: number | null
  }

  export type TicketCommentMinAggregateOutputType = {
    id: number | null
    content: string | null
    createdAt: Date | null
    ticketId: number | null
    createdById: number | null
  }

  export type TicketCommentMaxAggregateOutputType = {
    id: number | null
    content: string | null
    createdAt: Date | null
    ticketId: number | null
    createdById: number | null
  }

  export type TicketCommentCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    ticketId: number
    createdById: number
    _all: number
  }


  export type TicketCommentAvgAggregateInputType = {
    id?: true
    ticketId?: true
    createdById?: true
  }

  export type TicketCommentSumAggregateInputType = {
    id?: true
    ticketId?: true
    createdById?: true
  }

  export type TicketCommentMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    ticketId?: true
    createdById?: true
  }

  export type TicketCommentMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    ticketId?: true
    createdById?: true
  }

  export type TicketCommentCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    ticketId?: true
    createdById?: true
    _all?: true
  }

  export type TicketCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComment to aggregate.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketComments
    **/
    _count?: true | TicketCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketCommentMaxAggregateInputType
  }

  export type GetTicketCommentAggregateType<T extends TicketCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketComment[P]>
      : GetScalarType<T[P], AggregateTicketComment[P]>
  }




  export type TicketCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithAggregationInput | TicketCommentOrderByWithAggregationInput[]
    by: TicketCommentScalarFieldEnum[] | TicketCommentScalarFieldEnum
    having?: TicketCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCommentCountAggregateInputType | true
    _avg?: TicketCommentAvgAggregateInputType
    _sum?: TicketCommentSumAggregateInputType
    _min?: TicketCommentMinAggregateInputType
    _max?: TicketCommentMaxAggregateInputType
  }

  export type TicketCommentGroupByOutputType = {
    id: number
    content: string
    createdAt: Date
    ticketId: number
    createdById: number
    _count: TicketCommentCountAggregateOutputType | null
    _avg: TicketCommentAvgAggregateOutputType | null
    _sum: TicketCommentSumAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  type GetTicketCommentGroupByPayload<T extends TicketCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
        }
      >
    >


  export type TicketCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    ticketId?: boolean
    createdById?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>


  export type TicketCommentSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    ticketId?: boolean
    createdById?: boolean
  }

  export type TicketCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $TicketCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketComment"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      createdAt: Date
      ticketId: number
      createdById: number
    }, ExtArgs["result"]["ticketComment"]>
    composites: {}
  }

  type TicketCommentGetPayload<S extends boolean | null | undefined | TicketCommentDefaultArgs> = $Result.GetResult<Prisma.$TicketCommentPayload, S>

  type TicketCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketCommentCountAggregateInputType | true
    }

  export interface TicketCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketComment'], meta: { name: 'TicketComment' } }
    /**
     * Find zero or one TicketComment that matches the filter.
     * @param {TicketCommentFindUniqueArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketCommentFindUniqueArgs>(args: SelectSubset<T, TicketCommentFindUniqueArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketCommentFindUniqueOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketCommentFindFirstArgs>(args?: SelectSubset<T, TicketCommentFindFirstArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketComments
     * const ticketComments = await prisma.ticketComment.findMany()
     * 
     * // Get first 10 TicketComments
     * const ticketComments = await prisma.ticketComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketCommentFindManyArgs>(args?: SelectSubset<T, TicketCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketComment.
     * @param {TicketCommentCreateArgs} args - Arguments to create a TicketComment.
     * @example
     * // Create one TicketComment
     * const TicketComment = await prisma.ticketComment.create({
     *   data: {
     *     // ... data to create a TicketComment
     *   }
     * })
     * 
     */
    create<T extends TicketCommentCreateArgs>(args: SelectSubset<T, TicketCommentCreateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketComments.
     * @param {TicketCommentCreateManyArgs} args - Arguments to create many TicketComments.
     * @example
     * // Create many TicketComments
     * const ticketComment = await prisma.ticketComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCommentCreateManyArgs>(args?: SelectSubset<T, TicketCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TicketComment.
     * @param {TicketCommentDeleteArgs} args - Arguments to delete one TicketComment.
     * @example
     * // Delete one TicketComment
     * const TicketComment = await prisma.ticketComment.delete({
     *   where: {
     *     // ... filter to delete one TicketComment
     *   }
     * })
     * 
     */
    delete<T extends TicketCommentDeleteArgs>(args: SelectSubset<T, TicketCommentDeleteArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketComment.
     * @param {TicketCommentUpdateArgs} args - Arguments to update one TicketComment.
     * @example
     * // Update one TicketComment
     * const ticketComment = await prisma.ticketComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketCommentUpdateArgs>(args: SelectSubset<T, TicketCommentUpdateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketComments.
     * @param {TicketCommentDeleteManyArgs} args - Arguments to filter TicketComments to delete.
     * @example
     * // Delete a few TicketComments
     * const { count } = await prisma.ticketComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketCommentDeleteManyArgs>(args?: SelectSubset<T, TicketCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketComments
     * const ticketComment = await prisma.ticketComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketCommentUpdateManyArgs>(args: SelectSubset<T, TicketCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketComment.
     * @param {TicketCommentUpsertArgs} args - Arguments to update or create a TicketComment.
     * @example
     * // Update or create a TicketComment
     * const ticketComment = await prisma.ticketComment.upsert({
     *   create: {
     *     // ... data to create a TicketComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketComment we want to update
     *   }
     * })
     */
    upsert<T extends TicketCommentUpsertArgs>(args: SelectSubset<T, TicketCommentUpsertArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentCountArgs} args - Arguments to filter TicketComments to count.
     * @example
     * // Count the number of TicketComments
     * const count = await prisma.ticketComment.count({
     *   where: {
     *     // ... the filter for the TicketComments we want to count
     *   }
     * })
    **/
    count<T extends TicketCommentCountArgs>(
      args?: Subset<T, TicketCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketCommentAggregateArgs>(args: Subset<T, TicketCommentAggregateArgs>): Prisma.PrismaPromise<GetTicketCommentAggregateType<T>>

    /**
     * Group by TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketCommentGroupByArgs['orderBy'] }
        : { orderBy?: TicketCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketComment model
   */
  readonly fields: TicketCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketComment model
   */ 
  interface TicketCommentFieldRefs {
    readonly id: FieldRef<"TicketComment", 'Int'>
    readonly content: FieldRef<"TicketComment", 'String'>
    readonly createdAt: FieldRef<"TicketComment", 'DateTime'>
    readonly ticketId: FieldRef<"TicketComment", 'Int'>
    readonly createdById: FieldRef<"TicketComment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TicketComment findUnique
   */
  export type TicketCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findUniqueOrThrow
   */
  export type TicketCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findFirst
   */
  export type TicketCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findFirstOrThrow
   */
  export type TicketCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findMany
   */
  export type TicketCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComments to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment create
   */
  export type TicketCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketComment.
     */
    data: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
  }

  /**
   * TicketComment createMany
   */
  export type TicketCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketComments.
     */
    data: TicketCommentCreateManyInput | TicketCommentCreateManyInput[]
  }

  /**
   * TicketComment update
   */
  export type TicketCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketComment.
     */
    data: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
    /**
     * Choose, which TicketComment to update.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment updateMany
   */
  export type TicketCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketComments.
     */
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyInput>
    /**
     * Filter which TicketComments to update
     */
    where?: TicketCommentWhereInput
  }

  /**
   * TicketComment upsert
   */
  export type TicketCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketComment to update in case it exists.
     */
    where: TicketCommentWhereUniqueInput
    /**
     * In case the TicketComment found by the `where` argument doesn't exist, create a new TicketComment with this data.
     */
    create: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
    /**
     * In case the TicketComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
  }

  /**
   * TicketComment delete
   */
  export type TicketCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter which TicketComment to delete.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment deleteMany
   */
  export type TicketCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComments to delete
     */
    where?: TicketCommentWhereInput
  }

  /**
   * TicketComment without action
   */
  export type TicketCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
  }


  /**
   * Model TicketHistory
   */

  export type AggregateTicketHistory = {
    _count: TicketHistoryCountAggregateOutputType | null
    _avg: TicketHistoryAvgAggregateOutputType | null
    _sum: TicketHistorySumAggregateOutputType | null
    _min: TicketHistoryMinAggregateOutputType | null
    _max: TicketHistoryMaxAggregateOutputType | null
  }

  export type TicketHistoryAvgAggregateOutputType = {
    id: number | null
    ticketId: number | null
    changedById: number | null
  }

  export type TicketHistorySumAggregateOutputType = {
    id: number | null
    ticketId: number | null
    changedById: number | null
  }

  export type TicketHistoryMinAggregateOutputType = {
    id: number | null
    ticketId: number | null
    oldStatus: string | null
    newStatus: string | null
    changedById: number | null
    changedAt: Date | null
    note: string | null
  }

  export type TicketHistoryMaxAggregateOutputType = {
    id: number | null
    ticketId: number | null
    oldStatus: string | null
    newStatus: string | null
    changedById: number | null
    changedAt: Date | null
    note: string | null
  }

  export type TicketHistoryCountAggregateOutputType = {
    id: number
    ticketId: number
    oldStatus: number
    newStatus: number
    changedById: number
    changedAt: number
    note: number
    _all: number
  }


  export type TicketHistoryAvgAggregateInputType = {
    id?: true
    ticketId?: true
    changedById?: true
  }

  export type TicketHistorySumAggregateInputType = {
    id?: true
    ticketId?: true
    changedById?: true
  }

  export type TicketHistoryMinAggregateInputType = {
    id?: true
    ticketId?: true
    oldStatus?: true
    newStatus?: true
    changedById?: true
    changedAt?: true
    note?: true
  }

  export type TicketHistoryMaxAggregateInputType = {
    id?: true
    ticketId?: true
    oldStatus?: true
    newStatus?: true
    changedById?: true
    changedAt?: true
    note?: true
  }

  export type TicketHistoryCountAggregateInputType = {
    id?: true
    ticketId?: true
    oldStatus?: true
    newStatus?: true
    changedById?: true
    changedAt?: true
    note?: true
    _all?: true
  }

  export type TicketHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketHistory to aggregate.
     */
    where?: TicketHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketHistories to fetch.
     */
    orderBy?: TicketHistoryOrderByWithRelationInput | TicketHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketHistories
    **/
    _count?: true | TicketHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketHistoryMaxAggregateInputType
  }

  export type GetTicketHistoryAggregateType<T extends TicketHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketHistory[P]>
      : GetScalarType<T[P], AggregateTicketHistory[P]>
  }




  export type TicketHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketHistoryWhereInput
    orderBy?: TicketHistoryOrderByWithAggregationInput | TicketHistoryOrderByWithAggregationInput[]
    by: TicketHistoryScalarFieldEnum[] | TicketHistoryScalarFieldEnum
    having?: TicketHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketHistoryCountAggregateInputType | true
    _avg?: TicketHistoryAvgAggregateInputType
    _sum?: TicketHistorySumAggregateInputType
    _min?: TicketHistoryMinAggregateInputType
    _max?: TicketHistoryMaxAggregateInputType
  }

  export type TicketHistoryGroupByOutputType = {
    id: number
    ticketId: number
    oldStatus: string
    newStatus: string
    changedById: number
    changedAt: Date
    note: string | null
    _count: TicketHistoryCountAggregateOutputType | null
    _avg: TicketHistoryAvgAggregateOutputType | null
    _sum: TicketHistorySumAggregateOutputType | null
    _min: TicketHistoryMinAggregateOutputType | null
    _max: TicketHistoryMaxAggregateOutputType | null
  }

  type GetTicketHistoryGroupByPayload<T extends TicketHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], TicketHistoryGroupByOutputType[P]>
        }
      >
    >


  export type TicketHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    changedById?: boolean
    changedAt?: boolean
    note?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketHistory"]>


  export type TicketHistorySelectScalar = {
    id?: boolean
    ticketId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    changedById?: boolean
    changedAt?: boolean
    note?: boolean
  }

  export type TicketHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $TicketHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketHistory"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticketId: number
      oldStatus: string
      newStatus: string
      changedById: number
      changedAt: Date
      note: string | null
    }, ExtArgs["result"]["ticketHistory"]>
    composites: {}
  }

  type TicketHistoryGetPayload<S extends boolean | null | undefined | TicketHistoryDefaultArgs> = $Result.GetResult<Prisma.$TicketHistoryPayload, S>

  type TicketHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketHistoryCountAggregateInputType | true
    }

  export interface TicketHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketHistory'], meta: { name: 'TicketHistory' } }
    /**
     * Find zero or one TicketHistory that matches the filter.
     * @param {TicketHistoryFindUniqueArgs} args - Arguments to find a TicketHistory
     * @example
     * // Get one TicketHistory
     * const ticketHistory = await prisma.ticketHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketHistoryFindUniqueArgs>(args: SelectSubset<T, TicketHistoryFindUniqueArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketHistoryFindUniqueOrThrowArgs} args - Arguments to find a TicketHistory
     * @example
     * // Get one TicketHistory
     * const ticketHistory = await prisma.ticketHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHistoryFindFirstArgs} args - Arguments to find a TicketHistory
     * @example
     * // Get one TicketHistory
     * const ticketHistory = await prisma.ticketHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketHistoryFindFirstArgs>(args?: SelectSubset<T, TicketHistoryFindFirstArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHistoryFindFirstOrThrowArgs} args - Arguments to find a TicketHistory
     * @example
     * // Get one TicketHistory
     * const ticketHistory = await prisma.ticketHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketHistories
     * const ticketHistories = await prisma.ticketHistory.findMany()
     * 
     * // Get first 10 TicketHistories
     * const ticketHistories = await prisma.ticketHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketHistoryWithIdOnly = await prisma.ticketHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketHistoryFindManyArgs>(args?: SelectSubset<T, TicketHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketHistory.
     * @param {TicketHistoryCreateArgs} args - Arguments to create a TicketHistory.
     * @example
     * // Create one TicketHistory
     * const TicketHistory = await prisma.ticketHistory.create({
     *   data: {
     *     // ... data to create a TicketHistory
     *   }
     * })
     * 
     */
    create<T extends TicketHistoryCreateArgs>(args: SelectSubset<T, TicketHistoryCreateArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketHistories.
     * @param {TicketHistoryCreateManyArgs} args - Arguments to create many TicketHistories.
     * @example
     * // Create many TicketHistories
     * const ticketHistory = await prisma.ticketHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketHistoryCreateManyArgs>(args?: SelectSubset<T, TicketHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TicketHistory.
     * @param {TicketHistoryDeleteArgs} args - Arguments to delete one TicketHistory.
     * @example
     * // Delete one TicketHistory
     * const TicketHistory = await prisma.ticketHistory.delete({
     *   where: {
     *     // ... filter to delete one TicketHistory
     *   }
     * })
     * 
     */
    delete<T extends TicketHistoryDeleteArgs>(args: SelectSubset<T, TicketHistoryDeleteArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketHistory.
     * @param {TicketHistoryUpdateArgs} args - Arguments to update one TicketHistory.
     * @example
     * // Update one TicketHistory
     * const ticketHistory = await prisma.ticketHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketHistoryUpdateArgs>(args: SelectSubset<T, TicketHistoryUpdateArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketHistories.
     * @param {TicketHistoryDeleteManyArgs} args - Arguments to filter TicketHistories to delete.
     * @example
     * // Delete a few TicketHistories
     * const { count } = await prisma.ticketHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketHistoryDeleteManyArgs>(args?: SelectSubset<T, TicketHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketHistories
     * const ticketHistory = await prisma.ticketHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketHistoryUpdateManyArgs>(args: SelectSubset<T, TicketHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketHistory.
     * @param {TicketHistoryUpsertArgs} args - Arguments to update or create a TicketHistory.
     * @example
     * // Update or create a TicketHistory
     * const ticketHistory = await prisma.ticketHistory.upsert({
     *   create: {
     *     // ... data to create a TicketHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketHistory we want to update
     *   }
     * })
     */
    upsert<T extends TicketHistoryUpsertArgs>(args: SelectSubset<T, TicketHistoryUpsertArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHistoryCountArgs} args - Arguments to filter TicketHistories to count.
     * @example
     * // Count the number of TicketHistories
     * const count = await prisma.ticketHistory.count({
     *   where: {
     *     // ... the filter for the TicketHistories we want to count
     *   }
     * })
    **/
    count<T extends TicketHistoryCountArgs>(
      args?: Subset<T, TicketHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketHistoryAggregateArgs>(args: Subset<T, TicketHistoryAggregateArgs>): Prisma.PrismaPromise<GetTicketHistoryAggregateType<T>>

    /**
     * Group by TicketHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketHistoryGroupByArgs['orderBy'] }
        : { orderBy?: TicketHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketHistory model
   */
  readonly fields: TicketHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketHistory model
   */ 
  interface TicketHistoryFieldRefs {
    readonly id: FieldRef<"TicketHistory", 'Int'>
    readonly ticketId: FieldRef<"TicketHistory", 'Int'>
    readonly oldStatus: FieldRef<"TicketHistory", 'String'>
    readonly newStatus: FieldRef<"TicketHistory", 'String'>
    readonly changedById: FieldRef<"TicketHistory", 'Int'>
    readonly changedAt: FieldRef<"TicketHistory", 'DateTime'>
    readonly note: FieldRef<"TicketHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TicketHistory findUnique
   */
  export type TicketHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketHistory to fetch.
     */
    where: TicketHistoryWhereUniqueInput
  }

  /**
   * TicketHistory findUniqueOrThrow
   */
  export type TicketHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketHistory to fetch.
     */
    where: TicketHistoryWhereUniqueInput
  }

  /**
   * TicketHistory findFirst
   */
  export type TicketHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketHistory to fetch.
     */
    where?: TicketHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketHistories to fetch.
     */
    orderBy?: TicketHistoryOrderByWithRelationInput | TicketHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketHistories.
     */
    cursor?: TicketHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketHistories.
     */
    distinct?: TicketHistoryScalarFieldEnum | TicketHistoryScalarFieldEnum[]
  }

  /**
   * TicketHistory findFirstOrThrow
   */
  export type TicketHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketHistory to fetch.
     */
    where?: TicketHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketHistories to fetch.
     */
    orderBy?: TicketHistoryOrderByWithRelationInput | TicketHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketHistories.
     */
    cursor?: TicketHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketHistories.
     */
    distinct?: TicketHistoryScalarFieldEnum | TicketHistoryScalarFieldEnum[]
  }

  /**
   * TicketHistory findMany
   */
  export type TicketHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketHistories to fetch.
     */
    where?: TicketHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketHistories to fetch.
     */
    orderBy?: TicketHistoryOrderByWithRelationInput | TicketHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketHistories.
     */
    cursor?: TicketHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketHistories.
     */
    skip?: number
    distinct?: TicketHistoryScalarFieldEnum | TicketHistoryScalarFieldEnum[]
  }

  /**
   * TicketHistory create
   */
  export type TicketHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketHistory.
     */
    data: XOR<TicketHistoryCreateInput, TicketHistoryUncheckedCreateInput>
  }

  /**
   * TicketHistory createMany
   */
  export type TicketHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketHistories.
     */
    data: TicketHistoryCreateManyInput | TicketHistoryCreateManyInput[]
  }

  /**
   * TicketHistory update
   */
  export type TicketHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketHistory.
     */
    data: XOR<TicketHistoryUpdateInput, TicketHistoryUncheckedUpdateInput>
    /**
     * Choose, which TicketHistory to update.
     */
    where: TicketHistoryWhereUniqueInput
  }

  /**
   * TicketHistory updateMany
   */
  export type TicketHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketHistories.
     */
    data: XOR<TicketHistoryUpdateManyMutationInput, TicketHistoryUncheckedUpdateManyInput>
    /**
     * Filter which TicketHistories to update
     */
    where?: TicketHistoryWhereInput
  }

  /**
   * TicketHistory upsert
   */
  export type TicketHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketHistory to update in case it exists.
     */
    where: TicketHistoryWhereUniqueInput
    /**
     * In case the TicketHistory found by the `where` argument doesn't exist, create a new TicketHistory with this data.
     */
    create: XOR<TicketHistoryCreateInput, TicketHistoryUncheckedCreateInput>
    /**
     * In case the TicketHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketHistoryUpdateInput, TicketHistoryUncheckedUpdateInput>
  }

  /**
   * TicketHistory delete
   */
  export type TicketHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * Filter which TicketHistory to delete.
     */
    where: TicketHistoryWhereUniqueInput
  }

  /**
   * TicketHistory deleteMany
   */
  export type TicketHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketHistories to delete
     */
    where?: TicketHistoryWhereInput
  }

  /**
   * TicketHistory without action
   */
  export type TicketHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    empId: string | null
    email: string | null
    password: string | null
    role: string | null
    department: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    empId: string | null
    email: string | null
    password: string | null
    role: string | null
    department: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    empId: number
    email: number
    password: number
    role: number
    department: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    empId?: true
    email?: true
    password?: true
    role?: true
    department?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    empId?: true
    email?: true
    password?: true
    role?: true
    department?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    empId?: true
    email?: true
    password?: true
    role?: true
    department?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    empId: string
    email: string
    password: string
    role: string
    department: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    empId?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    department?: boolean
    Asset?: boolean | User$AssetArgs<ExtArgs>
    AssetHistory_AssetHistory_newOwnerIdToUser?: boolean | User$AssetHistory_AssetHistory_newOwnerIdToUserArgs<ExtArgs>
    AssetHistory_AssetHistory_oldOwnerIdToUser?: boolean | User$AssetHistory_AssetHistory_oldOwnerIdToUserArgs<ExtArgs>
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>
    Document?: boolean | User$DocumentArgs<ExtArgs>
    InventoryTransaction?: boolean | User$InventoryTransactionArgs<ExtArgs>
    KnowledgeBase?: boolean | User$KnowledgeBaseArgs<ExtArgs>
    Ticket_Ticket_assignedToIdToUser?: boolean | User$Ticket_Ticket_assignedToIdToUserArgs<ExtArgs>
    Ticket_Ticket_requestedByIdToUser?: boolean | User$Ticket_Ticket_requestedByIdToUserArgs<ExtArgs>
    TicketAttachment?: boolean | User$TicketAttachmentArgs<ExtArgs>
    TicketComment?: boolean | User$TicketCommentArgs<ExtArgs>
    TicketHistory?: boolean | User$TicketHistoryArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    empId?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    department?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Asset?: boolean | User$AssetArgs<ExtArgs>
    AssetHistory_AssetHistory_newOwnerIdToUser?: boolean | User$AssetHistory_AssetHistory_newOwnerIdToUserArgs<ExtArgs>
    AssetHistory_AssetHistory_oldOwnerIdToUser?: boolean | User$AssetHistory_AssetHistory_oldOwnerIdToUserArgs<ExtArgs>
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>
    Document?: boolean | User$DocumentArgs<ExtArgs>
    InventoryTransaction?: boolean | User$InventoryTransactionArgs<ExtArgs>
    KnowledgeBase?: boolean | User$KnowledgeBaseArgs<ExtArgs>
    Ticket_Ticket_assignedToIdToUser?: boolean | User$Ticket_Ticket_assignedToIdToUserArgs<ExtArgs>
    Ticket_Ticket_requestedByIdToUser?: boolean | User$Ticket_Ticket_requestedByIdToUserArgs<ExtArgs>
    TicketAttachment?: boolean | User$TicketAttachmentArgs<ExtArgs>
    TicketComment?: boolean | User$TicketCommentArgs<ExtArgs>
    TicketHistory?: boolean | User$TicketHistoryArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Asset: Prisma.$AssetPayload<ExtArgs>[]
      AssetHistory_AssetHistory_newOwnerIdToUser: Prisma.$AssetHistoryPayload<ExtArgs>[]
      AssetHistory_AssetHistory_oldOwnerIdToUser: Prisma.$AssetHistoryPayload<ExtArgs>[]
      AuditLog: Prisma.$AuditLogPayload<ExtArgs>[]
      Document: Prisma.$DocumentPayload<ExtArgs>[]
      InventoryTransaction: Prisma.$InventoryTransactionPayload<ExtArgs>[]
      KnowledgeBase: Prisma.$KnowledgeBasePayload<ExtArgs>[]
      Ticket_Ticket_assignedToIdToUser: Prisma.$TicketPayload<ExtArgs>[]
      Ticket_Ticket_requestedByIdToUser: Prisma.$TicketPayload<ExtArgs>[]
      TicketAttachment: Prisma.$TicketAttachmentPayload<ExtArgs>[]
      TicketComment: Prisma.$TicketCommentPayload<ExtArgs>[]
      TicketHistory: Prisma.$TicketHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      empId: string
      email: string
      password: string
      role: string
      department: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Asset<T extends User$AssetArgs<ExtArgs> = {}>(args?: Subset<T, User$AssetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany"> | Null>
    AssetHistory_AssetHistory_newOwnerIdToUser<T extends User$AssetHistory_AssetHistory_newOwnerIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$AssetHistory_AssetHistory_newOwnerIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    AssetHistory_AssetHistory_oldOwnerIdToUser<T extends User$AssetHistory_AssetHistory_oldOwnerIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$AssetHistory_AssetHistory_oldOwnerIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    AuditLog<T extends User$AuditLogArgs<ExtArgs> = {}>(args?: Subset<T, User$AuditLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    Document<T extends User$DocumentArgs<ExtArgs> = {}>(args?: Subset<T, User$DocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    InventoryTransaction<T extends User$InventoryTransactionArgs<ExtArgs> = {}>(args?: Subset<T, User$InventoryTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    KnowledgeBase<T extends User$KnowledgeBaseArgs<ExtArgs> = {}>(args?: Subset<T, User$KnowledgeBaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findMany"> | Null>
    Ticket_Ticket_assignedToIdToUser<T extends User$Ticket_Ticket_assignedToIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Ticket_Ticket_assignedToIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    Ticket_Ticket_requestedByIdToUser<T extends User$Ticket_Ticket_requestedByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Ticket_Ticket_requestedByIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    TicketAttachment<T extends User$TicketAttachmentArgs<ExtArgs> = {}>(args?: Subset<T, User$TicketAttachmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    TicketComment<T extends User$TicketCommentArgs<ExtArgs> = {}>(args?: Subset<T, User$TicketCommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany"> | Null>
    TicketHistory<T extends User$TicketHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$TicketHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly empId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly department: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.Asset
   */
  export type User$AssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * User.AssetHistory_AssetHistory_newOwnerIdToUser
   */
  export type User$AssetHistory_AssetHistory_newOwnerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    where?: AssetHistoryWhereInput
    orderBy?: AssetHistoryOrderByWithRelationInput | AssetHistoryOrderByWithRelationInput[]
    cursor?: AssetHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetHistoryScalarFieldEnum | AssetHistoryScalarFieldEnum[]
  }

  /**
   * User.AssetHistory_AssetHistory_oldOwnerIdToUser
   */
  export type User$AssetHistory_AssetHistory_oldOwnerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetHistory
     */
    select?: AssetHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetHistoryInclude<ExtArgs> | null
    where?: AssetHistoryWhereInput
    orderBy?: AssetHistoryOrderByWithRelationInput | AssetHistoryOrderByWithRelationInput[]
    cursor?: AssetHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetHistoryScalarFieldEnum | AssetHistoryScalarFieldEnum[]
  }

  /**
   * User.AuditLog
   */
  export type User$AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.Document
   */
  export type User$DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.InventoryTransaction
   */
  export type User$InventoryTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    cursor?: InventoryTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * User.KnowledgeBase
   */
  export type User$KnowledgeBaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    where?: KnowledgeBaseWhereInput
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    cursor?: KnowledgeBaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeBaseScalarFieldEnum | KnowledgeBaseScalarFieldEnum[]
  }

  /**
   * User.Ticket_Ticket_assignedToIdToUser
   */
  export type User$Ticket_Ticket_assignedToIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.Ticket_Ticket_requestedByIdToUser
   */
  export type User$Ticket_Ticket_requestedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.TicketAttachment
   */
  export type User$TicketAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    cursor?: TicketAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * User.TicketComment
   */
  export type User$TicketCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * User.TicketHistory
   */
  export type User$TicketHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    where?: TicketHistoryWhereInput
    orderBy?: TicketHistoryOrderByWithRelationInput | TicketHistoryOrderByWithRelationInput[]
    cursor?: TicketHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketHistoryScalarFieldEnum | TicketHistoryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    id: number | null
  }

  export type VendorSumAggregateOutputType = {
    id: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: number | null
    name: string | null
    contact: string | null
    email: string | null
    phone: string | null
    website: string | null
    address: string | null
  }

  export type VendorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    contact: string | null
    email: string | null
    phone: string | null
    website: string | null
    address: string | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    name: number
    contact: number
    email: number
    phone: number
    website: number
    address: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    id?: true
  }

  export type VendorSumAggregateInputType = {
    id?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    email?: true
    phone?: true
    website?: true
    address?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    email?: true
    phone?: true
    website?: true
    address?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    email?: true
    phone?: true
    website?: true
    address?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: number
    name: string
    contact: string | null
    email: string | null
    phone: string | null
    website: string | null
    address: string | null
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    address?: boolean
    Contract?: boolean | Vendor$ContractArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>


  export type VendorSelectScalar = {
    id?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    address?: boolean
  }

  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Contract?: boolean | Vendor$ContractArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      Contract: Prisma.$ContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      contact: string | null
      email: string | null
      phone: string | null
      website: string | null
      address: string | null
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Contract<T extends Vendor$ContractArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$ContractArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */ 
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'Int'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly contact: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly phone: FieldRef<"Vendor", 'String'>
    readonly website: FieldRef<"Vendor", 'String'>
    readonly address: FieldRef<"Vendor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
  }

  /**
   * Vendor.Contract
   */
  export type Vendor$ContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model webmes_User
   */

  export type AggregateWebmes_User = {
    _count: Webmes_UserCountAggregateOutputType | null
    _avg: Webmes_UserAvgAggregateOutputType | null
    _sum: Webmes_UserSumAggregateOutputType | null
    _min: Webmes_UserMinAggregateOutputType | null
    _max: Webmes_UserMaxAggregateOutputType | null
  }

  export type Webmes_UserAvgAggregateOutputType = {
    id: number | null
  }

  export type Webmes_UserSumAggregateOutputType = {
    id: number | null
  }

  export type Webmes_UserMinAggregateOutputType = {
    id: number | null
    employeeId: string | null
    fullName: string | null
    department: string | null
    email: string | null
    password: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Webmes_UserMaxAggregateOutputType = {
    id: number | null
    employeeId: string | null
    fullName: string | null
    department: string | null
    email: string | null
    password: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Webmes_UserCountAggregateOutputType = {
    id: number
    employeeId: number
    fullName: number
    department: number
    email: number
    password: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Webmes_UserAvgAggregateInputType = {
    id?: true
  }

  export type Webmes_UserSumAggregateInputType = {
    id?: true
  }

  export type Webmes_UserMinAggregateInputType = {
    id?: true
    employeeId?: true
    fullName?: true
    department?: true
    email?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Webmes_UserMaxAggregateInputType = {
    id?: true
    employeeId?: true
    fullName?: true
    department?: true
    email?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Webmes_UserCountAggregateInputType = {
    id?: true
    employeeId?: true
    fullName?: true
    department?: true
    email?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Webmes_UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webmes_User to aggregate.
     */
    where?: webmes_UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_Users to fetch.
     */
    orderBy?: webmes_UserOrderByWithRelationInput | webmes_UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: webmes_UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned webmes_Users
    **/
    _count?: true | Webmes_UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Webmes_UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Webmes_UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Webmes_UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Webmes_UserMaxAggregateInputType
  }

  export type GetWebmes_UserAggregateType<T extends Webmes_UserAggregateArgs> = {
        [P in keyof T & keyof AggregateWebmes_User]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebmes_User[P]>
      : GetScalarType<T[P], AggregateWebmes_User[P]>
  }




  export type webmes_UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: webmes_UserWhereInput
    orderBy?: webmes_UserOrderByWithAggregationInput | webmes_UserOrderByWithAggregationInput[]
    by: Webmes_UserScalarFieldEnum[] | Webmes_UserScalarFieldEnum
    having?: webmes_UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Webmes_UserCountAggregateInputType | true
    _avg?: Webmes_UserAvgAggregateInputType
    _sum?: Webmes_UserSumAggregateInputType
    _min?: Webmes_UserMinAggregateInputType
    _max?: Webmes_UserMaxAggregateInputType
  }

  export type Webmes_UserGroupByOutputType = {
    id: number
    employeeId: string
    fullName: string
    department: string
    email: string
    password: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Webmes_UserCountAggregateOutputType | null
    _avg: Webmes_UserAvgAggregateOutputType | null
    _sum: Webmes_UserSumAggregateOutputType | null
    _min: Webmes_UserMinAggregateOutputType | null
    _max: Webmes_UserMaxAggregateOutputType | null
  }

  type GetWebmes_UserGroupByPayload<T extends webmes_UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Webmes_UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Webmes_UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Webmes_UserGroupByOutputType[P]>
            : GetScalarType<T[P], Webmes_UserGroupByOutputType[P]>
        }
      >
    >


  export type webmes_UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    fullName?: boolean
    department?: boolean
    email?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean | webmes_User$rolesArgs<ExtArgs>
    _count?: boolean | Webmes_UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webmes_User"]>


  export type webmes_UserSelectScalar = {
    id?: boolean
    employeeId?: boolean
    fullName?: boolean
    department?: boolean
    email?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type webmes_UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | webmes_User$rolesArgs<ExtArgs>
    _count?: boolean | Webmes_UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $webmes_UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "webmes_User"
    objects: {
      roles: Prisma.$webmes_UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: string
      fullName: string
      department: string
      email: string
      password: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["webmes_User"]>
    composites: {}
  }

  type webmes_UserGetPayload<S extends boolean | null | undefined | webmes_UserDefaultArgs> = $Result.GetResult<Prisma.$webmes_UserPayload, S>

  type webmes_UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<webmes_UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Webmes_UserCountAggregateInputType | true
    }

  export interface webmes_UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['webmes_User'], meta: { name: 'webmes_User' } }
    /**
     * Find zero or one Webmes_User that matches the filter.
     * @param {webmes_UserFindUniqueArgs} args - Arguments to find a Webmes_User
     * @example
     * // Get one Webmes_User
     * const webmes_User = await prisma.webmes_User.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends webmes_UserFindUniqueArgs>(args: SelectSubset<T, webmes_UserFindUniqueArgs<ExtArgs>>): Prisma__webmes_UserClient<$Result.GetResult<Prisma.$webmes_UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Webmes_User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {webmes_UserFindUniqueOrThrowArgs} args - Arguments to find a Webmes_User
     * @example
     * // Get one Webmes_User
     * const webmes_User = await prisma.webmes_User.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends webmes_UserFindUniqueOrThrowArgs>(args: SelectSubset<T, webmes_UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__webmes_UserClient<$Result.GetResult<Prisma.$webmes_UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Webmes_User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_UserFindFirstArgs} args - Arguments to find a Webmes_User
     * @example
     * // Get one Webmes_User
     * const webmes_User = await prisma.webmes_User.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends webmes_UserFindFirstArgs>(args?: SelectSubset<T, webmes_UserFindFirstArgs<ExtArgs>>): Prisma__webmes_UserClient<$Result.GetResult<Prisma.$webmes_UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Webmes_User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_UserFindFirstOrThrowArgs} args - Arguments to find a Webmes_User
     * @example
     * // Get one Webmes_User
     * const webmes_User = await prisma.webmes_User.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends webmes_UserFindFirstOrThrowArgs>(args?: SelectSubset<T, webmes_UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__webmes_UserClient<$Result.GetResult<Prisma.$webmes_UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Webmes_Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webmes_Users
     * const webmes_Users = await prisma.webmes_User.findMany()
     * 
     * // Get first 10 Webmes_Users
     * const webmes_Users = await prisma.webmes_User.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webmes_UserWithIdOnly = await prisma.webmes_User.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends webmes_UserFindManyArgs>(args?: SelectSubset<T, webmes_UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$webmes_UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Webmes_User.
     * @param {webmes_UserCreateArgs} args - Arguments to create a Webmes_User.
     * @example
     * // Create one Webmes_User
     * const Webmes_User = await prisma.webmes_User.create({
     *   data: {
     *     // ... data to create a Webmes_User
     *   }
     * })
     * 
     */
    create<T extends webmes_UserCreateArgs>(args: SelectSubset<T, webmes_UserCreateArgs<ExtArgs>>): Prisma__webmes_UserClient<$Result.GetResult<Prisma.$webmes_UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Webmes_Users.
     * @param {webmes_UserCreateManyArgs} args - Arguments to create many Webmes_Users.
     * @example
     * // Create many Webmes_Users
     * const webmes_User = await prisma.webmes_User.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends webmes_UserCreateManyArgs>(args?: SelectSubset<T, webmes_UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Webmes_User.
     * @param {webmes_UserDeleteArgs} args - Arguments to delete one Webmes_User.
     * @example
     * // Delete one Webmes_User
     * const Webmes_User = await prisma.webmes_User.delete({
     *   where: {
     *     // ... filter to delete one Webmes_User
     *   }
     * })
     * 
     */
    delete<T extends webmes_UserDeleteArgs>(args: SelectSubset<T, webmes_UserDeleteArgs<ExtArgs>>): Prisma__webmes_UserClient<$Result.GetResult<Prisma.$webmes_UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Webmes_User.
     * @param {webmes_UserUpdateArgs} args - Arguments to update one Webmes_User.
     * @example
     * // Update one Webmes_User
     * const webmes_User = await prisma.webmes_User.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends webmes_UserUpdateArgs>(args: SelectSubset<T, webmes_UserUpdateArgs<ExtArgs>>): Prisma__webmes_UserClient<$Result.GetResult<Prisma.$webmes_UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Webmes_Users.
     * @param {webmes_UserDeleteManyArgs} args - Arguments to filter Webmes_Users to delete.
     * @example
     * // Delete a few Webmes_Users
     * const { count } = await prisma.webmes_User.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends webmes_UserDeleteManyArgs>(args?: SelectSubset<T, webmes_UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webmes_Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webmes_Users
     * const webmes_User = await prisma.webmes_User.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends webmes_UserUpdateManyArgs>(args: SelectSubset<T, webmes_UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Webmes_User.
     * @param {webmes_UserUpsertArgs} args - Arguments to update or create a Webmes_User.
     * @example
     * // Update or create a Webmes_User
     * const webmes_User = await prisma.webmes_User.upsert({
     *   create: {
     *     // ... data to create a Webmes_User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webmes_User we want to update
     *   }
     * })
     */
    upsert<T extends webmes_UserUpsertArgs>(args: SelectSubset<T, webmes_UserUpsertArgs<ExtArgs>>): Prisma__webmes_UserClient<$Result.GetResult<Prisma.$webmes_UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Webmes_Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_UserCountArgs} args - Arguments to filter Webmes_Users to count.
     * @example
     * // Count the number of Webmes_Users
     * const count = await prisma.webmes_User.count({
     *   where: {
     *     // ... the filter for the Webmes_Users we want to count
     *   }
     * })
    **/
    count<T extends webmes_UserCountArgs>(
      args?: Subset<T, webmes_UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Webmes_UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webmes_User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Webmes_UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Webmes_UserAggregateArgs>(args: Subset<T, Webmes_UserAggregateArgs>): Prisma.PrismaPromise<GetWebmes_UserAggregateType<T>>

    /**
     * Group by Webmes_User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends webmes_UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: webmes_UserGroupByArgs['orderBy'] }
        : { orderBy?: webmes_UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, webmes_UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebmes_UserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the webmes_User model
   */
  readonly fields: webmes_UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for webmes_User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__webmes_UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends webmes_User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, webmes_User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$webmes_UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the webmes_User model
   */ 
  interface webmes_UserFieldRefs {
    readonly id: FieldRef<"webmes_User", 'Int'>
    readonly employeeId: FieldRef<"webmes_User", 'String'>
    readonly fullName: FieldRef<"webmes_User", 'String'>
    readonly department: FieldRef<"webmes_User", 'String'>
    readonly email: FieldRef<"webmes_User", 'String'>
    readonly password: FieldRef<"webmes_User", 'String'>
    readonly isActive: FieldRef<"webmes_User", 'Boolean'>
    readonly createdAt: FieldRef<"webmes_User", 'DateTime'>
    readonly updatedAt: FieldRef<"webmes_User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * webmes_User findUnique
   */
  export type webmes_UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_User
     */
    select?: webmes_UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserInclude<ExtArgs> | null
    /**
     * Filter, which webmes_User to fetch.
     */
    where: webmes_UserWhereUniqueInput
  }

  /**
   * webmes_User findUniqueOrThrow
   */
  export type webmes_UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_User
     */
    select?: webmes_UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserInclude<ExtArgs> | null
    /**
     * Filter, which webmes_User to fetch.
     */
    where: webmes_UserWhereUniqueInput
  }

  /**
   * webmes_User findFirst
   */
  export type webmes_UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_User
     */
    select?: webmes_UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserInclude<ExtArgs> | null
    /**
     * Filter, which webmes_User to fetch.
     */
    where?: webmes_UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_Users to fetch.
     */
    orderBy?: webmes_UserOrderByWithRelationInput | webmes_UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webmes_Users.
     */
    cursor?: webmes_UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webmes_Users.
     */
    distinct?: Webmes_UserScalarFieldEnum | Webmes_UserScalarFieldEnum[]
  }

  /**
   * webmes_User findFirstOrThrow
   */
  export type webmes_UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_User
     */
    select?: webmes_UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserInclude<ExtArgs> | null
    /**
     * Filter, which webmes_User to fetch.
     */
    where?: webmes_UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_Users to fetch.
     */
    orderBy?: webmes_UserOrderByWithRelationInput | webmes_UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webmes_Users.
     */
    cursor?: webmes_UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webmes_Users.
     */
    distinct?: Webmes_UserScalarFieldEnum | Webmes_UserScalarFieldEnum[]
  }

  /**
   * webmes_User findMany
   */
  export type webmes_UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_User
     */
    select?: webmes_UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserInclude<ExtArgs> | null
    /**
     * Filter, which webmes_Users to fetch.
     */
    where?: webmes_UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_Users to fetch.
     */
    orderBy?: webmes_UserOrderByWithRelationInput | webmes_UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing webmes_Users.
     */
    cursor?: webmes_UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_Users.
     */
    skip?: number
    distinct?: Webmes_UserScalarFieldEnum | Webmes_UserScalarFieldEnum[]
  }

  /**
   * webmes_User create
   */
  export type webmes_UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_User
     */
    select?: webmes_UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserInclude<ExtArgs> | null
    /**
     * The data needed to create a webmes_User.
     */
    data: XOR<webmes_UserCreateInput, webmes_UserUncheckedCreateInput>
  }

  /**
   * webmes_User createMany
   */
  export type webmes_UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many webmes_Users.
     */
    data: webmes_UserCreateManyInput | webmes_UserCreateManyInput[]
  }

  /**
   * webmes_User update
   */
  export type webmes_UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_User
     */
    select?: webmes_UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserInclude<ExtArgs> | null
    /**
     * The data needed to update a webmes_User.
     */
    data: XOR<webmes_UserUpdateInput, webmes_UserUncheckedUpdateInput>
    /**
     * Choose, which webmes_User to update.
     */
    where: webmes_UserWhereUniqueInput
  }

  /**
   * webmes_User updateMany
   */
  export type webmes_UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update webmes_Users.
     */
    data: XOR<webmes_UserUpdateManyMutationInput, webmes_UserUncheckedUpdateManyInput>
    /**
     * Filter which webmes_Users to update
     */
    where?: webmes_UserWhereInput
  }

  /**
   * webmes_User upsert
   */
  export type webmes_UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_User
     */
    select?: webmes_UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserInclude<ExtArgs> | null
    /**
     * The filter to search for the webmes_User to update in case it exists.
     */
    where: webmes_UserWhereUniqueInput
    /**
     * In case the webmes_User found by the `where` argument doesn't exist, create a new webmes_User with this data.
     */
    create: XOR<webmes_UserCreateInput, webmes_UserUncheckedCreateInput>
    /**
     * In case the webmes_User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<webmes_UserUpdateInput, webmes_UserUncheckedUpdateInput>
  }

  /**
   * webmes_User delete
   */
  export type webmes_UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_User
     */
    select?: webmes_UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserInclude<ExtArgs> | null
    /**
     * Filter which webmes_User to delete.
     */
    where: webmes_UserWhereUniqueInput
  }

  /**
   * webmes_User deleteMany
   */
  export type webmes_UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webmes_Users to delete
     */
    where?: webmes_UserWhereInput
  }

  /**
   * webmes_User.roles
   */
  export type webmes_User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_UserRole
     */
    select?: webmes_UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserRoleInclude<ExtArgs> | null
    where?: webmes_UserRoleWhereInput
    orderBy?: webmes_UserRoleOrderByWithRelationInput | webmes_UserRoleOrderByWithRelationInput[]
    cursor?: webmes_UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Webmes_UserRoleScalarFieldEnum | Webmes_UserRoleScalarFieldEnum[]
  }

  /**
   * webmes_User without action
   */
  export type webmes_UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_User
     */
    select?: webmes_UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserInclude<ExtArgs> | null
  }


  /**
   * Model webmes_Role
   */

  export type AggregateWebmes_Role = {
    _count: Webmes_RoleCountAggregateOutputType | null
    _avg: Webmes_RoleAvgAggregateOutputType | null
    _sum: Webmes_RoleSumAggregateOutputType | null
    _min: Webmes_RoleMinAggregateOutputType | null
    _max: Webmes_RoleMaxAggregateOutputType | null
  }

  export type Webmes_RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type Webmes_RoleSumAggregateOutputType = {
    id: number | null
  }

  export type Webmes_RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type Webmes_RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type Webmes_RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type Webmes_RoleAvgAggregateInputType = {
    id?: true
  }

  export type Webmes_RoleSumAggregateInputType = {
    id?: true
  }

  export type Webmes_RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type Webmes_RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type Webmes_RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type Webmes_RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webmes_Role to aggregate.
     */
    where?: webmes_RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_Roles to fetch.
     */
    orderBy?: webmes_RoleOrderByWithRelationInput | webmes_RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: webmes_RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned webmes_Roles
    **/
    _count?: true | Webmes_RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Webmes_RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Webmes_RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Webmes_RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Webmes_RoleMaxAggregateInputType
  }

  export type GetWebmes_RoleAggregateType<T extends Webmes_RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateWebmes_Role]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebmes_Role[P]>
      : GetScalarType<T[P], AggregateWebmes_Role[P]>
  }




  export type webmes_RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: webmes_RoleWhereInput
    orderBy?: webmes_RoleOrderByWithAggregationInput | webmes_RoleOrderByWithAggregationInput[]
    by: Webmes_RoleScalarFieldEnum[] | Webmes_RoleScalarFieldEnum
    having?: webmes_RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Webmes_RoleCountAggregateInputType | true
    _avg?: Webmes_RoleAvgAggregateInputType
    _sum?: Webmes_RoleSumAggregateInputType
    _min?: Webmes_RoleMinAggregateInputType
    _max?: Webmes_RoleMaxAggregateInputType
  }

  export type Webmes_RoleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: Webmes_RoleCountAggregateOutputType | null
    _avg: Webmes_RoleAvgAggregateOutputType | null
    _sum: Webmes_RoleSumAggregateOutputType | null
    _min: Webmes_RoleMinAggregateOutputType | null
    _max: Webmes_RoleMaxAggregateOutputType | null
  }

  type GetWebmes_RoleGroupByPayload<T extends webmes_RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Webmes_RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Webmes_RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Webmes_RoleGroupByOutputType[P]>
            : GetScalarType<T[P], Webmes_RoleGroupByOutputType[P]>
        }
      >
    >


  export type webmes_RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean | webmes_Role$permissionsArgs<ExtArgs>
    users?: boolean | webmes_Role$usersArgs<ExtArgs>
    _count?: boolean | Webmes_RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webmes_Role"]>


  export type webmes_RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type webmes_RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | webmes_Role$permissionsArgs<ExtArgs>
    users?: boolean | webmes_Role$usersArgs<ExtArgs>
    _count?: boolean | Webmes_RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $webmes_RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "webmes_Role"
    objects: {
      permissions: Prisma.$webmes_RolePermissionPayload<ExtArgs>[]
      users: Prisma.$webmes_UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
    }, ExtArgs["result"]["webmes_Role"]>
    composites: {}
  }

  type webmes_RoleGetPayload<S extends boolean | null | undefined | webmes_RoleDefaultArgs> = $Result.GetResult<Prisma.$webmes_RolePayload, S>

  type webmes_RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<webmes_RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Webmes_RoleCountAggregateInputType | true
    }

  export interface webmes_RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['webmes_Role'], meta: { name: 'webmes_Role' } }
    /**
     * Find zero or one Webmes_Role that matches the filter.
     * @param {webmes_RoleFindUniqueArgs} args - Arguments to find a Webmes_Role
     * @example
     * // Get one Webmes_Role
     * const webmes_Role = await prisma.webmes_Role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends webmes_RoleFindUniqueArgs>(args: SelectSubset<T, webmes_RoleFindUniqueArgs<ExtArgs>>): Prisma__webmes_RoleClient<$Result.GetResult<Prisma.$webmes_RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Webmes_Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {webmes_RoleFindUniqueOrThrowArgs} args - Arguments to find a Webmes_Role
     * @example
     * // Get one Webmes_Role
     * const webmes_Role = await prisma.webmes_Role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends webmes_RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, webmes_RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__webmes_RoleClient<$Result.GetResult<Prisma.$webmes_RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Webmes_Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_RoleFindFirstArgs} args - Arguments to find a Webmes_Role
     * @example
     * // Get one Webmes_Role
     * const webmes_Role = await prisma.webmes_Role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends webmes_RoleFindFirstArgs>(args?: SelectSubset<T, webmes_RoleFindFirstArgs<ExtArgs>>): Prisma__webmes_RoleClient<$Result.GetResult<Prisma.$webmes_RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Webmes_Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_RoleFindFirstOrThrowArgs} args - Arguments to find a Webmes_Role
     * @example
     * // Get one Webmes_Role
     * const webmes_Role = await prisma.webmes_Role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends webmes_RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, webmes_RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__webmes_RoleClient<$Result.GetResult<Prisma.$webmes_RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Webmes_Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webmes_Roles
     * const webmes_Roles = await prisma.webmes_Role.findMany()
     * 
     * // Get first 10 Webmes_Roles
     * const webmes_Roles = await prisma.webmes_Role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webmes_RoleWithIdOnly = await prisma.webmes_Role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends webmes_RoleFindManyArgs>(args?: SelectSubset<T, webmes_RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$webmes_RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Webmes_Role.
     * @param {webmes_RoleCreateArgs} args - Arguments to create a Webmes_Role.
     * @example
     * // Create one Webmes_Role
     * const Webmes_Role = await prisma.webmes_Role.create({
     *   data: {
     *     // ... data to create a Webmes_Role
     *   }
     * })
     * 
     */
    create<T extends webmes_RoleCreateArgs>(args: SelectSubset<T, webmes_RoleCreateArgs<ExtArgs>>): Prisma__webmes_RoleClient<$Result.GetResult<Prisma.$webmes_RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Webmes_Roles.
     * @param {webmes_RoleCreateManyArgs} args - Arguments to create many Webmes_Roles.
     * @example
     * // Create many Webmes_Roles
     * const webmes_Role = await prisma.webmes_Role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends webmes_RoleCreateManyArgs>(args?: SelectSubset<T, webmes_RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Webmes_Role.
     * @param {webmes_RoleDeleteArgs} args - Arguments to delete one Webmes_Role.
     * @example
     * // Delete one Webmes_Role
     * const Webmes_Role = await prisma.webmes_Role.delete({
     *   where: {
     *     // ... filter to delete one Webmes_Role
     *   }
     * })
     * 
     */
    delete<T extends webmes_RoleDeleteArgs>(args: SelectSubset<T, webmes_RoleDeleteArgs<ExtArgs>>): Prisma__webmes_RoleClient<$Result.GetResult<Prisma.$webmes_RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Webmes_Role.
     * @param {webmes_RoleUpdateArgs} args - Arguments to update one Webmes_Role.
     * @example
     * // Update one Webmes_Role
     * const webmes_Role = await prisma.webmes_Role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends webmes_RoleUpdateArgs>(args: SelectSubset<T, webmes_RoleUpdateArgs<ExtArgs>>): Prisma__webmes_RoleClient<$Result.GetResult<Prisma.$webmes_RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Webmes_Roles.
     * @param {webmes_RoleDeleteManyArgs} args - Arguments to filter Webmes_Roles to delete.
     * @example
     * // Delete a few Webmes_Roles
     * const { count } = await prisma.webmes_Role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends webmes_RoleDeleteManyArgs>(args?: SelectSubset<T, webmes_RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webmes_Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webmes_Roles
     * const webmes_Role = await prisma.webmes_Role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends webmes_RoleUpdateManyArgs>(args: SelectSubset<T, webmes_RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Webmes_Role.
     * @param {webmes_RoleUpsertArgs} args - Arguments to update or create a Webmes_Role.
     * @example
     * // Update or create a Webmes_Role
     * const webmes_Role = await prisma.webmes_Role.upsert({
     *   create: {
     *     // ... data to create a Webmes_Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webmes_Role we want to update
     *   }
     * })
     */
    upsert<T extends webmes_RoleUpsertArgs>(args: SelectSubset<T, webmes_RoleUpsertArgs<ExtArgs>>): Prisma__webmes_RoleClient<$Result.GetResult<Prisma.$webmes_RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Webmes_Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_RoleCountArgs} args - Arguments to filter Webmes_Roles to count.
     * @example
     * // Count the number of Webmes_Roles
     * const count = await prisma.webmes_Role.count({
     *   where: {
     *     // ... the filter for the Webmes_Roles we want to count
     *   }
     * })
    **/
    count<T extends webmes_RoleCountArgs>(
      args?: Subset<T, webmes_RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Webmes_RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webmes_Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Webmes_RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Webmes_RoleAggregateArgs>(args: Subset<T, Webmes_RoleAggregateArgs>): Prisma.PrismaPromise<GetWebmes_RoleAggregateType<T>>

    /**
     * Group by Webmes_Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends webmes_RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: webmes_RoleGroupByArgs['orderBy'] }
        : { orderBy?: webmes_RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, webmes_RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebmes_RoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the webmes_Role model
   */
  readonly fields: webmes_RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for webmes_Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__webmes_RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends webmes_Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, webmes_Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$webmes_RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends webmes_Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, webmes_Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$webmes_UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the webmes_Role model
   */ 
  interface webmes_RoleFieldRefs {
    readonly id: FieldRef<"webmes_Role", 'Int'>
    readonly name: FieldRef<"webmes_Role", 'String'>
    readonly description: FieldRef<"webmes_Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * webmes_Role findUnique
   */
  export type webmes_RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Role
     */
    select?: webmes_RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RoleInclude<ExtArgs> | null
    /**
     * Filter, which webmes_Role to fetch.
     */
    where: webmes_RoleWhereUniqueInput
  }

  /**
   * webmes_Role findUniqueOrThrow
   */
  export type webmes_RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Role
     */
    select?: webmes_RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RoleInclude<ExtArgs> | null
    /**
     * Filter, which webmes_Role to fetch.
     */
    where: webmes_RoleWhereUniqueInput
  }

  /**
   * webmes_Role findFirst
   */
  export type webmes_RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Role
     */
    select?: webmes_RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RoleInclude<ExtArgs> | null
    /**
     * Filter, which webmes_Role to fetch.
     */
    where?: webmes_RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_Roles to fetch.
     */
    orderBy?: webmes_RoleOrderByWithRelationInput | webmes_RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webmes_Roles.
     */
    cursor?: webmes_RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webmes_Roles.
     */
    distinct?: Webmes_RoleScalarFieldEnum | Webmes_RoleScalarFieldEnum[]
  }

  /**
   * webmes_Role findFirstOrThrow
   */
  export type webmes_RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Role
     */
    select?: webmes_RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RoleInclude<ExtArgs> | null
    /**
     * Filter, which webmes_Role to fetch.
     */
    where?: webmes_RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_Roles to fetch.
     */
    orderBy?: webmes_RoleOrderByWithRelationInput | webmes_RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webmes_Roles.
     */
    cursor?: webmes_RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webmes_Roles.
     */
    distinct?: Webmes_RoleScalarFieldEnum | Webmes_RoleScalarFieldEnum[]
  }

  /**
   * webmes_Role findMany
   */
  export type webmes_RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Role
     */
    select?: webmes_RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RoleInclude<ExtArgs> | null
    /**
     * Filter, which webmes_Roles to fetch.
     */
    where?: webmes_RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_Roles to fetch.
     */
    orderBy?: webmes_RoleOrderByWithRelationInput | webmes_RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing webmes_Roles.
     */
    cursor?: webmes_RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_Roles.
     */
    skip?: number
    distinct?: Webmes_RoleScalarFieldEnum | Webmes_RoleScalarFieldEnum[]
  }

  /**
   * webmes_Role create
   */
  export type webmes_RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Role
     */
    select?: webmes_RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a webmes_Role.
     */
    data: XOR<webmes_RoleCreateInput, webmes_RoleUncheckedCreateInput>
  }

  /**
   * webmes_Role createMany
   */
  export type webmes_RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many webmes_Roles.
     */
    data: webmes_RoleCreateManyInput | webmes_RoleCreateManyInput[]
  }

  /**
   * webmes_Role update
   */
  export type webmes_RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Role
     */
    select?: webmes_RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a webmes_Role.
     */
    data: XOR<webmes_RoleUpdateInput, webmes_RoleUncheckedUpdateInput>
    /**
     * Choose, which webmes_Role to update.
     */
    where: webmes_RoleWhereUniqueInput
  }

  /**
   * webmes_Role updateMany
   */
  export type webmes_RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update webmes_Roles.
     */
    data: XOR<webmes_RoleUpdateManyMutationInput, webmes_RoleUncheckedUpdateManyInput>
    /**
     * Filter which webmes_Roles to update
     */
    where?: webmes_RoleWhereInput
  }

  /**
   * webmes_Role upsert
   */
  export type webmes_RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Role
     */
    select?: webmes_RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the webmes_Role to update in case it exists.
     */
    where: webmes_RoleWhereUniqueInput
    /**
     * In case the webmes_Role found by the `where` argument doesn't exist, create a new webmes_Role with this data.
     */
    create: XOR<webmes_RoleCreateInput, webmes_RoleUncheckedCreateInput>
    /**
     * In case the webmes_Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<webmes_RoleUpdateInput, webmes_RoleUncheckedUpdateInput>
  }

  /**
   * webmes_Role delete
   */
  export type webmes_RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Role
     */
    select?: webmes_RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RoleInclude<ExtArgs> | null
    /**
     * Filter which webmes_Role to delete.
     */
    where: webmes_RoleWhereUniqueInput
  }

  /**
   * webmes_Role deleteMany
   */
  export type webmes_RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webmes_Roles to delete
     */
    where?: webmes_RoleWhereInput
  }

  /**
   * webmes_Role.permissions
   */
  export type webmes_Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_RolePermission
     */
    select?: webmes_RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RolePermissionInclude<ExtArgs> | null
    where?: webmes_RolePermissionWhereInput
    orderBy?: webmes_RolePermissionOrderByWithRelationInput | webmes_RolePermissionOrderByWithRelationInput[]
    cursor?: webmes_RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Webmes_RolePermissionScalarFieldEnum | Webmes_RolePermissionScalarFieldEnum[]
  }

  /**
   * webmes_Role.users
   */
  export type webmes_Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_UserRole
     */
    select?: webmes_UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserRoleInclude<ExtArgs> | null
    where?: webmes_UserRoleWhereInput
    orderBy?: webmes_UserRoleOrderByWithRelationInput | webmes_UserRoleOrderByWithRelationInput[]
    cursor?: webmes_UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Webmes_UserRoleScalarFieldEnum | Webmes_UserRoleScalarFieldEnum[]
  }

  /**
   * webmes_Role without action
   */
  export type webmes_RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Role
     */
    select?: webmes_RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RoleInclude<ExtArgs> | null
  }


  /**
   * Model webmes_Permission
   */

  export type AggregateWebmes_Permission = {
    _count: Webmes_PermissionCountAggregateOutputType | null
    _avg: Webmes_PermissionAvgAggregateOutputType | null
    _sum: Webmes_PermissionSumAggregateOutputType | null
    _min: Webmes_PermissionMinAggregateOutputType | null
    _max: Webmes_PermissionMaxAggregateOutputType | null
  }

  export type Webmes_PermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type Webmes_PermissionSumAggregateOutputType = {
    id: number | null
  }

  export type Webmes_PermissionMinAggregateOutputType = {
    id: number | null
    name: string | null
    module: string | null
  }

  export type Webmes_PermissionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    module: string | null
  }

  export type Webmes_PermissionCountAggregateOutputType = {
    id: number
    name: number
    module: number
    _all: number
  }


  export type Webmes_PermissionAvgAggregateInputType = {
    id?: true
  }

  export type Webmes_PermissionSumAggregateInputType = {
    id?: true
  }

  export type Webmes_PermissionMinAggregateInputType = {
    id?: true
    name?: true
    module?: true
  }

  export type Webmes_PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    module?: true
  }

  export type Webmes_PermissionCountAggregateInputType = {
    id?: true
    name?: true
    module?: true
    _all?: true
  }

  export type Webmes_PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webmes_Permission to aggregate.
     */
    where?: webmes_PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_Permissions to fetch.
     */
    orderBy?: webmes_PermissionOrderByWithRelationInput | webmes_PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: webmes_PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned webmes_Permissions
    **/
    _count?: true | Webmes_PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Webmes_PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Webmes_PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Webmes_PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Webmes_PermissionMaxAggregateInputType
  }

  export type GetWebmes_PermissionAggregateType<T extends Webmes_PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateWebmes_Permission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebmes_Permission[P]>
      : GetScalarType<T[P], AggregateWebmes_Permission[P]>
  }




  export type webmes_PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: webmes_PermissionWhereInput
    orderBy?: webmes_PermissionOrderByWithAggregationInput | webmes_PermissionOrderByWithAggregationInput[]
    by: Webmes_PermissionScalarFieldEnum[] | Webmes_PermissionScalarFieldEnum
    having?: webmes_PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Webmes_PermissionCountAggregateInputType | true
    _avg?: Webmes_PermissionAvgAggregateInputType
    _sum?: Webmes_PermissionSumAggregateInputType
    _min?: Webmes_PermissionMinAggregateInputType
    _max?: Webmes_PermissionMaxAggregateInputType
  }

  export type Webmes_PermissionGroupByOutputType = {
    id: number
    name: string
    module: string
    _count: Webmes_PermissionCountAggregateOutputType | null
    _avg: Webmes_PermissionAvgAggregateOutputType | null
    _sum: Webmes_PermissionSumAggregateOutputType | null
    _min: Webmes_PermissionMinAggregateOutputType | null
    _max: Webmes_PermissionMaxAggregateOutputType | null
  }

  type GetWebmes_PermissionGroupByPayload<T extends webmes_PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Webmes_PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Webmes_PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Webmes_PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], Webmes_PermissionGroupByOutputType[P]>
        }
      >
    >


  export type webmes_PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    module?: boolean
    roles?: boolean | webmes_Permission$rolesArgs<ExtArgs>
    _count?: boolean | Webmes_PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webmes_Permission"]>


  export type webmes_PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    module?: boolean
  }

  export type webmes_PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | webmes_Permission$rolesArgs<ExtArgs>
    _count?: boolean | Webmes_PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $webmes_PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "webmes_Permission"
    objects: {
      roles: Prisma.$webmes_RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      module: string
    }, ExtArgs["result"]["webmes_Permission"]>
    composites: {}
  }

  type webmes_PermissionGetPayload<S extends boolean | null | undefined | webmes_PermissionDefaultArgs> = $Result.GetResult<Prisma.$webmes_PermissionPayload, S>

  type webmes_PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<webmes_PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Webmes_PermissionCountAggregateInputType | true
    }

  export interface webmes_PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['webmes_Permission'], meta: { name: 'webmes_Permission' } }
    /**
     * Find zero or one Webmes_Permission that matches the filter.
     * @param {webmes_PermissionFindUniqueArgs} args - Arguments to find a Webmes_Permission
     * @example
     * // Get one Webmes_Permission
     * const webmes_Permission = await prisma.webmes_Permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends webmes_PermissionFindUniqueArgs>(args: SelectSubset<T, webmes_PermissionFindUniqueArgs<ExtArgs>>): Prisma__webmes_PermissionClient<$Result.GetResult<Prisma.$webmes_PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Webmes_Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {webmes_PermissionFindUniqueOrThrowArgs} args - Arguments to find a Webmes_Permission
     * @example
     * // Get one Webmes_Permission
     * const webmes_Permission = await prisma.webmes_Permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends webmes_PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, webmes_PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__webmes_PermissionClient<$Result.GetResult<Prisma.$webmes_PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Webmes_Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_PermissionFindFirstArgs} args - Arguments to find a Webmes_Permission
     * @example
     * // Get one Webmes_Permission
     * const webmes_Permission = await prisma.webmes_Permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends webmes_PermissionFindFirstArgs>(args?: SelectSubset<T, webmes_PermissionFindFirstArgs<ExtArgs>>): Prisma__webmes_PermissionClient<$Result.GetResult<Prisma.$webmes_PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Webmes_Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_PermissionFindFirstOrThrowArgs} args - Arguments to find a Webmes_Permission
     * @example
     * // Get one Webmes_Permission
     * const webmes_Permission = await prisma.webmes_Permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends webmes_PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, webmes_PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__webmes_PermissionClient<$Result.GetResult<Prisma.$webmes_PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Webmes_Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webmes_Permissions
     * const webmes_Permissions = await prisma.webmes_Permission.findMany()
     * 
     * // Get first 10 Webmes_Permissions
     * const webmes_Permissions = await prisma.webmes_Permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webmes_PermissionWithIdOnly = await prisma.webmes_Permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends webmes_PermissionFindManyArgs>(args?: SelectSubset<T, webmes_PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$webmes_PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Webmes_Permission.
     * @param {webmes_PermissionCreateArgs} args - Arguments to create a Webmes_Permission.
     * @example
     * // Create one Webmes_Permission
     * const Webmes_Permission = await prisma.webmes_Permission.create({
     *   data: {
     *     // ... data to create a Webmes_Permission
     *   }
     * })
     * 
     */
    create<T extends webmes_PermissionCreateArgs>(args: SelectSubset<T, webmes_PermissionCreateArgs<ExtArgs>>): Prisma__webmes_PermissionClient<$Result.GetResult<Prisma.$webmes_PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Webmes_Permissions.
     * @param {webmes_PermissionCreateManyArgs} args - Arguments to create many Webmes_Permissions.
     * @example
     * // Create many Webmes_Permissions
     * const webmes_Permission = await prisma.webmes_Permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends webmes_PermissionCreateManyArgs>(args?: SelectSubset<T, webmes_PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Webmes_Permission.
     * @param {webmes_PermissionDeleteArgs} args - Arguments to delete one Webmes_Permission.
     * @example
     * // Delete one Webmes_Permission
     * const Webmes_Permission = await prisma.webmes_Permission.delete({
     *   where: {
     *     // ... filter to delete one Webmes_Permission
     *   }
     * })
     * 
     */
    delete<T extends webmes_PermissionDeleteArgs>(args: SelectSubset<T, webmes_PermissionDeleteArgs<ExtArgs>>): Prisma__webmes_PermissionClient<$Result.GetResult<Prisma.$webmes_PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Webmes_Permission.
     * @param {webmes_PermissionUpdateArgs} args - Arguments to update one Webmes_Permission.
     * @example
     * // Update one Webmes_Permission
     * const webmes_Permission = await prisma.webmes_Permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends webmes_PermissionUpdateArgs>(args: SelectSubset<T, webmes_PermissionUpdateArgs<ExtArgs>>): Prisma__webmes_PermissionClient<$Result.GetResult<Prisma.$webmes_PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Webmes_Permissions.
     * @param {webmes_PermissionDeleteManyArgs} args - Arguments to filter Webmes_Permissions to delete.
     * @example
     * // Delete a few Webmes_Permissions
     * const { count } = await prisma.webmes_Permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends webmes_PermissionDeleteManyArgs>(args?: SelectSubset<T, webmes_PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webmes_Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webmes_Permissions
     * const webmes_Permission = await prisma.webmes_Permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends webmes_PermissionUpdateManyArgs>(args: SelectSubset<T, webmes_PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Webmes_Permission.
     * @param {webmes_PermissionUpsertArgs} args - Arguments to update or create a Webmes_Permission.
     * @example
     * // Update or create a Webmes_Permission
     * const webmes_Permission = await prisma.webmes_Permission.upsert({
     *   create: {
     *     // ... data to create a Webmes_Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webmes_Permission we want to update
     *   }
     * })
     */
    upsert<T extends webmes_PermissionUpsertArgs>(args: SelectSubset<T, webmes_PermissionUpsertArgs<ExtArgs>>): Prisma__webmes_PermissionClient<$Result.GetResult<Prisma.$webmes_PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Webmes_Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_PermissionCountArgs} args - Arguments to filter Webmes_Permissions to count.
     * @example
     * // Count the number of Webmes_Permissions
     * const count = await prisma.webmes_Permission.count({
     *   where: {
     *     // ... the filter for the Webmes_Permissions we want to count
     *   }
     * })
    **/
    count<T extends webmes_PermissionCountArgs>(
      args?: Subset<T, webmes_PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Webmes_PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webmes_Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Webmes_PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Webmes_PermissionAggregateArgs>(args: Subset<T, Webmes_PermissionAggregateArgs>): Prisma.PrismaPromise<GetWebmes_PermissionAggregateType<T>>

    /**
     * Group by Webmes_Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends webmes_PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: webmes_PermissionGroupByArgs['orderBy'] }
        : { orderBy?: webmes_PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, webmes_PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebmes_PermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the webmes_Permission model
   */
  readonly fields: webmes_PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for webmes_Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__webmes_PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends webmes_Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, webmes_Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$webmes_RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the webmes_Permission model
   */ 
  interface webmes_PermissionFieldRefs {
    readonly id: FieldRef<"webmes_Permission", 'Int'>
    readonly name: FieldRef<"webmes_Permission", 'String'>
    readonly module: FieldRef<"webmes_Permission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * webmes_Permission findUnique
   */
  export type webmes_PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Permission
     */
    select?: webmes_PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_PermissionInclude<ExtArgs> | null
    /**
     * Filter, which webmes_Permission to fetch.
     */
    where: webmes_PermissionWhereUniqueInput
  }

  /**
   * webmes_Permission findUniqueOrThrow
   */
  export type webmes_PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Permission
     */
    select?: webmes_PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_PermissionInclude<ExtArgs> | null
    /**
     * Filter, which webmes_Permission to fetch.
     */
    where: webmes_PermissionWhereUniqueInput
  }

  /**
   * webmes_Permission findFirst
   */
  export type webmes_PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Permission
     */
    select?: webmes_PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_PermissionInclude<ExtArgs> | null
    /**
     * Filter, which webmes_Permission to fetch.
     */
    where?: webmes_PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_Permissions to fetch.
     */
    orderBy?: webmes_PermissionOrderByWithRelationInput | webmes_PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webmes_Permissions.
     */
    cursor?: webmes_PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webmes_Permissions.
     */
    distinct?: Webmes_PermissionScalarFieldEnum | Webmes_PermissionScalarFieldEnum[]
  }

  /**
   * webmes_Permission findFirstOrThrow
   */
  export type webmes_PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Permission
     */
    select?: webmes_PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_PermissionInclude<ExtArgs> | null
    /**
     * Filter, which webmes_Permission to fetch.
     */
    where?: webmes_PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_Permissions to fetch.
     */
    orderBy?: webmes_PermissionOrderByWithRelationInput | webmes_PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webmes_Permissions.
     */
    cursor?: webmes_PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webmes_Permissions.
     */
    distinct?: Webmes_PermissionScalarFieldEnum | Webmes_PermissionScalarFieldEnum[]
  }

  /**
   * webmes_Permission findMany
   */
  export type webmes_PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Permission
     */
    select?: webmes_PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_PermissionInclude<ExtArgs> | null
    /**
     * Filter, which webmes_Permissions to fetch.
     */
    where?: webmes_PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_Permissions to fetch.
     */
    orderBy?: webmes_PermissionOrderByWithRelationInput | webmes_PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing webmes_Permissions.
     */
    cursor?: webmes_PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_Permissions.
     */
    skip?: number
    distinct?: Webmes_PermissionScalarFieldEnum | Webmes_PermissionScalarFieldEnum[]
  }

  /**
   * webmes_Permission create
   */
  export type webmes_PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Permission
     */
    select?: webmes_PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a webmes_Permission.
     */
    data: XOR<webmes_PermissionCreateInput, webmes_PermissionUncheckedCreateInput>
  }

  /**
   * webmes_Permission createMany
   */
  export type webmes_PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many webmes_Permissions.
     */
    data: webmes_PermissionCreateManyInput | webmes_PermissionCreateManyInput[]
  }

  /**
   * webmes_Permission update
   */
  export type webmes_PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Permission
     */
    select?: webmes_PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a webmes_Permission.
     */
    data: XOR<webmes_PermissionUpdateInput, webmes_PermissionUncheckedUpdateInput>
    /**
     * Choose, which webmes_Permission to update.
     */
    where: webmes_PermissionWhereUniqueInput
  }

  /**
   * webmes_Permission updateMany
   */
  export type webmes_PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update webmes_Permissions.
     */
    data: XOR<webmes_PermissionUpdateManyMutationInput, webmes_PermissionUncheckedUpdateManyInput>
    /**
     * Filter which webmes_Permissions to update
     */
    where?: webmes_PermissionWhereInput
  }

  /**
   * webmes_Permission upsert
   */
  export type webmes_PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Permission
     */
    select?: webmes_PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the webmes_Permission to update in case it exists.
     */
    where: webmes_PermissionWhereUniqueInput
    /**
     * In case the webmes_Permission found by the `where` argument doesn't exist, create a new webmes_Permission with this data.
     */
    create: XOR<webmes_PermissionCreateInput, webmes_PermissionUncheckedCreateInput>
    /**
     * In case the webmes_Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<webmes_PermissionUpdateInput, webmes_PermissionUncheckedUpdateInput>
  }

  /**
   * webmes_Permission delete
   */
  export type webmes_PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Permission
     */
    select?: webmes_PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_PermissionInclude<ExtArgs> | null
    /**
     * Filter which webmes_Permission to delete.
     */
    where: webmes_PermissionWhereUniqueInput
  }

  /**
   * webmes_Permission deleteMany
   */
  export type webmes_PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webmes_Permissions to delete
     */
    where?: webmes_PermissionWhereInput
  }

  /**
   * webmes_Permission.roles
   */
  export type webmes_Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_RolePermission
     */
    select?: webmes_RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RolePermissionInclude<ExtArgs> | null
    where?: webmes_RolePermissionWhereInput
    orderBy?: webmes_RolePermissionOrderByWithRelationInput | webmes_RolePermissionOrderByWithRelationInput[]
    cursor?: webmes_RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Webmes_RolePermissionScalarFieldEnum | Webmes_RolePermissionScalarFieldEnum[]
  }

  /**
   * webmes_Permission without action
   */
  export type webmes_PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_Permission
     */
    select?: webmes_PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_PermissionInclude<ExtArgs> | null
  }


  /**
   * Model webmes_UserRole
   */

  export type AggregateWebmes_UserRole = {
    _count: Webmes_UserRoleCountAggregateOutputType | null
    _avg: Webmes_UserRoleAvgAggregateOutputType | null
    _sum: Webmes_UserRoleSumAggregateOutputType | null
    _min: Webmes_UserRoleMinAggregateOutputType | null
    _max: Webmes_UserRoleMaxAggregateOutputType | null
  }

  export type Webmes_UserRoleAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
  }

  export type Webmes_UserRoleSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
  }

  export type Webmes_UserRoleMinAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
  }

  export type Webmes_UserRoleMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
  }

  export type Webmes_UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    _all: number
  }


  export type Webmes_UserRoleAvgAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type Webmes_UserRoleSumAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type Webmes_UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type Webmes_UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type Webmes_UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    _all?: true
  }

  export type Webmes_UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webmes_UserRole to aggregate.
     */
    where?: webmes_UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_UserRoles to fetch.
     */
    orderBy?: webmes_UserRoleOrderByWithRelationInput | webmes_UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: webmes_UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned webmes_UserRoles
    **/
    _count?: true | Webmes_UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Webmes_UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Webmes_UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Webmes_UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Webmes_UserRoleMaxAggregateInputType
  }

  export type GetWebmes_UserRoleAggregateType<T extends Webmes_UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateWebmes_UserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebmes_UserRole[P]>
      : GetScalarType<T[P], AggregateWebmes_UserRole[P]>
  }




  export type webmes_UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: webmes_UserRoleWhereInput
    orderBy?: webmes_UserRoleOrderByWithAggregationInput | webmes_UserRoleOrderByWithAggregationInput[]
    by: Webmes_UserRoleScalarFieldEnum[] | Webmes_UserRoleScalarFieldEnum
    having?: webmes_UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Webmes_UserRoleCountAggregateInputType | true
    _avg?: Webmes_UserRoleAvgAggregateInputType
    _sum?: Webmes_UserRoleSumAggregateInputType
    _min?: Webmes_UserRoleMinAggregateInputType
    _max?: Webmes_UserRoleMaxAggregateInputType
  }

  export type Webmes_UserRoleGroupByOutputType = {
    id: number
    userId: number
    roleId: number
    _count: Webmes_UserRoleCountAggregateOutputType | null
    _avg: Webmes_UserRoleAvgAggregateOutputType | null
    _sum: Webmes_UserRoleSumAggregateOutputType | null
    _min: Webmes_UserRoleMinAggregateOutputType | null
    _max: Webmes_UserRoleMaxAggregateOutputType | null
  }

  type GetWebmes_UserRoleGroupByPayload<T extends webmes_UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Webmes_UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Webmes_UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Webmes_UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], Webmes_UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type webmes_UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    user?: boolean | webmes_UserDefaultArgs<ExtArgs>
    role?: boolean | webmes_RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webmes_UserRole"]>


  export type webmes_UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
  }

  export type webmes_UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | webmes_UserDefaultArgs<ExtArgs>
    role?: boolean | webmes_RoleDefaultArgs<ExtArgs>
  }

  export type $webmes_UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "webmes_UserRole"
    objects: {
      user: Prisma.$webmes_UserPayload<ExtArgs>
      role: Prisma.$webmes_RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      roleId: number
    }, ExtArgs["result"]["webmes_UserRole"]>
    composites: {}
  }

  type webmes_UserRoleGetPayload<S extends boolean | null | undefined | webmes_UserRoleDefaultArgs> = $Result.GetResult<Prisma.$webmes_UserRolePayload, S>

  type webmes_UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<webmes_UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Webmes_UserRoleCountAggregateInputType | true
    }

  export interface webmes_UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['webmes_UserRole'], meta: { name: 'webmes_UserRole' } }
    /**
     * Find zero or one Webmes_UserRole that matches the filter.
     * @param {webmes_UserRoleFindUniqueArgs} args - Arguments to find a Webmes_UserRole
     * @example
     * // Get one Webmes_UserRole
     * const webmes_UserRole = await prisma.webmes_UserRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends webmes_UserRoleFindUniqueArgs>(args: SelectSubset<T, webmes_UserRoleFindUniqueArgs<ExtArgs>>): Prisma__webmes_UserRoleClient<$Result.GetResult<Prisma.$webmes_UserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Webmes_UserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {webmes_UserRoleFindUniqueOrThrowArgs} args - Arguments to find a Webmes_UserRole
     * @example
     * // Get one Webmes_UserRole
     * const webmes_UserRole = await prisma.webmes_UserRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends webmes_UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, webmes_UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__webmes_UserRoleClient<$Result.GetResult<Prisma.$webmes_UserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Webmes_UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_UserRoleFindFirstArgs} args - Arguments to find a Webmes_UserRole
     * @example
     * // Get one Webmes_UserRole
     * const webmes_UserRole = await prisma.webmes_UserRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends webmes_UserRoleFindFirstArgs>(args?: SelectSubset<T, webmes_UserRoleFindFirstArgs<ExtArgs>>): Prisma__webmes_UserRoleClient<$Result.GetResult<Prisma.$webmes_UserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Webmes_UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_UserRoleFindFirstOrThrowArgs} args - Arguments to find a Webmes_UserRole
     * @example
     * // Get one Webmes_UserRole
     * const webmes_UserRole = await prisma.webmes_UserRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends webmes_UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, webmes_UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__webmes_UserRoleClient<$Result.GetResult<Prisma.$webmes_UserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Webmes_UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webmes_UserRoles
     * const webmes_UserRoles = await prisma.webmes_UserRole.findMany()
     * 
     * // Get first 10 Webmes_UserRoles
     * const webmes_UserRoles = await prisma.webmes_UserRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webmes_UserRoleWithIdOnly = await prisma.webmes_UserRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends webmes_UserRoleFindManyArgs>(args?: SelectSubset<T, webmes_UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$webmes_UserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Webmes_UserRole.
     * @param {webmes_UserRoleCreateArgs} args - Arguments to create a Webmes_UserRole.
     * @example
     * // Create one Webmes_UserRole
     * const Webmes_UserRole = await prisma.webmes_UserRole.create({
     *   data: {
     *     // ... data to create a Webmes_UserRole
     *   }
     * })
     * 
     */
    create<T extends webmes_UserRoleCreateArgs>(args: SelectSubset<T, webmes_UserRoleCreateArgs<ExtArgs>>): Prisma__webmes_UserRoleClient<$Result.GetResult<Prisma.$webmes_UserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Webmes_UserRoles.
     * @param {webmes_UserRoleCreateManyArgs} args - Arguments to create many Webmes_UserRoles.
     * @example
     * // Create many Webmes_UserRoles
     * const webmes_UserRole = await prisma.webmes_UserRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends webmes_UserRoleCreateManyArgs>(args?: SelectSubset<T, webmes_UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Webmes_UserRole.
     * @param {webmes_UserRoleDeleteArgs} args - Arguments to delete one Webmes_UserRole.
     * @example
     * // Delete one Webmes_UserRole
     * const Webmes_UserRole = await prisma.webmes_UserRole.delete({
     *   where: {
     *     // ... filter to delete one Webmes_UserRole
     *   }
     * })
     * 
     */
    delete<T extends webmes_UserRoleDeleteArgs>(args: SelectSubset<T, webmes_UserRoleDeleteArgs<ExtArgs>>): Prisma__webmes_UserRoleClient<$Result.GetResult<Prisma.$webmes_UserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Webmes_UserRole.
     * @param {webmes_UserRoleUpdateArgs} args - Arguments to update one Webmes_UserRole.
     * @example
     * // Update one Webmes_UserRole
     * const webmes_UserRole = await prisma.webmes_UserRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends webmes_UserRoleUpdateArgs>(args: SelectSubset<T, webmes_UserRoleUpdateArgs<ExtArgs>>): Prisma__webmes_UserRoleClient<$Result.GetResult<Prisma.$webmes_UserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Webmes_UserRoles.
     * @param {webmes_UserRoleDeleteManyArgs} args - Arguments to filter Webmes_UserRoles to delete.
     * @example
     * // Delete a few Webmes_UserRoles
     * const { count } = await prisma.webmes_UserRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends webmes_UserRoleDeleteManyArgs>(args?: SelectSubset<T, webmes_UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webmes_UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webmes_UserRoles
     * const webmes_UserRole = await prisma.webmes_UserRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends webmes_UserRoleUpdateManyArgs>(args: SelectSubset<T, webmes_UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Webmes_UserRole.
     * @param {webmes_UserRoleUpsertArgs} args - Arguments to update or create a Webmes_UserRole.
     * @example
     * // Update or create a Webmes_UserRole
     * const webmes_UserRole = await prisma.webmes_UserRole.upsert({
     *   create: {
     *     // ... data to create a Webmes_UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webmes_UserRole we want to update
     *   }
     * })
     */
    upsert<T extends webmes_UserRoleUpsertArgs>(args: SelectSubset<T, webmes_UserRoleUpsertArgs<ExtArgs>>): Prisma__webmes_UserRoleClient<$Result.GetResult<Prisma.$webmes_UserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Webmes_UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_UserRoleCountArgs} args - Arguments to filter Webmes_UserRoles to count.
     * @example
     * // Count the number of Webmes_UserRoles
     * const count = await prisma.webmes_UserRole.count({
     *   where: {
     *     // ... the filter for the Webmes_UserRoles we want to count
     *   }
     * })
    **/
    count<T extends webmes_UserRoleCountArgs>(
      args?: Subset<T, webmes_UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Webmes_UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webmes_UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Webmes_UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Webmes_UserRoleAggregateArgs>(args: Subset<T, Webmes_UserRoleAggregateArgs>): Prisma.PrismaPromise<GetWebmes_UserRoleAggregateType<T>>

    /**
     * Group by Webmes_UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends webmes_UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: webmes_UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: webmes_UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, webmes_UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebmes_UserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the webmes_UserRole model
   */
  readonly fields: webmes_UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for webmes_UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__webmes_UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends webmes_UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, webmes_UserDefaultArgs<ExtArgs>>): Prisma__webmes_UserClient<$Result.GetResult<Prisma.$webmes_UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends webmes_RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, webmes_RoleDefaultArgs<ExtArgs>>): Prisma__webmes_RoleClient<$Result.GetResult<Prisma.$webmes_RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the webmes_UserRole model
   */ 
  interface webmes_UserRoleFieldRefs {
    readonly id: FieldRef<"webmes_UserRole", 'Int'>
    readonly userId: FieldRef<"webmes_UserRole", 'Int'>
    readonly roleId: FieldRef<"webmes_UserRole", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * webmes_UserRole findUnique
   */
  export type webmes_UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_UserRole
     */
    select?: webmes_UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which webmes_UserRole to fetch.
     */
    where: webmes_UserRoleWhereUniqueInput
  }

  /**
   * webmes_UserRole findUniqueOrThrow
   */
  export type webmes_UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_UserRole
     */
    select?: webmes_UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which webmes_UserRole to fetch.
     */
    where: webmes_UserRoleWhereUniqueInput
  }

  /**
   * webmes_UserRole findFirst
   */
  export type webmes_UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_UserRole
     */
    select?: webmes_UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which webmes_UserRole to fetch.
     */
    where?: webmes_UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_UserRoles to fetch.
     */
    orderBy?: webmes_UserRoleOrderByWithRelationInput | webmes_UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webmes_UserRoles.
     */
    cursor?: webmes_UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webmes_UserRoles.
     */
    distinct?: Webmes_UserRoleScalarFieldEnum | Webmes_UserRoleScalarFieldEnum[]
  }

  /**
   * webmes_UserRole findFirstOrThrow
   */
  export type webmes_UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_UserRole
     */
    select?: webmes_UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which webmes_UserRole to fetch.
     */
    where?: webmes_UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_UserRoles to fetch.
     */
    orderBy?: webmes_UserRoleOrderByWithRelationInput | webmes_UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webmes_UserRoles.
     */
    cursor?: webmes_UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webmes_UserRoles.
     */
    distinct?: Webmes_UserRoleScalarFieldEnum | Webmes_UserRoleScalarFieldEnum[]
  }

  /**
   * webmes_UserRole findMany
   */
  export type webmes_UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_UserRole
     */
    select?: webmes_UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which webmes_UserRoles to fetch.
     */
    where?: webmes_UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_UserRoles to fetch.
     */
    orderBy?: webmes_UserRoleOrderByWithRelationInput | webmes_UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing webmes_UserRoles.
     */
    cursor?: webmes_UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_UserRoles.
     */
    skip?: number
    distinct?: Webmes_UserRoleScalarFieldEnum | Webmes_UserRoleScalarFieldEnum[]
  }

  /**
   * webmes_UserRole create
   */
  export type webmes_UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_UserRole
     */
    select?: webmes_UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a webmes_UserRole.
     */
    data: XOR<webmes_UserRoleCreateInput, webmes_UserRoleUncheckedCreateInput>
  }

  /**
   * webmes_UserRole createMany
   */
  export type webmes_UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many webmes_UserRoles.
     */
    data: webmes_UserRoleCreateManyInput | webmes_UserRoleCreateManyInput[]
  }

  /**
   * webmes_UserRole update
   */
  export type webmes_UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_UserRole
     */
    select?: webmes_UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a webmes_UserRole.
     */
    data: XOR<webmes_UserRoleUpdateInput, webmes_UserRoleUncheckedUpdateInput>
    /**
     * Choose, which webmes_UserRole to update.
     */
    where: webmes_UserRoleWhereUniqueInput
  }

  /**
   * webmes_UserRole updateMany
   */
  export type webmes_UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update webmes_UserRoles.
     */
    data: XOR<webmes_UserRoleUpdateManyMutationInput, webmes_UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which webmes_UserRoles to update
     */
    where?: webmes_UserRoleWhereInput
  }

  /**
   * webmes_UserRole upsert
   */
  export type webmes_UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_UserRole
     */
    select?: webmes_UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the webmes_UserRole to update in case it exists.
     */
    where: webmes_UserRoleWhereUniqueInput
    /**
     * In case the webmes_UserRole found by the `where` argument doesn't exist, create a new webmes_UserRole with this data.
     */
    create: XOR<webmes_UserRoleCreateInput, webmes_UserRoleUncheckedCreateInput>
    /**
     * In case the webmes_UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<webmes_UserRoleUpdateInput, webmes_UserRoleUncheckedUpdateInput>
  }

  /**
   * webmes_UserRole delete
   */
  export type webmes_UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_UserRole
     */
    select?: webmes_UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserRoleInclude<ExtArgs> | null
    /**
     * Filter which webmes_UserRole to delete.
     */
    where: webmes_UserRoleWhereUniqueInput
  }

  /**
   * webmes_UserRole deleteMany
   */
  export type webmes_UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webmes_UserRoles to delete
     */
    where?: webmes_UserRoleWhereInput
  }

  /**
   * webmes_UserRole without action
   */
  export type webmes_UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_UserRole
     */
    select?: webmes_UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model webmes_RolePermission
   */

  export type AggregateWebmes_RolePermission = {
    _count: Webmes_RolePermissionCountAggregateOutputType | null
    _avg: Webmes_RolePermissionAvgAggregateOutputType | null
    _sum: Webmes_RolePermissionSumAggregateOutputType | null
    _min: Webmes_RolePermissionMinAggregateOutputType | null
    _max: Webmes_RolePermissionMaxAggregateOutputType | null
  }

  export type Webmes_RolePermissionAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
  }

  export type Webmes_RolePermissionSumAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
  }

  export type Webmes_RolePermissionMinAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
  }

  export type Webmes_RolePermissionMaxAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
  }

  export type Webmes_RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    _all: number
  }


  export type Webmes_RolePermissionAvgAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type Webmes_RolePermissionSumAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type Webmes_RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type Webmes_RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type Webmes_RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    _all?: true
  }

  export type Webmes_RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webmes_RolePermission to aggregate.
     */
    where?: webmes_RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_RolePermissions to fetch.
     */
    orderBy?: webmes_RolePermissionOrderByWithRelationInput | webmes_RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: webmes_RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned webmes_RolePermissions
    **/
    _count?: true | Webmes_RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Webmes_RolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Webmes_RolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Webmes_RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Webmes_RolePermissionMaxAggregateInputType
  }

  export type GetWebmes_RolePermissionAggregateType<T extends Webmes_RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateWebmes_RolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebmes_RolePermission[P]>
      : GetScalarType<T[P], AggregateWebmes_RolePermission[P]>
  }




  export type webmes_RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: webmes_RolePermissionWhereInput
    orderBy?: webmes_RolePermissionOrderByWithAggregationInput | webmes_RolePermissionOrderByWithAggregationInput[]
    by: Webmes_RolePermissionScalarFieldEnum[] | Webmes_RolePermissionScalarFieldEnum
    having?: webmes_RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Webmes_RolePermissionCountAggregateInputType | true
    _avg?: Webmes_RolePermissionAvgAggregateInputType
    _sum?: Webmes_RolePermissionSumAggregateInputType
    _min?: Webmes_RolePermissionMinAggregateInputType
    _max?: Webmes_RolePermissionMaxAggregateInputType
  }

  export type Webmes_RolePermissionGroupByOutputType = {
    id: number
    roleId: number
    permissionId: number
    _count: Webmes_RolePermissionCountAggregateOutputType | null
    _avg: Webmes_RolePermissionAvgAggregateOutputType | null
    _sum: Webmes_RolePermissionSumAggregateOutputType | null
    _min: Webmes_RolePermissionMinAggregateOutputType | null
    _max: Webmes_RolePermissionMaxAggregateOutputType | null
  }

  type GetWebmes_RolePermissionGroupByPayload<T extends webmes_RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Webmes_RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Webmes_RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Webmes_RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], Webmes_RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type webmes_RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    role?: boolean | webmes_RoleDefaultArgs<ExtArgs>
    permission?: boolean | webmes_PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webmes_RolePermission"]>


  export type webmes_RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
  }

  export type webmes_RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | webmes_RoleDefaultArgs<ExtArgs>
    permission?: boolean | webmes_PermissionDefaultArgs<ExtArgs>
  }

  export type $webmes_RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "webmes_RolePermission"
    objects: {
      role: Prisma.$webmes_RolePayload<ExtArgs>
      permission: Prisma.$webmes_PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleId: number
      permissionId: number
    }, ExtArgs["result"]["webmes_RolePermission"]>
    composites: {}
  }

  type webmes_RolePermissionGetPayload<S extends boolean | null | undefined | webmes_RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$webmes_RolePermissionPayload, S>

  type webmes_RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<webmes_RolePermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Webmes_RolePermissionCountAggregateInputType | true
    }

  export interface webmes_RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['webmes_RolePermission'], meta: { name: 'webmes_RolePermission' } }
    /**
     * Find zero or one Webmes_RolePermission that matches the filter.
     * @param {webmes_RolePermissionFindUniqueArgs} args - Arguments to find a Webmes_RolePermission
     * @example
     * // Get one Webmes_RolePermission
     * const webmes_RolePermission = await prisma.webmes_RolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends webmes_RolePermissionFindUniqueArgs>(args: SelectSubset<T, webmes_RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__webmes_RolePermissionClient<$Result.GetResult<Prisma.$webmes_RolePermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Webmes_RolePermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {webmes_RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a Webmes_RolePermission
     * @example
     * // Get one Webmes_RolePermission
     * const webmes_RolePermission = await prisma.webmes_RolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends webmes_RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, webmes_RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__webmes_RolePermissionClient<$Result.GetResult<Prisma.$webmes_RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Webmes_RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_RolePermissionFindFirstArgs} args - Arguments to find a Webmes_RolePermission
     * @example
     * // Get one Webmes_RolePermission
     * const webmes_RolePermission = await prisma.webmes_RolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends webmes_RolePermissionFindFirstArgs>(args?: SelectSubset<T, webmes_RolePermissionFindFirstArgs<ExtArgs>>): Prisma__webmes_RolePermissionClient<$Result.GetResult<Prisma.$webmes_RolePermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Webmes_RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_RolePermissionFindFirstOrThrowArgs} args - Arguments to find a Webmes_RolePermission
     * @example
     * // Get one Webmes_RolePermission
     * const webmes_RolePermission = await prisma.webmes_RolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends webmes_RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, webmes_RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__webmes_RolePermissionClient<$Result.GetResult<Prisma.$webmes_RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Webmes_RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webmes_RolePermissions
     * const webmes_RolePermissions = await prisma.webmes_RolePermission.findMany()
     * 
     * // Get first 10 Webmes_RolePermissions
     * const webmes_RolePermissions = await prisma.webmes_RolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webmes_RolePermissionWithIdOnly = await prisma.webmes_RolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends webmes_RolePermissionFindManyArgs>(args?: SelectSubset<T, webmes_RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$webmes_RolePermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Webmes_RolePermission.
     * @param {webmes_RolePermissionCreateArgs} args - Arguments to create a Webmes_RolePermission.
     * @example
     * // Create one Webmes_RolePermission
     * const Webmes_RolePermission = await prisma.webmes_RolePermission.create({
     *   data: {
     *     // ... data to create a Webmes_RolePermission
     *   }
     * })
     * 
     */
    create<T extends webmes_RolePermissionCreateArgs>(args: SelectSubset<T, webmes_RolePermissionCreateArgs<ExtArgs>>): Prisma__webmes_RolePermissionClient<$Result.GetResult<Prisma.$webmes_RolePermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Webmes_RolePermissions.
     * @param {webmes_RolePermissionCreateManyArgs} args - Arguments to create many Webmes_RolePermissions.
     * @example
     * // Create many Webmes_RolePermissions
     * const webmes_RolePermission = await prisma.webmes_RolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends webmes_RolePermissionCreateManyArgs>(args?: SelectSubset<T, webmes_RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Webmes_RolePermission.
     * @param {webmes_RolePermissionDeleteArgs} args - Arguments to delete one Webmes_RolePermission.
     * @example
     * // Delete one Webmes_RolePermission
     * const Webmes_RolePermission = await prisma.webmes_RolePermission.delete({
     *   where: {
     *     // ... filter to delete one Webmes_RolePermission
     *   }
     * })
     * 
     */
    delete<T extends webmes_RolePermissionDeleteArgs>(args: SelectSubset<T, webmes_RolePermissionDeleteArgs<ExtArgs>>): Prisma__webmes_RolePermissionClient<$Result.GetResult<Prisma.$webmes_RolePermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Webmes_RolePermission.
     * @param {webmes_RolePermissionUpdateArgs} args - Arguments to update one Webmes_RolePermission.
     * @example
     * // Update one Webmes_RolePermission
     * const webmes_RolePermission = await prisma.webmes_RolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends webmes_RolePermissionUpdateArgs>(args: SelectSubset<T, webmes_RolePermissionUpdateArgs<ExtArgs>>): Prisma__webmes_RolePermissionClient<$Result.GetResult<Prisma.$webmes_RolePermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Webmes_RolePermissions.
     * @param {webmes_RolePermissionDeleteManyArgs} args - Arguments to filter Webmes_RolePermissions to delete.
     * @example
     * // Delete a few Webmes_RolePermissions
     * const { count } = await prisma.webmes_RolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends webmes_RolePermissionDeleteManyArgs>(args?: SelectSubset<T, webmes_RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webmes_RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webmes_RolePermissions
     * const webmes_RolePermission = await prisma.webmes_RolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends webmes_RolePermissionUpdateManyArgs>(args: SelectSubset<T, webmes_RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Webmes_RolePermission.
     * @param {webmes_RolePermissionUpsertArgs} args - Arguments to update or create a Webmes_RolePermission.
     * @example
     * // Update or create a Webmes_RolePermission
     * const webmes_RolePermission = await prisma.webmes_RolePermission.upsert({
     *   create: {
     *     // ... data to create a Webmes_RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webmes_RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends webmes_RolePermissionUpsertArgs>(args: SelectSubset<T, webmes_RolePermissionUpsertArgs<ExtArgs>>): Prisma__webmes_RolePermissionClient<$Result.GetResult<Prisma.$webmes_RolePermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Webmes_RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_RolePermissionCountArgs} args - Arguments to filter Webmes_RolePermissions to count.
     * @example
     * // Count the number of Webmes_RolePermissions
     * const count = await prisma.webmes_RolePermission.count({
     *   where: {
     *     // ... the filter for the Webmes_RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends webmes_RolePermissionCountArgs>(
      args?: Subset<T, webmes_RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Webmes_RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webmes_RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Webmes_RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Webmes_RolePermissionAggregateArgs>(args: Subset<T, Webmes_RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetWebmes_RolePermissionAggregateType<T>>

    /**
     * Group by Webmes_RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webmes_RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends webmes_RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: webmes_RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: webmes_RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, webmes_RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebmes_RolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the webmes_RolePermission model
   */
  readonly fields: webmes_RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for webmes_RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__webmes_RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends webmes_RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, webmes_RoleDefaultArgs<ExtArgs>>): Prisma__webmes_RoleClient<$Result.GetResult<Prisma.$webmes_RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    permission<T extends webmes_PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, webmes_PermissionDefaultArgs<ExtArgs>>): Prisma__webmes_PermissionClient<$Result.GetResult<Prisma.$webmes_PermissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the webmes_RolePermission model
   */ 
  interface webmes_RolePermissionFieldRefs {
    readonly id: FieldRef<"webmes_RolePermission", 'Int'>
    readonly roleId: FieldRef<"webmes_RolePermission", 'Int'>
    readonly permissionId: FieldRef<"webmes_RolePermission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * webmes_RolePermission findUnique
   */
  export type webmes_RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_RolePermission
     */
    select?: webmes_RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which webmes_RolePermission to fetch.
     */
    where: webmes_RolePermissionWhereUniqueInput
  }

  /**
   * webmes_RolePermission findUniqueOrThrow
   */
  export type webmes_RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_RolePermission
     */
    select?: webmes_RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which webmes_RolePermission to fetch.
     */
    where: webmes_RolePermissionWhereUniqueInput
  }

  /**
   * webmes_RolePermission findFirst
   */
  export type webmes_RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_RolePermission
     */
    select?: webmes_RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which webmes_RolePermission to fetch.
     */
    where?: webmes_RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_RolePermissions to fetch.
     */
    orderBy?: webmes_RolePermissionOrderByWithRelationInput | webmes_RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webmes_RolePermissions.
     */
    cursor?: webmes_RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webmes_RolePermissions.
     */
    distinct?: Webmes_RolePermissionScalarFieldEnum | Webmes_RolePermissionScalarFieldEnum[]
  }

  /**
   * webmes_RolePermission findFirstOrThrow
   */
  export type webmes_RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_RolePermission
     */
    select?: webmes_RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which webmes_RolePermission to fetch.
     */
    where?: webmes_RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_RolePermissions to fetch.
     */
    orderBy?: webmes_RolePermissionOrderByWithRelationInput | webmes_RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webmes_RolePermissions.
     */
    cursor?: webmes_RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webmes_RolePermissions.
     */
    distinct?: Webmes_RolePermissionScalarFieldEnum | Webmes_RolePermissionScalarFieldEnum[]
  }

  /**
   * webmes_RolePermission findMany
   */
  export type webmes_RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_RolePermission
     */
    select?: webmes_RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which webmes_RolePermissions to fetch.
     */
    where?: webmes_RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webmes_RolePermissions to fetch.
     */
    orderBy?: webmes_RolePermissionOrderByWithRelationInput | webmes_RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing webmes_RolePermissions.
     */
    cursor?: webmes_RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webmes_RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webmes_RolePermissions.
     */
    skip?: number
    distinct?: Webmes_RolePermissionScalarFieldEnum | Webmes_RolePermissionScalarFieldEnum[]
  }

  /**
   * webmes_RolePermission create
   */
  export type webmes_RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_RolePermission
     */
    select?: webmes_RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a webmes_RolePermission.
     */
    data: XOR<webmes_RolePermissionCreateInput, webmes_RolePermissionUncheckedCreateInput>
  }

  /**
   * webmes_RolePermission createMany
   */
  export type webmes_RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many webmes_RolePermissions.
     */
    data: webmes_RolePermissionCreateManyInput | webmes_RolePermissionCreateManyInput[]
  }

  /**
   * webmes_RolePermission update
   */
  export type webmes_RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_RolePermission
     */
    select?: webmes_RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a webmes_RolePermission.
     */
    data: XOR<webmes_RolePermissionUpdateInput, webmes_RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which webmes_RolePermission to update.
     */
    where: webmes_RolePermissionWhereUniqueInput
  }

  /**
   * webmes_RolePermission updateMany
   */
  export type webmes_RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update webmes_RolePermissions.
     */
    data: XOR<webmes_RolePermissionUpdateManyMutationInput, webmes_RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which webmes_RolePermissions to update
     */
    where?: webmes_RolePermissionWhereInput
  }

  /**
   * webmes_RolePermission upsert
   */
  export type webmes_RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_RolePermission
     */
    select?: webmes_RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the webmes_RolePermission to update in case it exists.
     */
    where: webmes_RolePermissionWhereUniqueInput
    /**
     * In case the webmes_RolePermission found by the `where` argument doesn't exist, create a new webmes_RolePermission with this data.
     */
    create: XOR<webmes_RolePermissionCreateInput, webmes_RolePermissionUncheckedCreateInput>
    /**
     * In case the webmes_RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<webmes_RolePermissionUpdateInput, webmes_RolePermissionUncheckedUpdateInput>
  }

  /**
   * webmes_RolePermission delete
   */
  export type webmes_RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_RolePermission
     */
    select?: webmes_RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which webmes_RolePermission to delete.
     */
    where: webmes_RolePermissionWhereUniqueInput
  }

  /**
   * webmes_RolePermission deleteMany
   */
  export type webmes_RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webmes_RolePermissions to delete
     */
    where?: webmes_RolePermissionWhereInput
  }

  /**
   * webmes_RolePermission without action
   */
  export type webmes_RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webmes_RolePermission
     */
    select?: webmes_RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: webmes_RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AssetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    serialNumber: 'serialNumber',
    assetTag: 'assetTag',
    type: 'type',
    brand: 'brand',
    model: 'model',
    spec: 'spec',
    purchaseDate: 'purchaseDate',
    warrantyUntil: 'warrantyUntil',
    location: 'location',
    status: 'status',
    ownerId: 'ownerId'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const AssetHistoryScalarFieldEnum: {
    id: 'id',
    assetId: 'assetId',
    oldOwnerId: 'oldOwnerId',
    newOwnerId: 'newOwnerId',
    changedAt: 'changedAt',
    reason: 'reason'
  };

  export type AssetHistoryScalarFieldEnum = (typeof AssetHistoryScalarFieldEnum)[keyof typeof AssetHistoryScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    tableName: 'tableName',
    recordId: 'recordId',
    oldValue: 'oldValue',
    newValue: 'newValue',
    userId: 'userId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    title: 'title',
    contractNo: 'contractNo',
    startDate: 'startDate',
    endDate: 'endDate',
    amount: 'amount',
    description: 'description',
    vendorId: 'vendorId'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const DepartmentsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DepartmentsScalarFieldEnum = (typeof DepartmentsScalarFieldEnum)[keyof typeof DepartmentsScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    filePath: 'filePath',
    version: 'version',
    permission: 'permission',
    createdAt: 'createdAt',
    createdById: 'createdById'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const Employee_rolesScalarFieldEnum: {
    employee_id: 'employee_id',
    role_id: 'role_id'
  };

  export type Employee_rolesScalarFieldEnum = (typeof Employee_rolesScalarFieldEnum)[keyof typeof Employee_rolesScalarFieldEnum]


  export const EmployeesScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    employee_code: 'employee_code',
    department_id: 'department_id',
    is_dept_head: 'is_dept_head',
    is_active: 'is_active'
  };

  export type EmployeesScalarFieldEnum = (typeof EmployeesScalarFieldEnum)[keyof typeof EmployeesScalarFieldEnum]


  export const InventoryCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type InventoryCategoryScalarFieldEnum = (typeof InventoryCategoryScalarFieldEnum)[keyof typeof InventoryCategoryScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    barcode: 'barcode',
    serialNumber: 'serialNumber',
    categoryId: 'categoryId',
    supplierId: 'supplierId',
    stock: 'stock',
    minStock: 'minStock',
    unit: 'unit',
    imagePath: 'imagePath'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const InventorySupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contact: 'contact',
    email: 'email',
    phone: 'phone'
  };

  export type InventorySupplierScalarFieldEnum = (typeof InventorySupplierScalarFieldEnum)[keyof typeof InventorySupplierScalarFieldEnum]


  export const InventoryTransactionScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    type: 'type',
    qty: 'qty',
    userId: 'userId',
    date: 'date',
    note: 'note',
    barcode: 'barcode'
  };

  export type InventoryTransactionScalarFieldEnum = (typeof InventoryTransactionScalarFieldEnum)[keyof typeof InventoryTransactionScalarFieldEnum]


  export const It_departmentsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type It_departmentsScalarFieldEnum = (typeof It_departmentsScalarFieldEnum)[keyof typeof It_departmentsScalarFieldEnum]


  export const It_employee_rolesScalarFieldEnum: {
    employee_id: 'employee_id',
    role_id: 'role_id'
  };

  export type It_employee_rolesScalarFieldEnum = (typeof It_employee_rolesScalarFieldEnum)[keyof typeof It_employee_rolesScalarFieldEnum]


  export const It_employeesScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    employee_code: 'employee_code',
    department_id: 'department_id',
    is_dept_head: 'is_dept_head',
    is_active: 'is_active'
  };

  export type It_employeesScalarFieldEnum = (typeof It_employeesScalarFieldEnum)[keyof typeof It_employeesScalarFieldEnum]


  export const It_rolesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type It_rolesScalarFieldEnum = (typeof It_rolesScalarFieldEnum)[keyof typeof It_rolesScalarFieldEnum]


  export const KnowledgeBaseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    category: 'category',
    tags: 'tags',
    isPublic: 'isPublic',
    createdById: 'createdById',
    linkedTicketId: 'linkedTicketId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KnowledgeBaseScalarFieldEnum = (typeof KnowledgeBaseScalarFieldEnum)[keyof typeof KnowledgeBaseScalarFieldEnum]


  export const LicenseScalarFieldEnum: {
    id: 'id',
    softwareName: 'softwareName',
    licenseKey: 'licenseKey',
    expireDate: 'expireDate',
    assetId: 'assetId'
  };

  export type LicenseScalarFieldEnum = (typeof LicenseScalarFieldEnum)[keyof typeof LicenseScalarFieldEnum]


  export const MonitorScalarFieldEnum: {
    id: 'id',
    targetName: 'targetName',
    ipAddress: 'ipAddress',
    status: 'status',
    lastCheck: 'lastCheck',
    assetId: 'assetId'
  };

  export type MonitorScalarFieldEnum = (typeof MonitorScalarFieldEnum)[keyof typeof MonitorScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    resolutionNote: 'resolutionNote',
    status: 'status',
    createdAt: 'createdAt',
    assetId: 'assetId',
    requestedById: 'requestedById',
    assignedToId: 'assignedToId'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TicketAttachmentScalarFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    filePath: 'filePath',
    uploadedAt: 'uploadedAt',
    ticketId: 'ticketId',
    uploadedById: 'uploadedById'
  };

  export type TicketAttachmentScalarFieldEnum = (typeof TicketAttachmentScalarFieldEnum)[keyof typeof TicketAttachmentScalarFieldEnum]


  export const TicketCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    ticketId: 'ticketId',
    createdById: 'createdById'
  };

  export type TicketCommentScalarFieldEnum = (typeof TicketCommentScalarFieldEnum)[keyof typeof TicketCommentScalarFieldEnum]


  export const TicketHistoryScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    oldStatus: 'oldStatus',
    newStatus: 'newStatus',
    changedById: 'changedById',
    changedAt: 'changedAt',
    note: 'note'
  };

  export type TicketHistoryScalarFieldEnum = (typeof TicketHistoryScalarFieldEnum)[keyof typeof TicketHistoryScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    empId: 'empId',
    email: 'email',
    password: 'password',
    role: 'role',
    department: 'department'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contact: 'contact',
    email: 'email',
    phone: 'phone',
    website: 'website',
    address: 'address'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const Webmes_UserScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    fullName: 'fullName',
    department: 'department',
    email: 'email',
    password: 'password',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Webmes_UserScalarFieldEnum = (typeof Webmes_UserScalarFieldEnum)[keyof typeof Webmes_UserScalarFieldEnum]


  export const Webmes_RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type Webmes_RoleScalarFieldEnum = (typeof Webmes_RoleScalarFieldEnum)[keyof typeof Webmes_RoleScalarFieldEnum]


  export const Webmes_PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    module: 'module'
  };

  export type Webmes_PermissionScalarFieldEnum = (typeof Webmes_PermissionScalarFieldEnum)[keyof typeof Webmes_PermissionScalarFieldEnum]


  export const Webmes_UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId'
  };

  export type Webmes_UserRoleScalarFieldEnum = (typeof Webmes_UserRoleScalarFieldEnum)[keyof typeof Webmes_UserRoleScalarFieldEnum]


  export const Webmes_RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId'
  };

  export type Webmes_RolePermissionScalarFieldEnum = (typeof Webmes_RolePermissionScalarFieldEnum)[keyof typeof Webmes_RolePermissionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: IntFilter<"Asset"> | number
    name?: StringFilter<"Asset"> | string
    serialNumber?: StringFilter<"Asset"> | string
    assetTag?: StringNullableFilter<"Asset"> | string | null
    type?: StringFilter<"Asset"> | string
    brand?: StringNullableFilter<"Asset"> | string | null
    model?: StringNullableFilter<"Asset"> | string | null
    spec?: StringNullableFilter<"Asset"> | string | null
    purchaseDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
    warrantyUntil?: DateTimeNullableFilter<"Asset"> | Date | string | null
    location?: StringNullableFilter<"Asset"> | string | null
    status?: StringFilter<"Asset"> | string
    ownerId?: IntNullableFilter<"Asset"> | number | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    AssetHistory?: AssetHistoryListRelationFilter
    License?: LicenseListRelationFilter
    Monitor?: XOR<MonitorNullableRelationFilter, MonitorWhereInput> | null
    Ticket?: TicketListRelationFilter
    Contract?: ContractListRelationFilter
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrder
    assetTag?: SortOrderInput | SortOrder
    type?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    spec?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    warrantyUntil?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    AssetHistory?: AssetHistoryOrderByRelationAggregateInput
    License?: LicenseOrderByRelationAggregateInput
    Monitor?: MonitorOrderByWithRelationInput
    Ticket?: TicketOrderByRelationAggregateInput
    Contract?: ContractOrderByRelationAggregateInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serialNumber?: string
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    name?: StringFilter<"Asset"> | string
    assetTag?: StringNullableFilter<"Asset"> | string | null
    type?: StringFilter<"Asset"> | string
    brand?: StringNullableFilter<"Asset"> | string | null
    model?: StringNullableFilter<"Asset"> | string | null
    spec?: StringNullableFilter<"Asset"> | string | null
    purchaseDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
    warrantyUntil?: DateTimeNullableFilter<"Asset"> | Date | string | null
    location?: StringNullableFilter<"Asset"> | string | null
    status?: StringFilter<"Asset"> | string
    ownerId?: IntNullableFilter<"Asset"> | number | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    AssetHistory?: AssetHistoryListRelationFilter
    License?: LicenseListRelationFilter
    Monitor?: XOR<MonitorNullableRelationFilter, MonitorWhereInput> | null
    Ticket?: TicketListRelationFilter
    Contract?: ContractListRelationFilter
  }, "id" | "serialNumber">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrder
    assetTag?: SortOrderInput | SortOrder
    type?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    spec?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    warrantyUntil?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    _count?: AssetCountOrderByAggregateInput
    _avg?: AssetAvgOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
    _sum?: AssetSumOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Asset"> | number
    name?: StringWithAggregatesFilter<"Asset"> | string
    serialNumber?: StringWithAggregatesFilter<"Asset"> | string
    assetTag?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    type?: StringWithAggregatesFilter<"Asset"> | string
    brand?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    model?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    spec?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    purchaseDate?: DateTimeNullableWithAggregatesFilter<"Asset"> | Date | string | null
    warrantyUntil?: DateTimeNullableWithAggregatesFilter<"Asset"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    status?: StringWithAggregatesFilter<"Asset"> | string
    ownerId?: IntNullableWithAggregatesFilter<"Asset"> | number | null
  }

  export type AssetHistoryWhereInput = {
    AND?: AssetHistoryWhereInput | AssetHistoryWhereInput[]
    OR?: AssetHistoryWhereInput[]
    NOT?: AssetHistoryWhereInput | AssetHistoryWhereInput[]
    id?: IntFilter<"AssetHistory"> | number
    assetId?: IntFilter<"AssetHistory"> | number
    oldOwnerId?: IntNullableFilter<"AssetHistory"> | number | null
    newOwnerId?: IntNullableFilter<"AssetHistory"> | number | null
    changedAt?: DateTimeFilter<"AssetHistory"> | Date | string
    reason?: StringNullableFilter<"AssetHistory"> | string | null
    Asset?: XOR<AssetRelationFilter, AssetWhereInput>
    User_AssetHistory_newOwnerIdToUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    User_AssetHistory_oldOwnerIdToUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AssetHistoryOrderByWithRelationInput = {
    id?: SortOrder
    assetId?: SortOrder
    oldOwnerId?: SortOrderInput | SortOrder
    newOwnerId?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    reason?: SortOrderInput | SortOrder
    Asset?: AssetOrderByWithRelationInput
    User_AssetHistory_newOwnerIdToUser?: UserOrderByWithRelationInput
    User_AssetHistory_oldOwnerIdToUser?: UserOrderByWithRelationInput
  }

  export type AssetHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssetHistoryWhereInput | AssetHistoryWhereInput[]
    OR?: AssetHistoryWhereInput[]
    NOT?: AssetHistoryWhereInput | AssetHistoryWhereInput[]
    assetId?: IntFilter<"AssetHistory"> | number
    oldOwnerId?: IntNullableFilter<"AssetHistory"> | number | null
    newOwnerId?: IntNullableFilter<"AssetHistory"> | number | null
    changedAt?: DateTimeFilter<"AssetHistory"> | Date | string
    reason?: StringNullableFilter<"AssetHistory"> | string | null
    Asset?: XOR<AssetRelationFilter, AssetWhereInput>
    User_AssetHistory_newOwnerIdToUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    User_AssetHistory_oldOwnerIdToUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AssetHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    assetId?: SortOrder
    oldOwnerId?: SortOrderInput | SortOrder
    newOwnerId?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    reason?: SortOrderInput | SortOrder
    _count?: AssetHistoryCountOrderByAggregateInput
    _avg?: AssetHistoryAvgOrderByAggregateInput
    _max?: AssetHistoryMaxOrderByAggregateInput
    _min?: AssetHistoryMinOrderByAggregateInput
    _sum?: AssetHistorySumOrderByAggregateInput
  }

  export type AssetHistoryScalarWhereWithAggregatesInput = {
    AND?: AssetHistoryScalarWhereWithAggregatesInput | AssetHistoryScalarWhereWithAggregatesInput[]
    OR?: AssetHistoryScalarWhereWithAggregatesInput[]
    NOT?: AssetHistoryScalarWhereWithAggregatesInput | AssetHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AssetHistory"> | number
    assetId?: IntWithAggregatesFilter<"AssetHistory"> | number
    oldOwnerId?: IntNullableWithAggregatesFilter<"AssetHistory"> | number | null
    newOwnerId?: IntNullableWithAggregatesFilter<"AssetHistory"> | number | null
    changedAt?: DateTimeWithAggregatesFilter<"AssetHistory"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"AssetHistory"> | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: IntNullableFilter<"AuditLog"> | number | null
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    userId?: IntFilter<"AuditLog"> | number
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    userId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: StringFilter<"AuditLog"> | string
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: IntNullableFilter<"AuditLog"> | number | null
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    userId?: IntFilter<"AuditLog"> | number
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    userId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    tableName?: StringWithAggregatesFilter<"AuditLog"> | string
    recordId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    oldValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userId?: IntWithAggregatesFilter<"AuditLog"> | number
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: IntFilter<"Contract"> | number
    title?: StringFilter<"Contract"> | string
    contractNo?: StringFilter<"Contract"> | string
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeFilter<"Contract"> | Date | string
    amount?: FloatNullableFilter<"Contract"> | number | null
    description?: StringNullableFilter<"Contract"> | string | null
    vendorId?: IntFilter<"Contract"> | number
    Vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    Asset?: AssetListRelationFilter
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    contractNo?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    amount?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    vendorId?: SortOrder
    Vendor?: VendorOrderByWithRelationInput
    Asset?: AssetOrderByRelationAggregateInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    contractNo?: string
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    title?: StringFilter<"Contract"> | string
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeFilter<"Contract"> | Date | string
    amount?: FloatNullableFilter<"Contract"> | number | null
    description?: StringNullableFilter<"Contract"> | string | null
    vendorId?: IntFilter<"Contract"> | number
    Vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    Asset?: AssetListRelationFilter
  }, "id" | "contractNo">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    contractNo?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    amount?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    vendorId?: SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contract"> | number
    title?: StringWithAggregatesFilter<"Contract"> | string
    contractNo?: StringWithAggregatesFilter<"Contract"> | string
    startDate?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    amount?: FloatNullableWithAggregatesFilter<"Contract"> | number | null
    description?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    vendorId?: IntWithAggregatesFilter<"Contract"> | number
  }

  export type departmentsWhereInput = {
    AND?: departmentsWhereInput | departmentsWhereInput[]
    OR?: departmentsWhereInput[]
    NOT?: departmentsWhereInput | departmentsWhereInput[]
    id?: IntFilter<"departments"> | number
    name?: StringFilter<"departments"> | string
    employees?: EmployeesListRelationFilter
  }

  export type departmentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    employees?: employeesOrderByRelationAggregateInput
  }

  export type departmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: departmentsWhereInput | departmentsWhereInput[]
    OR?: departmentsWhereInput[]
    NOT?: departmentsWhereInput | departmentsWhereInput[]
    employees?: EmployeesListRelationFilter
  }, "id" | "name">

  export type departmentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: departmentsCountOrderByAggregateInput
    _avg?: departmentsAvgOrderByAggregateInput
    _max?: departmentsMaxOrderByAggregateInput
    _min?: departmentsMinOrderByAggregateInput
    _sum?: departmentsSumOrderByAggregateInput
  }

  export type departmentsScalarWhereWithAggregatesInput = {
    AND?: departmentsScalarWhereWithAggregatesInput | departmentsScalarWhereWithAggregatesInput[]
    OR?: departmentsScalarWhereWithAggregatesInput[]
    NOT?: departmentsScalarWhereWithAggregatesInput | departmentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"departments"> | number
    name?: StringWithAggregatesFilter<"departments"> | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: IntFilter<"Document"> | number
    name?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    version?: StringFilter<"Document"> | string
    permission?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    createdById?: IntFilter<"Document"> | number
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    filePath?: SortOrder
    version?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    name?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    version?: StringFilter<"Document"> | string
    permission?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    createdById?: IntFilter<"Document"> | number
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    filePath?: SortOrder
    version?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Document"> | number
    name?: StringWithAggregatesFilter<"Document"> | string
    filePath?: StringWithAggregatesFilter<"Document"> | string
    version?: StringWithAggregatesFilter<"Document"> | string
    permission?: StringWithAggregatesFilter<"Document"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    createdById?: IntWithAggregatesFilter<"Document"> | number
  }

  export type employee_rolesWhereInput = {
    AND?: employee_rolesWhereInput | employee_rolesWhereInput[]
    OR?: employee_rolesWhereInput[]
    NOT?: employee_rolesWhereInput | employee_rolesWhereInput[]
    employee_id?: IntFilter<"employee_roles"> | number
    role_id?: IntFilter<"employee_roles"> | number
    employees?: XOR<EmployeesRelationFilter, employeesWhereInput>
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
  }

  export type employee_rolesOrderByWithRelationInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
    employees?: employeesOrderByWithRelationInput
    roles?: rolesOrderByWithRelationInput
  }

  export type employee_rolesWhereUniqueInput = Prisma.AtLeast<{
    employee_id_role_id?: employee_rolesEmployee_idRole_idCompoundUniqueInput
    AND?: employee_rolesWhereInput | employee_rolesWhereInput[]
    OR?: employee_rolesWhereInput[]
    NOT?: employee_rolesWhereInput | employee_rolesWhereInput[]
    employee_id?: IntFilter<"employee_roles"> | number
    role_id?: IntFilter<"employee_roles"> | number
    employees?: XOR<EmployeesRelationFilter, employeesWhereInput>
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
  }, "employee_id_role_id">

  export type employee_rolesOrderByWithAggregationInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
    _count?: employee_rolesCountOrderByAggregateInput
    _avg?: employee_rolesAvgOrderByAggregateInput
    _max?: employee_rolesMaxOrderByAggregateInput
    _min?: employee_rolesMinOrderByAggregateInput
    _sum?: employee_rolesSumOrderByAggregateInput
  }

  export type employee_rolesScalarWhereWithAggregatesInput = {
    AND?: employee_rolesScalarWhereWithAggregatesInput | employee_rolesScalarWhereWithAggregatesInput[]
    OR?: employee_rolesScalarWhereWithAggregatesInput[]
    NOT?: employee_rolesScalarWhereWithAggregatesInput | employee_rolesScalarWhereWithAggregatesInput[]
    employee_id?: IntWithAggregatesFilter<"employee_roles"> | number
    role_id?: IntWithAggregatesFilter<"employee_roles"> | number
  }

  export type employeesWhereInput = {
    AND?: employeesWhereInput | employeesWhereInput[]
    OR?: employeesWhereInput[]
    NOT?: employeesWhereInput | employeesWhereInput[]
    id?: IntFilter<"employees"> | number
    first_name?: StringFilter<"employees"> | string
    last_name?: StringFilter<"employees"> | string
    employee_code?: StringFilter<"employees"> | string
    department_id?: IntFilter<"employees"> | number
    is_dept_head?: BoolFilter<"employees"> | boolean
    is_active?: BoolFilter<"employees"> | boolean
    employee_roles?: Employee_rolesListRelationFilter
    departments?: XOR<DepartmentsRelationFilter, departmentsWhereInput>
  }

  export type employeesOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    employee_code?: SortOrder
    department_id?: SortOrder
    is_dept_head?: SortOrder
    is_active?: SortOrder
    employee_roles?: employee_rolesOrderByRelationAggregateInput
    departments?: departmentsOrderByWithRelationInput
  }

  export type employeesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employee_code?: string
    AND?: employeesWhereInput | employeesWhereInput[]
    OR?: employeesWhereInput[]
    NOT?: employeesWhereInput | employeesWhereInput[]
    first_name?: StringFilter<"employees"> | string
    last_name?: StringFilter<"employees"> | string
    department_id?: IntFilter<"employees"> | number
    is_dept_head?: BoolFilter<"employees"> | boolean
    is_active?: BoolFilter<"employees"> | boolean
    employee_roles?: Employee_rolesListRelationFilter
    departments?: XOR<DepartmentsRelationFilter, departmentsWhereInput>
  }, "id" | "employee_code">

  export type employeesOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    employee_code?: SortOrder
    department_id?: SortOrder
    is_dept_head?: SortOrder
    is_active?: SortOrder
    _count?: employeesCountOrderByAggregateInput
    _avg?: employeesAvgOrderByAggregateInput
    _max?: employeesMaxOrderByAggregateInput
    _min?: employeesMinOrderByAggregateInput
    _sum?: employeesSumOrderByAggregateInput
  }

  export type employeesScalarWhereWithAggregatesInput = {
    AND?: employeesScalarWhereWithAggregatesInput | employeesScalarWhereWithAggregatesInput[]
    OR?: employeesScalarWhereWithAggregatesInput[]
    NOT?: employeesScalarWhereWithAggregatesInput | employeesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"employees"> | number
    first_name?: StringWithAggregatesFilter<"employees"> | string
    last_name?: StringWithAggregatesFilter<"employees"> | string
    employee_code?: StringWithAggregatesFilter<"employees"> | string
    department_id?: IntWithAggregatesFilter<"employees"> | number
    is_dept_head?: BoolWithAggregatesFilter<"employees"> | boolean
    is_active?: BoolWithAggregatesFilter<"employees"> | boolean
  }

  export type InventoryCategoryWhereInput = {
    AND?: InventoryCategoryWhereInput | InventoryCategoryWhereInput[]
    OR?: InventoryCategoryWhereInput[]
    NOT?: InventoryCategoryWhereInput | InventoryCategoryWhereInput[]
    id?: IntFilter<"InventoryCategory"> | number
    name?: StringFilter<"InventoryCategory"> | string
    InventoryItem?: InventoryItemListRelationFilter
  }

  export type InventoryCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    InventoryItem?: InventoryItemOrderByRelationAggregateInput
  }

  export type InventoryCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: InventoryCategoryWhereInput | InventoryCategoryWhereInput[]
    OR?: InventoryCategoryWhereInput[]
    NOT?: InventoryCategoryWhereInput | InventoryCategoryWhereInput[]
    InventoryItem?: InventoryItemListRelationFilter
  }, "id" | "name">

  export type InventoryCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: InventoryCategoryCountOrderByAggregateInput
    _avg?: InventoryCategoryAvgOrderByAggregateInput
    _max?: InventoryCategoryMaxOrderByAggregateInput
    _min?: InventoryCategoryMinOrderByAggregateInput
    _sum?: InventoryCategorySumOrderByAggregateInput
  }

  export type InventoryCategoryScalarWhereWithAggregatesInput = {
    AND?: InventoryCategoryScalarWhereWithAggregatesInput | InventoryCategoryScalarWhereWithAggregatesInput[]
    OR?: InventoryCategoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryCategoryScalarWhereWithAggregatesInput | InventoryCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InventoryCategory"> | number
    name?: StringWithAggregatesFilter<"InventoryCategory"> | string
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: IntFilter<"InventoryItem"> | number
    name?: StringFilter<"InventoryItem"> | string
    description?: StringNullableFilter<"InventoryItem"> | string | null
    barcode?: StringNullableFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableFilter<"InventoryItem"> | string | null
    categoryId?: IntFilter<"InventoryItem"> | number
    supplierId?: IntNullableFilter<"InventoryItem"> | number | null
    stock?: IntFilter<"InventoryItem"> | number
    minStock?: IntFilter<"InventoryItem"> | number
    unit?: StringNullableFilter<"InventoryItem"> | string | null
    imagePath?: StringNullableFilter<"InventoryItem"> | string | null
    InventoryCategory?: XOR<InventoryCategoryRelationFilter, InventoryCategoryWhereInput>
    InventorySupplier?: XOR<InventorySupplierNullableRelationFilter, InventorySupplierWhereInput> | null
    InventoryTransaction?: InventoryTransactionListRelationFilter
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    unit?: SortOrderInput | SortOrder
    imagePath?: SortOrderInput | SortOrder
    InventoryCategory?: InventoryCategoryOrderByWithRelationInput
    InventorySupplier?: InventorySupplierOrderByWithRelationInput
    InventoryTransaction?: InventoryTransactionOrderByRelationAggregateInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    barcode?: string
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    name?: StringFilter<"InventoryItem"> | string
    description?: StringNullableFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableFilter<"InventoryItem"> | string | null
    categoryId?: IntFilter<"InventoryItem"> | number
    supplierId?: IntNullableFilter<"InventoryItem"> | number | null
    stock?: IntFilter<"InventoryItem"> | number
    minStock?: IntFilter<"InventoryItem"> | number
    unit?: StringNullableFilter<"InventoryItem"> | string | null
    imagePath?: StringNullableFilter<"InventoryItem"> | string | null
    InventoryCategory?: XOR<InventoryCategoryRelationFilter, InventoryCategoryWhereInput>
    InventorySupplier?: XOR<InventorySupplierNullableRelationFilter, InventorySupplierWhereInput> | null
    InventoryTransaction?: InventoryTransactionListRelationFilter
  }, "id" | "barcode">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    unit?: SortOrderInput | SortOrder
    imagePath?: SortOrderInput | SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InventoryItem"> | number
    name?: StringWithAggregatesFilter<"InventoryItem"> | string
    description?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    barcode?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    categoryId?: IntWithAggregatesFilter<"InventoryItem"> | number
    supplierId?: IntNullableWithAggregatesFilter<"InventoryItem"> | number | null
    stock?: IntWithAggregatesFilter<"InventoryItem"> | number
    minStock?: IntWithAggregatesFilter<"InventoryItem"> | number
    unit?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    imagePath?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
  }

  export type InventorySupplierWhereInput = {
    AND?: InventorySupplierWhereInput | InventorySupplierWhereInput[]
    OR?: InventorySupplierWhereInput[]
    NOT?: InventorySupplierWhereInput | InventorySupplierWhereInput[]
    id?: IntFilter<"InventorySupplier"> | number
    name?: StringFilter<"InventorySupplier"> | string
    contact?: StringNullableFilter<"InventorySupplier"> | string | null
    email?: StringNullableFilter<"InventorySupplier"> | string | null
    phone?: StringNullableFilter<"InventorySupplier"> | string | null
    InventoryItem?: InventoryItemListRelationFilter
  }

  export type InventorySupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    InventoryItem?: InventoryItemOrderByRelationAggregateInput
  }

  export type InventorySupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InventorySupplierWhereInput | InventorySupplierWhereInput[]
    OR?: InventorySupplierWhereInput[]
    NOT?: InventorySupplierWhereInput | InventorySupplierWhereInput[]
    name?: StringFilter<"InventorySupplier"> | string
    contact?: StringNullableFilter<"InventorySupplier"> | string | null
    email?: StringNullableFilter<"InventorySupplier"> | string | null
    phone?: StringNullableFilter<"InventorySupplier"> | string | null
    InventoryItem?: InventoryItemListRelationFilter
  }, "id">

  export type InventorySupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: InventorySupplierCountOrderByAggregateInput
    _avg?: InventorySupplierAvgOrderByAggregateInput
    _max?: InventorySupplierMaxOrderByAggregateInput
    _min?: InventorySupplierMinOrderByAggregateInput
    _sum?: InventorySupplierSumOrderByAggregateInput
  }

  export type InventorySupplierScalarWhereWithAggregatesInput = {
    AND?: InventorySupplierScalarWhereWithAggregatesInput | InventorySupplierScalarWhereWithAggregatesInput[]
    OR?: InventorySupplierScalarWhereWithAggregatesInput[]
    NOT?: InventorySupplierScalarWhereWithAggregatesInput | InventorySupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InventorySupplier"> | number
    name?: StringWithAggregatesFilter<"InventorySupplier"> | string
    contact?: StringNullableWithAggregatesFilter<"InventorySupplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"InventorySupplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"InventorySupplier"> | string | null
  }

  export type InventoryTransactionWhereInput = {
    AND?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    OR?: InventoryTransactionWhereInput[]
    NOT?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    id?: IntFilter<"InventoryTransaction"> | number
    itemId?: IntFilter<"InventoryTransaction"> | number
    type?: StringFilter<"InventoryTransaction"> | string
    qty?: IntFilter<"InventoryTransaction"> | number
    userId?: IntNullableFilter<"InventoryTransaction"> | number | null
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
    note?: StringNullableFilter<"InventoryTransaction"> | string | null
    barcode?: StringNullableFilter<"InventoryTransaction"> | string | null
    InventoryItem?: XOR<InventoryItemRelationFilter, InventoryItemWhereInput>
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type InventoryTransactionOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    qty?: SortOrder
    userId?: SortOrderInput | SortOrder
    date?: SortOrder
    note?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    InventoryItem?: InventoryItemOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type InventoryTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    OR?: InventoryTransactionWhereInput[]
    NOT?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    itemId?: IntFilter<"InventoryTransaction"> | number
    type?: StringFilter<"InventoryTransaction"> | string
    qty?: IntFilter<"InventoryTransaction"> | number
    userId?: IntNullableFilter<"InventoryTransaction"> | number | null
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
    note?: StringNullableFilter<"InventoryTransaction"> | string | null
    barcode?: StringNullableFilter<"InventoryTransaction"> | string | null
    InventoryItem?: XOR<InventoryItemRelationFilter, InventoryItemWhereInput>
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type InventoryTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    qty?: SortOrder
    userId?: SortOrderInput | SortOrder
    date?: SortOrder
    note?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    _count?: InventoryTransactionCountOrderByAggregateInput
    _avg?: InventoryTransactionAvgOrderByAggregateInput
    _max?: InventoryTransactionMaxOrderByAggregateInput
    _min?: InventoryTransactionMinOrderByAggregateInput
    _sum?: InventoryTransactionSumOrderByAggregateInput
  }

  export type InventoryTransactionScalarWhereWithAggregatesInput = {
    AND?: InventoryTransactionScalarWhereWithAggregatesInput | InventoryTransactionScalarWhereWithAggregatesInput[]
    OR?: InventoryTransactionScalarWhereWithAggregatesInput[]
    NOT?: InventoryTransactionScalarWhereWithAggregatesInput | InventoryTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InventoryTransaction"> | number
    itemId?: IntWithAggregatesFilter<"InventoryTransaction"> | number
    type?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    qty?: IntWithAggregatesFilter<"InventoryTransaction"> | number
    userId?: IntNullableWithAggregatesFilter<"InventoryTransaction"> | number | null
    date?: DateTimeWithAggregatesFilter<"InventoryTransaction"> | Date | string
    note?: StringNullableWithAggregatesFilter<"InventoryTransaction"> | string | null
    barcode?: StringNullableWithAggregatesFilter<"InventoryTransaction"> | string | null
  }

  export type it_departmentsWhereInput = {
    AND?: it_departmentsWhereInput | it_departmentsWhereInput[]
    OR?: it_departmentsWhereInput[]
    NOT?: it_departmentsWhereInput | it_departmentsWhereInput[]
    id?: IntFilter<"it_departments"> | number
    name?: StringFilter<"it_departments"> | string
    it_employees?: It_employeesListRelationFilter
  }

  export type it_departmentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    it_employees?: it_employeesOrderByRelationAggregateInput
  }

  export type it_departmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: it_departmentsWhereInput | it_departmentsWhereInput[]
    OR?: it_departmentsWhereInput[]
    NOT?: it_departmentsWhereInput | it_departmentsWhereInput[]
    it_employees?: It_employeesListRelationFilter
  }, "id" | "name">

  export type it_departmentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: it_departmentsCountOrderByAggregateInput
    _avg?: it_departmentsAvgOrderByAggregateInput
    _max?: it_departmentsMaxOrderByAggregateInput
    _min?: it_departmentsMinOrderByAggregateInput
    _sum?: it_departmentsSumOrderByAggregateInput
  }

  export type it_departmentsScalarWhereWithAggregatesInput = {
    AND?: it_departmentsScalarWhereWithAggregatesInput | it_departmentsScalarWhereWithAggregatesInput[]
    OR?: it_departmentsScalarWhereWithAggregatesInput[]
    NOT?: it_departmentsScalarWhereWithAggregatesInput | it_departmentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"it_departments"> | number
    name?: StringWithAggregatesFilter<"it_departments"> | string
  }

  export type it_employee_rolesWhereInput = {
    AND?: it_employee_rolesWhereInput | it_employee_rolesWhereInput[]
    OR?: it_employee_rolesWhereInput[]
    NOT?: it_employee_rolesWhereInput | it_employee_rolesWhereInput[]
    employee_id?: IntFilter<"it_employee_roles"> | number
    role_id?: IntFilter<"it_employee_roles"> | number
    it_employees?: XOR<It_employeesRelationFilter, it_employeesWhereInput>
    it_roles?: XOR<It_rolesRelationFilter, it_rolesWhereInput>
  }

  export type it_employee_rolesOrderByWithRelationInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
    it_employees?: it_employeesOrderByWithRelationInput
    it_roles?: it_rolesOrderByWithRelationInput
  }

  export type it_employee_rolesWhereUniqueInput = Prisma.AtLeast<{
    employee_id_role_id?: it_employee_rolesEmployee_idRole_idCompoundUniqueInput
    AND?: it_employee_rolesWhereInput | it_employee_rolesWhereInput[]
    OR?: it_employee_rolesWhereInput[]
    NOT?: it_employee_rolesWhereInput | it_employee_rolesWhereInput[]
    employee_id?: IntFilter<"it_employee_roles"> | number
    role_id?: IntFilter<"it_employee_roles"> | number
    it_employees?: XOR<It_employeesRelationFilter, it_employeesWhereInput>
    it_roles?: XOR<It_rolesRelationFilter, it_rolesWhereInput>
  }, "employee_id_role_id">

  export type it_employee_rolesOrderByWithAggregationInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
    _count?: it_employee_rolesCountOrderByAggregateInput
    _avg?: it_employee_rolesAvgOrderByAggregateInput
    _max?: it_employee_rolesMaxOrderByAggregateInput
    _min?: it_employee_rolesMinOrderByAggregateInput
    _sum?: it_employee_rolesSumOrderByAggregateInput
  }

  export type it_employee_rolesScalarWhereWithAggregatesInput = {
    AND?: it_employee_rolesScalarWhereWithAggregatesInput | it_employee_rolesScalarWhereWithAggregatesInput[]
    OR?: it_employee_rolesScalarWhereWithAggregatesInput[]
    NOT?: it_employee_rolesScalarWhereWithAggregatesInput | it_employee_rolesScalarWhereWithAggregatesInput[]
    employee_id?: IntWithAggregatesFilter<"it_employee_roles"> | number
    role_id?: IntWithAggregatesFilter<"it_employee_roles"> | number
  }

  export type it_employeesWhereInput = {
    AND?: it_employeesWhereInput | it_employeesWhereInput[]
    OR?: it_employeesWhereInput[]
    NOT?: it_employeesWhereInput | it_employeesWhereInput[]
    id?: IntFilter<"it_employees"> | number
    first_name?: StringFilter<"it_employees"> | string
    last_name?: StringFilter<"it_employees"> | string
    employee_code?: StringFilter<"it_employees"> | string
    department_id?: IntFilter<"it_employees"> | number
    is_dept_head?: BoolFilter<"it_employees"> | boolean
    is_active?: BoolFilter<"it_employees"> | boolean
    it_employee_roles?: It_employee_rolesListRelationFilter
    it_departments?: XOR<It_departmentsRelationFilter, it_departmentsWhereInput>
  }

  export type it_employeesOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    employee_code?: SortOrder
    department_id?: SortOrder
    is_dept_head?: SortOrder
    is_active?: SortOrder
    it_employee_roles?: it_employee_rolesOrderByRelationAggregateInput
    it_departments?: it_departmentsOrderByWithRelationInput
  }

  export type it_employeesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employee_code?: string
    AND?: it_employeesWhereInput | it_employeesWhereInput[]
    OR?: it_employeesWhereInput[]
    NOT?: it_employeesWhereInput | it_employeesWhereInput[]
    first_name?: StringFilter<"it_employees"> | string
    last_name?: StringFilter<"it_employees"> | string
    department_id?: IntFilter<"it_employees"> | number
    is_dept_head?: BoolFilter<"it_employees"> | boolean
    is_active?: BoolFilter<"it_employees"> | boolean
    it_employee_roles?: It_employee_rolesListRelationFilter
    it_departments?: XOR<It_departmentsRelationFilter, it_departmentsWhereInput>
  }, "id" | "employee_code">

  export type it_employeesOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    employee_code?: SortOrder
    department_id?: SortOrder
    is_dept_head?: SortOrder
    is_active?: SortOrder
    _count?: it_employeesCountOrderByAggregateInput
    _avg?: it_employeesAvgOrderByAggregateInput
    _max?: it_employeesMaxOrderByAggregateInput
    _min?: it_employeesMinOrderByAggregateInput
    _sum?: it_employeesSumOrderByAggregateInput
  }

  export type it_employeesScalarWhereWithAggregatesInput = {
    AND?: it_employeesScalarWhereWithAggregatesInput | it_employeesScalarWhereWithAggregatesInput[]
    OR?: it_employeesScalarWhereWithAggregatesInput[]
    NOT?: it_employeesScalarWhereWithAggregatesInput | it_employeesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"it_employees"> | number
    first_name?: StringWithAggregatesFilter<"it_employees"> | string
    last_name?: StringWithAggregatesFilter<"it_employees"> | string
    employee_code?: StringWithAggregatesFilter<"it_employees"> | string
    department_id?: IntWithAggregatesFilter<"it_employees"> | number
    is_dept_head?: BoolWithAggregatesFilter<"it_employees"> | boolean
    is_active?: BoolWithAggregatesFilter<"it_employees"> | boolean
  }

  export type it_rolesWhereInput = {
    AND?: it_rolesWhereInput | it_rolesWhereInput[]
    OR?: it_rolesWhereInput[]
    NOT?: it_rolesWhereInput | it_rolesWhereInput[]
    id?: IntFilter<"it_roles"> | number
    name?: StringFilter<"it_roles"> | string
    it_employee_roles?: It_employee_rolesListRelationFilter
  }

  export type it_rolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    it_employee_roles?: it_employee_rolesOrderByRelationAggregateInput
  }

  export type it_rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: it_rolesWhereInput | it_rolesWhereInput[]
    OR?: it_rolesWhereInput[]
    NOT?: it_rolesWhereInput | it_rolesWhereInput[]
    it_employee_roles?: It_employee_rolesListRelationFilter
  }, "id" | "name">

  export type it_rolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: it_rolesCountOrderByAggregateInput
    _avg?: it_rolesAvgOrderByAggregateInput
    _max?: it_rolesMaxOrderByAggregateInput
    _min?: it_rolesMinOrderByAggregateInput
    _sum?: it_rolesSumOrderByAggregateInput
  }

  export type it_rolesScalarWhereWithAggregatesInput = {
    AND?: it_rolesScalarWhereWithAggregatesInput | it_rolesScalarWhereWithAggregatesInput[]
    OR?: it_rolesScalarWhereWithAggregatesInput[]
    NOT?: it_rolesScalarWhereWithAggregatesInput | it_rolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"it_roles"> | number
    name?: StringWithAggregatesFilter<"it_roles"> | string
  }

  export type KnowledgeBaseWhereInput = {
    AND?: KnowledgeBaseWhereInput | KnowledgeBaseWhereInput[]
    OR?: KnowledgeBaseWhereInput[]
    NOT?: KnowledgeBaseWhereInput | KnowledgeBaseWhereInput[]
    id?: IntFilter<"KnowledgeBase"> | number
    title?: StringFilter<"KnowledgeBase"> | string
    content?: StringFilter<"KnowledgeBase"> | string
    category?: StringNullableFilter<"KnowledgeBase"> | string | null
    tags?: StringNullableFilter<"KnowledgeBase"> | string | null
    isPublic?: BoolFilter<"KnowledgeBase"> | boolean
    createdById?: IntFilter<"KnowledgeBase"> | number
    linkedTicketId?: IntNullableFilter<"KnowledgeBase"> | number | null
    createdAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Ticket?: XOR<TicketNullableRelationFilter, TicketWhereInput> | null
  }

  export type KnowledgeBaseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdById?: SortOrder
    linkedTicketId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Ticket?: TicketOrderByWithRelationInput
  }

  export type KnowledgeBaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KnowledgeBaseWhereInput | KnowledgeBaseWhereInput[]
    OR?: KnowledgeBaseWhereInput[]
    NOT?: KnowledgeBaseWhereInput | KnowledgeBaseWhereInput[]
    title?: StringFilter<"KnowledgeBase"> | string
    content?: StringFilter<"KnowledgeBase"> | string
    category?: StringNullableFilter<"KnowledgeBase"> | string | null
    tags?: StringNullableFilter<"KnowledgeBase"> | string | null
    isPublic?: BoolFilter<"KnowledgeBase"> | boolean
    createdById?: IntFilter<"KnowledgeBase"> | number
    linkedTicketId?: IntNullableFilter<"KnowledgeBase"> | number | null
    createdAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Ticket?: XOR<TicketNullableRelationFilter, TicketWhereInput> | null
  }, "id">

  export type KnowledgeBaseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdById?: SortOrder
    linkedTicketId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KnowledgeBaseCountOrderByAggregateInput
    _avg?: KnowledgeBaseAvgOrderByAggregateInput
    _max?: KnowledgeBaseMaxOrderByAggregateInput
    _min?: KnowledgeBaseMinOrderByAggregateInput
    _sum?: KnowledgeBaseSumOrderByAggregateInput
  }

  export type KnowledgeBaseScalarWhereWithAggregatesInput = {
    AND?: KnowledgeBaseScalarWhereWithAggregatesInput | KnowledgeBaseScalarWhereWithAggregatesInput[]
    OR?: KnowledgeBaseScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeBaseScalarWhereWithAggregatesInput | KnowledgeBaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KnowledgeBase"> | number
    title?: StringWithAggregatesFilter<"KnowledgeBase"> | string
    content?: StringWithAggregatesFilter<"KnowledgeBase"> | string
    category?: StringNullableWithAggregatesFilter<"KnowledgeBase"> | string | null
    tags?: StringNullableWithAggregatesFilter<"KnowledgeBase"> | string | null
    isPublic?: BoolWithAggregatesFilter<"KnowledgeBase"> | boolean
    createdById?: IntWithAggregatesFilter<"KnowledgeBase"> | number
    linkedTicketId?: IntNullableWithAggregatesFilter<"KnowledgeBase"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeBase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeBase"> | Date | string
  }

  export type LicenseWhereInput = {
    AND?: LicenseWhereInput | LicenseWhereInput[]
    OR?: LicenseWhereInput[]
    NOT?: LicenseWhereInput | LicenseWhereInput[]
    id?: IntFilter<"License"> | number
    softwareName?: StringFilter<"License"> | string
    licenseKey?: StringFilter<"License"> | string
    expireDate?: DateTimeFilter<"License"> | Date | string
    assetId?: IntFilter<"License"> | number
    Asset?: XOR<AssetRelationFilter, AssetWhereInput>
  }

  export type LicenseOrderByWithRelationInput = {
    id?: SortOrder
    softwareName?: SortOrder
    licenseKey?: SortOrder
    expireDate?: SortOrder
    assetId?: SortOrder
    Asset?: AssetOrderByWithRelationInput
  }

  export type LicenseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LicenseWhereInput | LicenseWhereInput[]
    OR?: LicenseWhereInput[]
    NOT?: LicenseWhereInput | LicenseWhereInput[]
    softwareName?: StringFilter<"License"> | string
    licenseKey?: StringFilter<"License"> | string
    expireDate?: DateTimeFilter<"License"> | Date | string
    assetId?: IntFilter<"License"> | number
    Asset?: XOR<AssetRelationFilter, AssetWhereInput>
  }, "id">

  export type LicenseOrderByWithAggregationInput = {
    id?: SortOrder
    softwareName?: SortOrder
    licenseKey?: SortOrder
    expireDate?: SortOrder
    assetId?: SortOrder
    _count?: LicenseCountOrderByAggregateInput
    _avg?: LicenseAvgOrderByAggregateInput
    _max?: LicenseMaxOrderByAggregateInput
    _min?: LicenseMinOrderByAggregateInput
    _sum?: LicenseSumOrderByAggregateInput
  }

  export type LicenseScalarWhereWithAggregatesInput = {
    AND?: LicenseScalarWhereWithAggregatesInput | LicenseScalarWhereWithAggregatesInput[]
    OR?: LicenseScalarWhereWithAggregatesInput[]
    NOT?: LicenseScalarWhereWithAggregatesInput | LicenseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"License"> | number
    softwareName?: StringWithAggregatesFilter<"License"> | string
    licenseKey?: StringWithAggregatesFilter<"License"> | string
    expireDate?: DateTimeWithAggregatesFilter<"License"> | Date | string
    assetId?: IntWithAggregatesFilter<"License"> | number
  }

  export type MonitorWhereInput = {
    AND?: MonitorWhereInput | MonitorWhereInput[]
    OR?: MonitorWhereInput[]
    NOT?: MonitorWhereInput | MonitorWhereInput[]
    id?: IntFilter<"Monitor"> | number
    targetName?: StringFilter<"Monitor"> | string
    ipAddress?: StringFilter<"Monitor"> | string
    status?: StringFilter<"Monitor"> | string
    lastCheck?: DateTimeFilter<"Monitor"> | Date | string
    assetId?: IntFilter<"Monitor"> | number
    Asset?: XOR<AssetRelationFilter, AssetWhereInput>
  }

  export type MonitorOrderByWithRelationInput = {
    id?: SortOrder
    targetName?: SortOrder
    ipAddress?: SortOrder
    status?: SortOrder
    lastCheck?: SortOrder
    assetId?: SortOrder
    Asset?: AssetOrderByWithRelationInput
  }

  export type MonitorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    assetId?: number
    AND?: MonitorWhereInput | MonitorWhereInput[]
    OR?: MonitorWhereInput[]
    NOT?: MonitorWhereInput | MonitorWhereInput[]
    targetName?: StringFilter<"Monitor"> | string
    ipAddress?: StringFilter<"Monitor"> | string
    status?: StringFilter<"Monitor"> | string
    lastCheck?: DateTimeFilter<"Monitor"> | Date | string
    Asset?: XOR<AssetRelationFilter, AssetWhereInput>
  }, "id" | "assetId">

  export type MonitorOrderByWithAggregationInput = {
    id?: SortOrder
    targetName?: SortOrder
    ipAddress?: SortOrder
    status?: SortOrder
    lastCheck?: SortOrder
    assetId?: SortOrder
    _count?: MonitorCountOrderByAggregateInput
    _avg?: MonitorAvgOrderByAggregateInput
    _max?: MonitorMaxOrderByAggregateInput
    _min?: MonitorMinOrderByAggregateInput
    _sum?: MonitorSumOrderByAggregateInput
  }

  export type MonitorScalarWhereWithAggregatesInput = {
    AND?: MonitorScalarWhereWithAggregatesInput | MonitorScalarWhereWithAggregatesInput[]
    OR?: MonitorScalarWhereWithAggregatesInput[]
    NOT?: MonitorScalarWhereWithAggregatesInput | MonitorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Monitor"> | number
    targetName?: StringWithAggregatesFilter<"Monitor"> | string
    ipAddress?: StringWithAggregatesFilter<"Monitor"> | string
    status?: StringWithAggregatesFilter<"Monitor"> | string
    lastCheck?: DateTimeWithAggregatesFilter<"Monitor"> | Date | string
    assetId?: IntWithAggregatesFilter<"Monitor"> | number
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id?: IntFilter<"roles"> | number
    name?: StringFilter<"roles"> | string
    employee_roles?: Employee_rolesListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    employee_roles?: employee_rolesOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    employee_roles?: Employee_rolesListRelationFilter
  }, "id" | "name">

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"roles"> | number
    name?: StringWithAggregatesFilter<"roles"> | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: IntFilter<"Ticket"> | number
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    resolutionNote?: StringNullableFilter<"Ticket"> | string | null
    status?: StringFilter<"Ticket"> | string
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    assetId?: IntNullableFilter<"Ticket"> | number | null
    requestedById?: IntFilter<"Ticket"> | number
    assignedToId?: IntNullableFilter<"Ticket"> | number | null
    KnowledgeBase?: KnowledgeBaseListRelationFilter
    Asset?: XOR<AssetNullableRelationFilter, AssetWhereInput> | null
    User_Ticket_assignedToIdToUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    User_Ticket_requestedByIdToUser?: XOR<UserRelationFilter, UserWhereInput>
    TicketAttachment?: TicketAttachmentListRelationFilter
    TicketComment?: TicketCommentListRelationFilter
    TicketHistory?: TicketHistoryListRelationFilter
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resolutionNote?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    assetId?: SortOrderInput | SortOrder
    requestedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    KnowledgeBase?: KnowledgeBaseOrderByRelationAggregateInput
    Asset?: AssetOrderByWithRelationInput
    User_Ticket_assignedToIdToUser?: UserOrderByWithRelationInput
    User_Ticket_requestedByIdToUser?: UserOrderByWithRelationInput
    TicketAttachment?: TicketAttachmentOrderByRelationAggregateInput
    TicketComment?: TicketCommentOrderByRelationAggregateInput
    TicketHistory?: TicketHistoryOrderByRelationAggregateInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    resolutionNote?: StringNullableFilter<"Ticket"> | string | null
    status?: StringFilter<"Ticket"> | string
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    assetId?: IntNullableFilter<"Ticket"> | number | null
    requestedById?: IntFilter<"Ticket"> | number
    assignedToId?: IntNullableFilter<"Ticket"> | number | null
    KnowledgeBase?: KnowledgeBaseListRelationFilter
    Asset?: XOR<AssetNullableRelationFilter, AssetWhereInput> | null
    User_Ticket_assignedToIdToUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    User_Ticket_requestedByIdToUser?: XOR<UserRelationFilter, UserWhereInput>
    TicketAttachment?: TicketAttachmentListRelationFilter
    TicketComment?: TicketCommentListRelationFilter
    TicketHistory?: TicketHistoryListRelationFilter
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resolutionNote?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    assetId?: SortOrderInput | SortOrder
    requestedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    _count?: TicketCountOrderByAggregateInput
    _avg?: TicketAvgOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
    _sum?: TicketSumOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ticket"> | number
    title?: StringWithAggregatesFilter<"Ticket"> | string
    description?: StringWithAggregatesFilter<"Ticket"> | string
    resolutionNote?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    status?: StringWithAggregatesFilter<"Ticket"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    assetId?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
    requestedById?: IntWithAggregatesFilter<"Ticket"> | number
    assignedToId?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
  }

  export type TicketAttachmentWhereInput = {
    AND?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    OR?: TicketAttachmentWhereInput[]
    NOT?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    id?: IntFilter<"TicketAttachment"> | number
    fileName?: StringFilter<"TicketAttachment"> | string
    filePath?: StringFilter<"TicketAttachment"> | string
    uploadedAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticketId?: IntFilter<"TicketAttachment"> | number
    uploadedById?: IntFilter<"TicketAttachment"> | number
    Ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TicketAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    ticketId?: SortOrder
    uploadedById?: SortOrder
    Ticket?: TicketOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type TicketAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    OR?: TicketAttachmentWhereInput[]
    NOT?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    fileName?: StringFilter<"TicketAttachment"> | string
    filePath?: StringFilter<"TicketAttachment"> | string
    uploadedAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticketId?: IntFilter<"TicketAttachment"> | number
    uploadedById?: IntFilter<"TicketAttachment"> | number
    Ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TicketAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    ticketId?: SortOrder
    uploadedById?: SortOrder
    _count?: TicketAttachmentCountOrderByAggregateInput
    _avg?: TicketAttachmentAvgOrderByAggregateInput
    _max?: TicketAttachmentMaxOrderByAggregateInput
    _min?: TicketAttachmentMinOrderByAggregateInput
    _sum?: TicketAttachmentSumOrderByAggregateInput
  }

  export type TicketAttachmentScalarWhereWithAggregatesInput = {
    AND?: TicketAttachmentScalarWhereWithAggregatesInput | TicketAttachmentScalarWhereWithAggregatesInput[]
    OR?: TicketAttachmentScalarWhereWithAggregatesInput[]
    NOT?: TicketAttachmentScalarWhereWithAggregatesInput | TicketAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketAttachment"> | number
    fileName?: StringWithAggregatesFilter<"TicketAttachment"> | string
    filePath?: StringWithAggregatesFilter<"TicketAttachment"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"TicketAttachment"> | Date | string
    ticketId?: IntWithAggregatesFilter<"TicketAttachment"> | number
    uploadedById?: IntWithAggregatesFilter<"TicketAttachment"> | number
  }

  export type TicketCommentWhereInput = {
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    id?: IntFilter<"TicketComment"> | number
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticketId?: IntFilter<"TicketComment"> | number
    createdById?: IntFilter<"TicketComment"> | number
    User?: XOR<UserRelationFilter, UserWhereInput>
    Ticket?: XOR<TicketRelationFilter, TicketWhereInput>
  }

  export type TicketCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
    createdById?: SortOrder
    User?: UserOrderByWithRelationInput
    Ticket?: TicketOrderByWithRelationInput
  }

  export type TicketCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticketId?: IntFilter<"TicketComment"> | number
    createdById?: IntFilter<"TicketComment"> | number
    User?: XOR<UserRelationFilter, UserWhereInput>
    Ticket?: XOR<TicketRelationFilter, TicketWhereInput>
  }, "id">

  export type TicketCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
    createdById?: SortOrder
    _count?: TicketCommentCountOrderByAggregateInput
    _avg?: TicketCommentAvgOrderByAggregateInput
    _max?: TicketCommentMaxOrderByAggregateInput
    _min?: TicketCommentMinOrderByAggregateInput
    _sum?: TicketCommentSumOrderByAggregateInput
  }

  export type TicketCommentScalarWhereWithAggregatesInput = {
    AND?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    OR?: TicketCommentScalarWhereWithAggregatesInput[]
    NOT?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketComment"> | number
    content?: StringWithAggregatesFilter<"TicketComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketComment"> | Date | string
    ticketId?: IntWithAggregatesFilter<"TicketComment"> | number
    createdById?: IntWithAggregatesFilter<"TicketComment"> | number
  }

  export type TicketHistoryWhereInput = {
    AND?: TicketHistoryWhereInput | TicketHistoryWhereInput[]
    OR?: TicketHistoryWhereInput[]
    NOT?: TicketHistoryWhereInput | TicketHistoryWhereInput[]
    id?: IntFilter<"TicketHistory"> | number
    ticketId?: IntFilter<"TicketHistory"> | number
    oldStatus?: StringFilter<"TicketHistory"> | string
    newStatus?: StringFilter<"TicketHistory"> | string
    changedById?: IntFilter<"TicketHistory"> | number
    changedAt?: DateTimeFilter<"TicketHistory"> | Date | string
    note?: StringNullableFilter<"TicketHistory"> | string | null
    User?: XOR<UserRelationFilter, UserWhereInput>
    Ticket?: XOR<TicketRelationFilter, TicketWhereInput>
  }

  export type TicketHistoryOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
    note?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    Ticket?: TicketOrderByWithRelationInput
  }

  export type TicketHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketHistoryWhereInput | TicketHistoryWhereInput[]
    OR?: TicketHistoryWhereInput[]
    NOT?: TicketHistoryWhereInput | TicketHistoryWhereInput[]
    ticketId?: IntFilter<"TicketHistory"> | number
    oldStatus?: StringFilter<"TicketHistory"> | string
    newStatus?: StringFilter<"TicketHistory"> | string
    changedById?: IntFilter<"TicketHistory"> | number
    changedAt?: DateTimeFilter<"TicketHistory"> | Date | string
    note?: StringNullableFilter<"TicketHistory"> | string | null
    User?: XOR<UserRelationFilter, UserWhereInput>
    Ticket?: XOR<TicketRelationFilter, TicketWhereInput>
  }, "id">

  export type TicketHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: TicketHistoryCountOrderByAggregateInput
    _avg?: TicketHistoryAvgOrderByAggregateInput
    _max?: TicketHistoryMaxOrderByAggregateInput
    _min?: TicketHistoryMinOrderByAggregateInput
    _sum?: TicketHistorySumOrderByAggregateInput
  }

  export type TicketHistoryScalarWhereWithAggregatesInput = {
    AND?: TicketHistoryScalarWhereWithAggregatesInput | TicketHistoryScalarWhereWithAggregatesInput[]
    OR?: TicketHistoryScalarWhereWithAggregatesInput[]
    NOT?: TicketHistoryScalarWhereWithAggregatesInput | TicketHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketHistory"> | number
    ticketId?: IntWithAggregatesFilter<"TicketHistory"> | number
    oldStatus?: StringWithAggregatesFilter<"TicketHistory"> | string
    newStatus?: StringWithAggregatesFilter<"TicketHistory"> | string
    changedById?: IntWithAggregatesFilter<"TicketHistory"> | number
    changedAt?: DateTimeWithAggregatesFilter<"TicketHistory"> | Date | string
    note?: StringNullableWithAggregatesFilter<"TicketHistory"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    empId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    department?: StringNullableFilter<"User"> | string | null
    Asset?: AssetListRelationFilter
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryListRelationFilter
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryListRelationFilter
    AuditLog?: AuditLogListRelationFilter
    Document?: DocumentListRelationFilter
    InventoryTransaction?: InventoryTransactionListRelationFilter
    KnowledgeBase?: KnowledgeBaseListRelationFilter
    Ticket_Ticket_assignedToIdToUser?: TicketListRelationFilter
    Ticket_Ticket_requestedByIdToUser?: TicketListRelationFilter
    TicketAttachment?: TicketAttachmentListRelationFilter
    TicketComment?: TicketCommentListRelationFilter
    TicketHistory?: TicketHistoryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    empId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    Asset?: AssetOrderByRelationAggregateInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryOrderByRelationAggregateInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryOrderByRelationAggregateInput
    AuditLog?: AuditLogOrderByRelationAggregateInput
    Document?: DocumentOrderByRelationAggregateInput
    InventoryTransaction?: InventoryTransactionOrderByRelationAggregateInput
    KnowledgeBase?: KnowledgeBaseOrderByRelationAggregateInput
    Ticket_Ticket_assignedToIdToUser?: TicketOrderByRelationAggregateInput
    Ticket_Ticket_requestedByIdToUser?: TicketOrderByRelationAggregateInput
    TicketAttachment?: TicketAttachmentOrderByRelationAggregateInput
    TicketComment?: TicketCommentOrderByRelationAggregateInput
    TicketHistory?: TicketHistoryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    empId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    department?: StringNullableFilter<"User"> | string | null
    Asset?: AssetListRelationFilter
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryListRelationFilter
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryListRelationFilter
    AuditLog?: AuditLogListRelationFilter
    Document?: DocumentListRelationFilter
    InventoryTransaction?: InventoryTransactionListRelationFilter
    KnowledgeBase?: KnowledgeBaseListRelationFilter
    Ticket_Ticket_assignedToIdToUser?: TicketListRelationFilter
    Ticket_Ticket_requestedByIdToUser?: TicketListRelationFilter
    TicketAttachment?: TicketAttachmentListRelationFilter
    TicketComment?: TicketCommentListRelationFilter
    TicketHistory?: TicketHistoryListRelationFilter
  }, "id" | "empId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    empId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    empId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    department?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: IntFilter<"Vendor"> | number
    name?: StringFilter<"Vendor"> | string
    contact?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    website?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    Contract?: ContractListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    Contract?: ContractOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    name?: StringFilter<"Vendor"> | string
    contact?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    website?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    Contract?: ContractListRelationFilter
  }, "id">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vendor"> | number
    name?: StringWithAggregatesFilter<"Vendor"> | string
    contact?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    website?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    address?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
  }

  export type webmes_UserWhereInput = {
    AND?: webmes_UserWhereInput | webmes_UserWhereInput[]
    OR?: webmes_UserWhereInput[]
    NOT?: webmes_UserWhereInput | webmes_UserWhereInput[]
    id?: IntFilter<"webmes_User"> | number
    employeeId?: StringFilter<"webmes_User"> | string
    fullName?: StringFilter<"webmes_User"> | string
    department?: StringFilter<"webmes_User"> | string
    email?: StringFilter<"webmes_User"> | string
    password?: StringFilter<"webmes_User"> | string
    isActive?: BoolFilter<"webmes_User"> | boolean
    createdAt?: DateTimeFilter<"webmes_User"> | Date | string
    updatedAt?: DateTimeFilter<"webmes_User"> | Date | string
    roles?: Webmes_UserRoleListRelationFilter
  }

  export type webmes_UserOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fullName?: SortOrder
    department?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roles?: webmes_UserRoleOrderByRelationAggregateInput
  }

  export type webmes_UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId?: string
    email?: string
    AND?: webmes_UserWhereInput | webmes_UserWhereInput[]
    OR?: webmes_UserWhereInput[]
    NOT?: webmes_UserWhereInput | webmes_UserWhereInput[]
    fullName?: StringFilter<"webmes_User"> | string
    department?: StringFilter<"webmes_User"> | string
    password?: StringFilter<"webmes_User"> | string
    isActive?: BoolFilter<"webmes_User"> | boolean
    createdAt?: DateTimeFilter<"webmes_User"> | Date | string
    updatedAt?: DateTimeFilter<"webmes_User"> | Date | string
    roles?: Webmes_UserRoleListRelationFilter
  }, "id" | "employeeId" | "email">

  export type webmes_UserOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fullName?: SortOrder
    department?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: webmes_UserCountOrderByAggregateInput
    _avg?: webmes_UserAvgOrderByAggregateInput
    _max?: webmes_UserMaxOrderByAggregateInput
    _min?: webmes_UserMinOrderByAggregateInput
    _sum?: webmes_UserSumOrderByAggregateInput
  }

  export type webmes_UserScalarWhereWithAggregatesInput = {
    AND?: webmes_UserScalarWhereWithAggregatesInput | webmes_UserScalarWhereWithAggregatesInput[]
    OR?: webmes_UserScalarWhereWithAggregatesInput[]
    NOT?: webmes_UserScalarWhereWithAggregatesInput | webmes_UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"webmes_User"> | number
    employeeId?: StringWithAggregatesFilter<"webmes_User"> | string
    fullName?: StringWithAggregatesFilter<"webmes_User"> | string
    department?: StringWithAggregatesFilter<"webmes_User"> | string
    email?: StringWithAggregatesFilter<"webmes_User"> | string
    password?: StringWithAggregatesFilter<"webmes_User"> | string
    isActive?: BoolWithAggregatesFilter<"webmes_User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"webmes_User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"webmes_User"> | Date | string
  }

  export type webmes_RoleWhereInput = {
    AND?: webmes_RoleWhereInput | webmes_RoleWhereInput[]
    OR?: webmes_RoleWhereInput[]
    NOT?: webmes_RoleWhereInput | webmes_RoleWhereInput[]
    id?: IntFilter<"webmes_Role"> | number
    name?: StringFilter<"webmes_Role"> | string
    description?: StringNullableFilter<"webmes_Role"> | string | null
    permissions?: Webmes_RolePermissionListRelationFilter
    users?: Webmes_UserRoleListRelationFilter
  }

  export type webmes_RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: webmes_RolePermissionOrderByRelationAggregateInput
    users?: webmes_UserRoleOrderByRelationAggregateInput
  }

  export type webmes_RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: webmes_RoleWhereInput | webmes_RoleWhereInput[]
    OR?: webmes_RoleWhereInput[]
    NOT?: webmes_RoleWhereInput | webmes_RoleWhereInput[]
    description?: StringNullableFilter<"webmes_Role"> | string | null
    permissions?: Webmes_RolePermissionListRelationFilter
    users?: Webmes_UserRoleListRelationFilter
  }, "id" | "name">

  export type webmes_RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: webmes_RoleCountOrderByAggregateInput
    _avg?: webmes_RoleAvgOrderByAggregateInput
    _max?: webmes_RoleMaxOrderByAggregateInput
    _min?: webmes_RoleMinOrderByAggregateInput
    _sum?: webmes_RoleSumOrderByAggregateInput
  }

  export type webmes_RoleScalarWhereWithAggregatesInput = {
    AND?: webmes_RoleScalarWhereWithAggregatesInput | webmes_RoleScalarWhereWithAggregatesInput[]
    OR?: webmes_RoleScalarWhereWithAggregatesInput[]
    NOT?: webmes_RoleScalarWhereWithAggregatesInput | webmes_RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"webmes_Role"> | number
    name?: StringWithAggregatesFilter<"webmes_Role"> | string
    description?: StringNullableWithAggregatesFilter<"webmes_Role"> | string | null
  }

  export type webmes_PermissionWhereInput = {
    AND?: webmes_PermissionWhereInput | webmes_PermissionWhereInput[]
    OR?: webmes_PermissionWhereInput[]
    NOT?: webmes_PermissionWhereInput | webmes_PermissionWhereInput[]
    id?: IntFilter<"webmes_Permission"> | number
    name?: StringFilter<"webmes_Permission"> | string
    module?: StringFilter<"webmes_Permission"> | string
    roles?: Webmes_RolePermissionListRelationFilter
  }

  export type webmes_PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    module?: SortOrder
    roles?: webmes_RolePermissionOrderByRelationAggregateInput
  }

  export type webmes_PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_module?: webmes_PermissionNameModuleCompoundUniqueInput
    AND?: webmes_PermissionWhereInput | webmes_PermissionWhereInput[]
    OR?: webmes_PermissionWhereInput[]
    NOT?: webmes_PermissionWhereInput | webmes_PermissionWhereInput[]
    name?: StringFilter<"webmes_Permission"> | string
    module?: StringFilter<"webmes_Permission"> | string
    roles?: Webmes_RolePermissionListRelationFilter
  }, "id" | "name_module">

  export type webmes_PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    module?: SortOrder
    _count?: webmes_PermissionCountOrderByAggregateInput
    _avg?: webmes_PermissionAvgOrderByAggregateInput
    _max?: webmes_PermissionMaxOrderByAggregateInput
    _min?: webmes_PermissionMinOrderByAggregateInput
    _sum?: webmes_PermissionSumOrderByAggregateInput
  }

  export type webmes_PermissionScalarWhereWithAggregatesInput = {
    AND?: webmes_PermissionScalarWhereWithAggregatesInput | webmes_PermissionScalarWhereWithAggregatesInput[]
    OR?: webmes_PermissionScalarWhereWithAggregatesInput[]
    NOT?: webmes_PermissionScalarWhereWithAggregatesInput | webmes_PermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"webmes_Permission"> | number
    name?: StringWithAggregatesFilter<"webmes_Permission"> | string
    module?: StringWithAggregatesFilter<"webmes_Permission"> | string
  }

  export type webmes_UserRoleWhereInput = {
    AND?: webmes_UserRoleWhereInput | webmes_UserRoleWhereInput[]
    OR?: webmes_UserRoleWhereInput[]
    NOT?: webmes_UserRoleWhereInput | webmes_UserRoleWhereInput[]
    id?: IntFilter<"webmes_UserRole"> | number
    userId?: IntFilter<"webmes_UserRole"> | number
    roleId?: IntFilter<"webmes_UserRole"> | number
    user?: XOR<Webmes_UserRelationFilter, webmes_UserWhereInput>
    role?: XOR<Webmes_RoleRelationFilter, webmes_RoleWhereInput>
  }

  export type webmes_UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    user?: webmes_UserOrderByWithRelationInput
    role?: webmes_RoleOrderByWithRelationInput
  }

  export type webmes_UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_roleId?: webmes_UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: webmes_UserRoleWhereInput | webmes_UserRoleWhereInput[]
    OR?: webmes_UserRoleWhereInput[]
    NOT?: webmes_UserRoleWhereInput | webmes_UserRoleWhereInput[]
    userId?: IntFilter<"webmes_UserRole"> | number
    roleId?: IntFilter<"webmes_UserRole"> | number
    user?: XOR<Webmes_UserRelationFilter, webmes_UserWhereInput>
    role?: XOR<Webmes_RoleRelationFilter, webmes_RoleWhereInput>
  }, "id" | "userId_roleId">

  export type webmes_UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    _count?: webmes_UserRoleCountOrderByAggregateInput
    _avg?: webmes_UserRoleAvgOrderByAggregateInput
    _max?: webmes_UserRoleMaxOrderByAggregateInput
    _min?: webmes_UserRoleMinOrderByAggregateInput
    _sum?: webmes_UserRoleSumOrderByAggregateInput
  }

  export type webmes_UserRoleScalarWhereWithAggregatesInput = {
    AND?: webmes_UserRoleScalarWhereWithAggregatesInput | webmes_UserRoleScalarWhereWithAggregatesInput[]
    OR?: webmes_UserRoleScalarWhereWithAggregatesInput[]
    NOT?: webmes_UserRoleScalarWhereWithAggregatesInput | webmes_UserRoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"webmes_UserRole"> | number
    userId?: IntWithAggregatesFilter<"webmes_UserRole"> | number
    roleId?: IntWithAggregatesFilter<"webmes_UserRole"> | number
  }

  export type webmes_RolePermissionWhereInput = {
    AND?: webmes_RolePermissionWhereInput | webmes_RolePermissionWhereInput[]
    OR?: webmes_RolePermissionWhereInput[]
    NOT?: webmes_RolePermissionWhereInput | webmes_RolePermissionWhereInput[]
    id?: IntFilter<"webmes_RolePermission"> | number
    roleId?: IntFilter<"webmes_RolePermission"> | number
    permissionId?: IntFilter<"webmes_RolePermission"> | number
    role?: XOR<Webmes_RoleRelationFilter, webmes_RoleWhereInput>
    permission?: XOR<Webmes_PermissionRelationFilter, webmes_PermissionWhereInput>
  }

  export type webmes_RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    role?: webmes_RoleOrderByWithRelationInput
    permission?: webmes_PermissionOrderByWithRelationInput
  }

  export type webmes_RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roleId_permissionId?: webmes_RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: webmes_RolePermissionWhereInput | webmes_RolePermissionWhereInput[]
    OR?: webmes_RolePermissionWhereInput[]
    NOT?: webmes_RolePermissionWhereInput | webmes_RolePermissionWhereInput[]
    roleId?: IntFilter<"webmes_RolePermission"> | number
    permissionId?: IntFilter<"webmes_RolePermission"> | number
    role?: XOR<Webmes_RoleRelationFilter, webmes_RoleWhereInput>
    permission?: XOR<Webmes_PermissionRelationFilter, webmes_PermissionWhereInput>
  }, "id" | "roleId_permissionId">

  export type webmes_RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    _count?: webmes_RolePermissionCountOrderByAggregateInput
    _avg?: webmes_RolePermissionAvgOrderByAggregateInput
    _max?: webmes_RolePermissionMaxOrderByAggregateInput
    _min?: webmes_RolePermissionMinOrderByAggregateInput
    _sum?: webmes_RolePermissionSumOrderByAggregateInput
  }

  export type webmes_RolePermissionScalarWhereWithAggregatesInput = {
    AND?: webmes_RolePermissionScalarWhereWithAggregatesInput | webmes_RolePermissionScalarWhereWithAggregatesInput[]
    OR?: webmes_RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: webmes_RolePermissionScalarWhereWithAggregatesInput | webmes_RolePermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"webmes_RolePermission"> | number
    roleId?: IntWithAggregatesFilter<"webmes_RolePermission"> | number
    permissionId?: IntWithAggregatesFilter<"webmes_RolePermission"> | number
  }

  export type AssetCreateInput = {
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    User?: UserCreateNestedOneWithoutAssetInput
    AssetHistory?: AssetHistoryCreateNestedManyWithoutAssetInput
    License?: LicenseCreateNestedManyWithoutAssetInput
    Monitor?: MonitorCreateNestedOneWithoutAssetInput
    Ticket?: TicketCreateNestedManyWithoutAssetInput
    Contract?: ContractCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateInput = {
    id?: number
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    ownerId?: number | null
    AssetHistory?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
    License?: LicenseUncheckedCreateNestedManyWithoutAssetInput
    Monitor?: MonitorUncheckedCreateNestedOneWithoutAssetInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutAssetInput
    Contract?: ContractUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutAssetNestedInput
    AssetHistory?: AssetHistoryUpdateManyWithoutAssetNestedInput
    License?: LicenseUpdateManyWithoutAssetNestedInput
    Monitor?: MonitorUpdateOneWithoutAssetNestedInput
    Ticket?: TicketUpdateManyWithoutAssetNestedInput
    Contract?: ContractUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    AssetHistory?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
    License?: LicenseUncheckedUpdateManyWithoutAssetNestedInput
    Monitor?: MonitorUncheckedUpdateOneWithoutAssetNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutAssetNestedInput
    Contract?: ContractUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetCreateManyInput = {
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    ownerId?: number | null
  }

  export type AssetUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssetHistoryCreateInput = {
    changedAt?: Date | string
    reason?: string | null
    Asset: AssetCreateNestedOneWithoutAssetHistoryInput
    User_AssetHistory_newOwnerIdToUser?: UserCreateNestedOneWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput
    User_AssetHistory_oldOwnerIdToUser?: UserCreateNestedOneWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput
  }

  export type AssetHistoryUncheckedCreateInput = {
    id?: number
    assetId: number
    oldOwnerId?: number | null
    newOwnerId?: number | null
    changedAt?: Date | string
    reason?: string | null
  }

  export type AssetHistoryUpdateInput = {
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateOneRequiredWithoutAssetHistoryNestedInput
    User_AssetHistory_newOwnerIdToUser?: UserUpdateOneWithoutAssetHistory_AssetHistory_newOwnerIdToUserNestedInput
    User_AssetHistory_oldOwnerIdToUser?: UserUpdateOneWithoutAssetHistory_AssetHistory_oldOwnerIdToUserNestedInput
  }

  export type AssetHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    oldOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    newOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetHistoryCreateManyInput = {
    assetId: number
    oldOwnerId?: number | null
    newOwnerId?: number | null
    changedAt?: Date | string
    reason?: string | null
  }

  export type AssetHistoryUpdateManyMutationInput = {
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    oldOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    newOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateInput = {
    action: string
    tableName: string
    recordId?: number | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
    User: UserCreateNestedOneWithoutAuditLogInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    action: string
    tableName: string
    recordId?: number | null
    oldValue?: string | null
    newValue?: string | null
    userId: number
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableIntFieldUpdateOperationsInput | number | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutAuditLogNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableIntFieldUpdateOperationsInput | number | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    action: string
    tableName: string
    recordId?: number | null
    oldValue?: string | null
    newValue?: string | null
    userId: number
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableIntFieldUpdateOperationsInput | number | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableIntFieldUpdateOperationsInput | number | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateInput = {
    title: string
    contractNo: string
    startDate: Date | string
    endDate: Date | string
    amount?: number | null
    description?: string | null
    Vendor: VendorCreateNestedOneWithoutContractInput
    Asset?: AssetCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateInput = {
    id?: number
    title: string
    contractNo: string
    startDate: Date | string
    endDate: Date | string
    amount?: number | null
    description?: string | null
    vendorId: number
    Asset?: AssetUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Vendor?: VendorUpdateOneRequiredWithoutContractNestedInput
    Asset?: AssetUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
    Asset?: AssetUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractCreateManyInput = {
    title: string
    contractNo: string
    startDate: Date | string
    endDate: Date | string
    amount?: number | null
    description?: string | null
    vendorId: number
  }

  export type ContractUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
  }

  export type departmentsCreateInput = {
    name: string
    employees?: employeesCreateNestedManyWithoutDepartmentsInput
  }

  export type departmentsUncheckedCreateInput = {
    id?: number
    name: string
    employees?: employeesUncheckedCreateNestedManyWithoutDepartmentsInput
  }

  export type departmentsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    employees?: employeesUpdateManyWithoutDepartmentsNestedInput
  }

  export type departmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    employees?: employeesUncheckedUpdateManyWithoutDepartmentsNestedInput
  }

  export type departmentsCreateManyInput = {
    name: string
  }

  export type departmentsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type departmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateInput = {
    name: string
    filePath: string
    version: string
    permission: string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: number
    name: string
    filePath: string
    version: string
    permission: string
    createdAt?: Date | string
    createdById: number
  }

  export type DocumentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type DocumentCreateManyInput = {
    name: string
    filePath: string
    version: string
    permission: string
    createdAt?: Date | string
    createdById: number
  }

  export type DocumentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type employee_rolesCreateInput = {
    employees: employeesCreateNestedOneWithoutEmployee_rolesInput
    roles: rolesCreateNestedOneWithoutEmployee_rolesInput
  }

  export type employee_rolesUncheckedCreateInput = {
    employee_id: number
    role_id: number
  }

  export type employee_rolesUpdateInput = {
    employees?: employeesUpdateOneRequiredWithoutEmployee_rolesNestedInput
    roles?: rolesUpdateOneRequiredWithoutEmployee_rolesNestedInput
  }

  export type employee_rolesUncheckedUpdateInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type employee_rolesCreateManyInput = {
    employee_id: number
    role_id: number
  }

  export type employee_rolesUpdateManyMutationInput = {

  }

  export type employee_rolesUncheckedUpdateManyInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type employeesCreateInput = {
    first_name: string
    last_name: string
    employee_code: string
    is_dept_head?: boolean
    is_active?: boolean
    employee_roles?: employee_rolesCreateNestedManyWithoutEmployeesInput
    departments: departmentsCreateNestedOneWithoutEmployeesInput
  }

  export type employeesUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    employee_code: string
    department_id: number
    is_dept_head?: boolean
    is_active?: boolean
    employee_roles?: employee_rolesUncheckedCreateNestedManyWithoutEmployeesInput
  }

  export type employeesUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    employee_roles?: employee_rolesUpdateManyWithoutEmployeesNestedInput
    departments?: departmentsUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type employeesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    employee_roles?: employee_rolesUncheckedUpdateManyWithoutEmployeesNestedInput
  }

  export type employeesCreateManyInput = {
    first_name: string
    last_name: string
    employee_code: string
    department_id: number
    is_dept_head?: boolean
    is_active?: boolean
  }

  export type employeesUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type employeesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventoryCategoryCreateInput = {
    name: string
    InventoryItem?: InventoryItemCreateNestedManyWithoutInventoryCategoryInput
  }

  export type InventoryCategoryUncheckedCreateInput = {
    id?: number
    name: string
    InventoryItem?: InventoryItemUncheckedCreateNestedManyWithoutInventoryCategoryInput
  }

  export type InventoryCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    InventoryItem?: InventoryItemUpdateManyWithoutInventoryCategoryNestedInput
  }

  export type InventoryCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    InventoryItem?: InventoryItemUncheckedUpdateManyWithoutInventoryCategoryNestedInput
  }

  export type InventoryCategoryCreateManyInput = {
    name: string
  }

  export type InventoryCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryItemCreateInput = {
    name: string
    description?: string | null
    barcode?: string | null
    serialNumber?: string | null
    stock?: number
    minStock?: number
    unit?: string | null
    imagePath?: string | null
    InventoryCategory: InventoryCategoryCreateNestedOneWithoutInventoryItemInput
    InventorySupplier?: InventorySupplierCreateNestedOneWithoutInventoryItemInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    barcode?: string | null
    serialNumber?: string | null
    categoryId: number
    supplierId?: number | null
    stock?: number
    minStock?: number
    unit?: string | null
    imagePath?: string | null
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    InventoryCategory?: InventoryCategoryUpdateOneRequiredWithoutInventoryItemNestedInput
    InventorySupplier?: InventorySupplierUpdateOneWithoutInventoryItemNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemCreateManyInput = {
    name: string
    description?: string | null
    barcode?: string | null
    serialNumber?: string | null
    categoryId: number
    supplierId?: number | null
    stock?: number
    minStock?: number
    unit?: string | null
    imagePath?: string | null
  }

  export type InventoryItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventorySupplierCreateInput = {
    name: string
    contact?: string | null
    email?: string | null
    phone?: string | null
    InventoryItem?: InventoryItemCreateNestedManyWithoutInventorySupplierInput
  }

  export type InventorySupplierUncheckedCreateInput = {
    id?: number
    name: string
    contact?: string | null
    email?: string | null
    phone?: string | null
    InventoryItem?: InventoryItemUncheckedCreateNestedManyWithoutInventorySupplierInput
  }

  export type InventorySupplierUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    InventoryItem?: InventoryItemUpdateManyWithoutInventorySupplierNestedInput
  }

  export type InventorySupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    InventoryItem?: InventoryItemUncheckedUpdateManyWithoutInventorySupplierNestedInput
  }

  export type InventorySupplierCreateManyInput = {
    name: string
    contact?: string | null
    email?: string | null
    phone?: string | null
  }

  export type InventorySupplierUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventorySupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryTransactionCreateInput = {
    type: string
    qty: number
    date?: Date | string
    note?: string | null
    barcode?: string | null
    InventoryItem: InventoryItemCreateNestedOneWithoutInventoryTransactionInput
    User?: UserCreateNestedOneWithoutInventoryTransactionInput
  }

  export type InventoryTransactionUncheckedCreateInput = {
    id?: number
    itemId: number
    type: string
    qty: number
    userId?: number | null
    date?: Date | string
    note?: string | null
    barcode?: string | null
  }

  export type InventoryTransactionUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    InventoryItem?: InventoryItemUpdateOneRequiredWithoutInventoryTransactionNestedInput
    User?: UserUpdateOneWithoutInventoryTransactionNestedInput
  }

  export type InventoryTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryTransactionCreateManyInput = {
    itemId: number
    type: string
    qty: number
    userId?: number | null
    date?: Date | string
    note?: string | null
    barcode?: string | null
  }

  export type InventoryTransactionUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type it_departmentsCreateInput = {
    name: string
    it_employees?: it_employeesCreateNestedManyWithoutIt_departmentsInput
  }

  export type it_departmentsUncheckedCreateInput = {
    id?: number
    name: string
    it_employees?: it_employeesUncheckedCreateNestedManyWithoutIt_departmentsInput
  }

  export type it_departmentsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    it_employees?: it_employeesUpdateManyWithoutIt_departmentsNestedInput
  }

  export type it_departmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    it_employees?: it_employeesUncheckedUpdateManyWithoutIt_departmentsNestedInput
  }

  export type it_departmentsCreateManyInput = {
    name: string
  }

  export type it_departmentsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type it_departmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type it_employee_rolesCreateInput = {
    it_employees: it_employeesCreateNestedOneWithoutIt_employee_rolesInput
    it_roles: it_rolesCreateNestedOneWithoutIt_employee_rolesInput
  }

  export type it_employee_rolesUncheckedCreateInput = {
    employee_id: number
    role_id: number
  }

  export type it_employee_rolesUpdateInput = {
    it_employees?: it_employeesUpdateOneRequiredWithoutIt_employee_rolesNestedInput
    it_roles?: it_rolesUpdateOneRequiredWithoutIt_employee_rolesNestedInput
  }

  export type it_employee_rolesUncheckedUpdateInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type it_employee_rolesCreateManyInput = {
    employee_id: number
    role_id: number
  }

  export type it_employee_rolesUpdateManyMutationInput = {

  }

  export type it_employee_rolesUncheckedUpdateManyInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type it_employeesCreateInput = {
    first_name: string
    last_name: string
    employee_code: string
    is_dept_head?: boolean
    is_active?: boolean
    it_employee_roles?: it_employee_rolesCreateNestedManyWithoutIt_employeesInput
    it_departments: it_departmentsCreateNestedOneWithoutIt_employeesInput
  }

  export type it_employeesUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    employee_code: string
    department_id: number
    is_dept_head?: boolean
    is_active?: boolean
    it_employee_roles?: it_employee_rolesUncheckedCreateNestedManyWithoutIt_employeesInput
  }

  export type it_employeesUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    it_employee_roles?: it_employee_rolesUpdateManyWithoutIt_employeesNestedInput
    it_departments?: it_departmentsUpdateOneRequiredWithoutIt_employeesNestedInput
  }

  export type it_employeesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    it_employee_roles?: it_employee_rolesUncheckedUpdateManyWithoutIt_employeesNestedInput
  }

  export type it_employeesCreateManyInput = {
    first_name: string
    last_name: string
    employee_code: string
    department_id: number
    is_dept_head?: boolean
    is_active?: boolean
  }

  export type it_employeesUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type it_employeesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type it_rolesCreateInput = {
    name: string
    it_employee_roles?: it_employee_rolesCreateNestedManyWithoutIt_rolesInput
  }

  export type it_rolesUncheckedCreateInput = {
    id?: number
    name: string
    it_employee_roles?: it_employee_rolesUncheckedCreateNestedManyWithoutIt_rolesInput
  }

  export type it_rolesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    it_employee_roles?: it_employee_rolesUpdateManyWithoutIt_rolesNestedInput
  }

  export type it_rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    it_employee_roles?: it_employee_rolesUncheckedUpdateManyWithoutIt_rolesNestedInput
  }

  export type it_rolesCreateManyInput = {
    name: string
  }

  export type it_rolesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type it_rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type KnowledgeBaseCreateInput = {
    title: string
    content: string
    category?: string | null
    tags?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    User: UserCreateNestedOneWithoutKnowledgeBaseInput
    Ticket?: TicketCreateNestedOneWithoutKnowledgeBaseInput
  }

  export type KnowledgeBaseUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    category?: string | null
    tags?: string | null
    isPublic?: boolean
    createdById: number
    linkedTicketId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type KnowledgeBaseUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutKnowledgeBaseNestedInput
    Ticket?: TicketUpdateOneWithoutKnowledgeBaseNestedInput
  }

  export type KnowledgeBaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdById?: IntFieldUpdateOperationsInput | number
    linkedTicketId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseCreateManyInput = {
    title: string
    content: string
    category?: string | null
    tags?: string | null
    isPublic?: boolean
    createdById: number
    linkedTicketId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type KnowledgeBaseUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdById?: IntFieldUpdateOperationsInput | number
    linkedTicketId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseCreateInput = {
    softwareName: string
    licenseKey: string
    expireDate: Date | string
    Asset: AssetCreateNestedOneWithoutLicenseInput
  }

  export type LicenseUncheckedCreateInput = {
    id?: number
    softwareName: string
    licenseKey: string
    expireDate: Date | string
    assetId: number
  }

  export type LicenseUpdateInput = {
    softwareName?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    expireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Asset?: AssetUpdateOneRequiredWithoutLicenseNestedInput
  }

  export type LicenseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    softwareName?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    expireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assetId?: IntFieldUpdateOperationsInput | number
  }

  export type LicenseCreateManyInput = {
    softwareName: string
    licenseKey: string
    expireDate: Date | string
    assetId: number
  }

  export type LicenseUpdateManyMutationInput = {
    softwareName?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    expireDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    softwareName?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    expireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assetId?: IntFieldUpdateOperationsInput | number
  }

  export type MonitorCreateInput = {
    targetName: string
    ipAddress: string
    status: string
    lastCheck: Date | string
    Asset: AssetCreateNestedOneWithoutMonitorInput
  }

  export type MonitorUncheckedCreateInput = {
    id?: number
    targetName: string
    ipAddress: string
    status: string
    lastCheck: Date | string
    assetId: number
  }

  export type MonitorUpdateInput = {
    targetName?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    Asset?: AssetUpdateOneRequiredWithoutMonitorNestedInput
  }

  export type MonitorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetName?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    assetId?: IntFieldUpdateOperationsInput | number
  }

  export type MonitorCreateManyInput = {
    targetName: string
    ipAddress: string
    status: string
    lastCheck: Date | string
    assetId: number
  }

  export type MonitorUpdateManyMutationInput = {
    targetName?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetName?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    assetId?: IntFieldUpdateOperationsInput | number
  }

  export type rolesCreateInput = {
    name: string
    employee_roles?: employee_rolesCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    id?: number
    name: string
    employee_roles?: employee_rolesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    employee_roles?: employee_rolesUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    employee_roles?: employee_rolesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    name: string
  }

  export type rolesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TicketCreateInput = {
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutTicketInput
    Asset?: AssetCreateNestedOneWithoutTicketInput
    User_Ticket_assignedToIdToUser?: UserCreateNestedOneWithoutTicket_Ticket_assignedToIdToUserInput
    User_Ticket_requestedByIdToUser: UserCreateNestedOneWithoutTicket_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutTicketInput
    TicketComment?: TicketCommentCreateNestedManyWithoutTicketInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    assetId?: number | null
    requestedById: number
    assignedToId?: number | null
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutTicketInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutTicketNestedInput
    Asset?: AssetUpdateOneWithoutTicketNestedInput
    User_Ticket_assignedToIdToUser?: UserUpdateOneWithoutTicket_Ticket_assignedToIdToUserNestedInput
    User_Ticket_requestedByIdToUser?: UserUpdateOneRequiredWithoutTicket_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutTicketNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutTicketNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketCreateManyInput = {
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    assetId?: number | null
    requestedById: number
    assignedToId?: number | null
  }

  export type TicketUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TicketAttachmentCreateInput = {
    fileName: string
    filePath: string
    uploadedAt?: Date | string
    Ticket: TicketCreateNestedOneWithoutTicketAttachmentInput
    User: UserCreateNestedOneWithoutTicketAttachmentInput
  }

  export type TicketAttachmentUncheckedCreateInput = {
    id?: number
    fileName: string
    filePath: string
    uploadedAt?: Date | string
    ticketId: number
    uploadedById: number
  }

  export type TicketAttachmentUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ticket?: TicketUpdateOneRequiredWithoutTicketAttachmentNestedInput
    User?: UserUpdateOneRequiredWithoutTicketAttachmentNestedInput
  }

  export type TicketAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: IntFieldUpdateOperationsInput | number
    uploadedById?: IntFieldUpdateOperationsInput | number
  }

  export type TicketAttachmentCreateManyInput = {
    fileName: string
    filePath: string
    uploadedAt?: Date | string
    ticketId: number
    uploadedById: number
  }

  export type TicketAttachmentUpdateManyMutationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: IntFieldUpdateOperationsInput | number
    uploadedById?: IntFieldUpdateOperationsInput | number
  }

  export type TicketCommentCreateInput = {
    content: string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutTicketCommentInput
    Ticket: TicketCreateNestedOneWithoutTicketCommentInput
  }

  export type TicketCommentUncheckedCreateInput = {
    id?: number
    content: string
    createdAt?: Date | string
    ticketId: number
    createdById: number
  }

  export type TicketCommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutTicketCommentNestedInput
    Ticket?: TicketUpdateOneRequiredWithoutTicketCommentNestedInput
  }

  export type TicketCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type TicketCommentCreateManyInput = {
    content: string
    createdAt?: Date | string
    ticketId: number
    createdById: number
  }

  export type TicketCommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type TicketHistoryCreateInput = {
    oldStatus: string
    newStatus: string
    changedAt?: Date | string
    note?: string | null
    User: UserCreateNestedOneWithoutTicketHistoryInput
    Ticket: TicketCreateNestedOneWithoutTicketHistoryInput
  }

  export type TicketHistoryUncheckedCreateInput = {
    id?: number
    ticketId: number
    oldStatus: string
    newStatus: string
    changedById: number
    changedAt?: Date | string
    note?: string | null
  }

  export type TicketHistoryUpdateInput = {
    oldStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneRequiredWithoutTicketHistoryNestedInput
    Ticket?: TicketUpdateOneRequiredWithoutTicketHistoryNestedInput
  }

  export type TicketHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    oldStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedById?: IntFieldUpdateOperationsInput | number
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketHistoryCreateManyInput = {
    ticketId: number
    oldStatus: string
    newStatus: string
    changedById: number
    changedAt?: Date | string
    note?: string | null
  }

  export type TicketHistoryUpdateManyMutationInput = {
    oldStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    oldStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedById?: IntFieldUpdateOperationsInput | number
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Document?: DocumentCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetUncheckedCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Document?: DocumentUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUncheckedUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendorCreateInput = {
    name: string
    contact?: string | null
    email?: string | null
    phone?: string | null
    website?: string | null
    address?: string | null
    Contract?: ContractCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: number
    name: string
    contact?: string | null
    email?: string | null
    phone?: string | null
    website?: string | null
    address?: string | null
    Contract?: ContractUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Contract?: ContractUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Contract?: ContractUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    name: string
    contact?: string | null
    email?: string | null
    phone?: string | null
    website?: string | null
    address?: string | null
  }

  export type VendorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type webmes_UserCreateInput = {
    employeeId: string
    fullName: string
    department: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: webmes_UserRoleCreateNestedManyWithoutUserInput
  }

  export type webmes_UserUncheckedCreateInput = {
    id?: number
    employeeId: string
    fullName: string
    department: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: webmes_UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type webmes_UserUpdateInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: webmes_UserRoleUpdateManyWithoutUserNestedInput
  }

  export type webmes_UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: webmes_UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type webmes_UserCreateManyInput = {
    employeeId: string
    fullName: string
    department: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webmes_UserUpdateManyMutationInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webmes_UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webmes_RoleCreateInput = {
    name: string
    description?: string | null
    permissions?: webmes_RolePermissionCreateNestedManyWithoutRoleInput
    users?: webmes_UserRoleCreateNestedManyWithoutRoleInput
  }

  export type webmes_RoleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    permissions?: webmes_RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    users?: webmes_UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type webmes_RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: webmes_RolePermissionUpdateManyWithoutRoleNestedInput
    users?: webmes_UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type webmes_RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: webmes_RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    users?: webmes_UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type webmes_RoleCreateManyInput = {
    name: string
    description?: string | null
  }

  export type webmes_RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type webmes_RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type webmes_PermissionCreateInput = {
    name: string
    module: string
    roles?: webmes_RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type webmes_PermissionUncheckedCreateInput = {
    id?: number
    name: string
    module: string
    roles?: webmes_RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type webmes_PermissionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    roles?: webmes_RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type webmes_PermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    roles?: webmes_RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type webmes_PermissionCreateManyInput = {
    name: string
    module: string
  }

  export type webmes_PermissionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
  }

  export type webmes_PermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
  }

  export type webmes_UserRoleCreateInput = {
    user: webmes_UserCreateNestedOneWithoutRolesInput
    role: webmes_RoleCreateNestedOneWithoutUsersInput
  }

  export type webmes_UserRoleUncheckedCreateInput = {
    id?: number
    userId: number
    roleId: number
  }

  export type webmes_UserRoleUpdateInput = {
    user?: webmes_UserUpdateOneRequiredWithoutRolesNestedInput
    role?: webmes_RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type webmes_UserRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type webmes_UserRoleCreateManyInput = {
    userId: number
    roleId: number
  }

  export type webmes_UserRoleUpdateManyMutationInput = {

  }

  export type webmes_UserRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type webmes_RolePermissionCreateInput = {
    role: webmes_RoleCreateNestedOneWithoutPermissionsInput
    permission: webmes_PermissionCreateNestedOneWithoutRolesInput
  }

  export type webmes_RolePermissionUncheckedCreateInput = {
    id?: number
    roleId: number
    permissionId: number
  }

  export type webmes_RolePermissionUpdateInput = {
    role?: webmes_RoleUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: webmes_PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type webmes_RolePermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type webmes_RolePermissionCreateManyInput = {
    roleId: number
    permissionId: number
  }

  export type webmes_RolePermissionUpdateManyMutationInput = {

  }

  export type webmes_RolePermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AssetHistoryListRelationFilter = {
    every?: AssetHistoryWhereInput
    some?: AssetHistoryWhereInput
    none?: AssetHistoryWhereInput
  }

  export type LicenseListRelationFilter = {
    every?: LicenseWhereInput
    some?: LicenseWhereInput
    none?: LicenseWhereInput
  }

  export type MonitorNullableRelationFilter = {
    is?: MonitorWhereInput | null
    isNot?: MonitorWhereInput | null
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type ContractListRelationFilter = {
    every?: ContractWhereInput
    some?: ContractWhereInput
    none?: ContractWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AssetHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LicenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrder
    assetTag?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    spec?: SortOrder
    purchaseDate?: SortOrder
    warrantyUntil?: SortOrder
    location?: SortOrder
    status?: SortOrder
    ownerId?: SortOrder
  }

  export type AssetAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrder
    assetTag?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    spec?: SortOrder
    purchaseDate?: SortOrder
    warrantyUntil?: SortOrder
    location?: SortOrder
    status?: SortOrder
    ownerId?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serialNumber?: SortOrder
    assetTag?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    spec?: SortOrder
    purchaseDate?: SortOrder
    warrantyUntil?: SortOrder
    location?: SortOrder
    status?: SortOrder
    ownerId?: SortOrder
  }

  export type AssetSumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AssetRelationFilter = {
    is?: AssetWhereInput
    isNot?: AssetWhereInput
  }

  export type AssetHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    oldOwnerId?: SortOrder
    newOwnerId?: SortOrder
    changedAt?: SortOrder
    reason?: SortOrder
  }

  export type AssetHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    oldOwnerId?: SortOrder
    newOwnerId?: SortOrder
  }

  export type AssetHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    oldOwnerId?: SortOrder
    newOwnerId?: SortOrder
    changedAt?: SortOrder
    reason?: SortOrder
  }

  export type AssetHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    oldOwnerId?: SortOrder
    newOwnerId?: SortOrder
    changedAt?: SortOrder
    reason?: SortOrder
  }

  export type AssetHistorySumOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    oldOwnerId?: SortOrder
    newOwnerId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    recordId?: SortOrder
    userId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    recordId?: SortOrder
    userId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type VendorRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    contractNo?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    vendorId?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    vendorId?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    contractNo?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    vendorId?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    contractNo?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    vendorId?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    vendorId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EmployeesListRelationFilter = {
    every?: employeesWhereInput
    some?: employeesWhereInput
    none?: employeesWhereInput
  }

  export type employeesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type departmentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type departmentsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type departmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type departmentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type departmentsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    filePath?: SortOrder
    version?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    filePath?: SortOrder
    version?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    filePath?: SortOrder
    version?: SortOrder
    permission?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type EmployeesRelationFilter = {
    is?: employeesWhereInput
    isNot?: employeesWhereInput
  }

  export type RolesRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type employee_rolesEmployee_idRole_idCompoundUniqueInput = {
    employee_id: number
    role_id: number
  }

  export type employee_rolesCountOrderByAggregateInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
  }

  export type employee_rolesAvgOrderByAggregateInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
  }

  export type employee_rolesMaxOrderByAggregateInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
  }

  export type employee_rolesMinOrderByAggregateInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
  }

  export type employee_rolesSumOrderByAggregateInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Employee_rolesListRelationFilter = {
    every?: employee_rolesWhereInput
    some?: employee_rolesWhereInput
    none?: employee_rolesWhereInput
  }

  export type DepartmentsRelationFilter = {
    is?: departmentsWhereInput
    isNot?: departmentsWhereInput
  }

  export type employee_rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type employeesCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    employee_code?: SortOrder
    department_id?: SortOrder
    is_dept_head?: SortOrder
    is_active?: SortOrder
  }

  export type employeesAvgOrderByAggregateInput = {
    id?: SortOrder
    department_id?: SortOrder
  }

  export type employeesMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    employee_code?: SortOrder
    department_id?: SortOrder
    is_dept_head?: SortOrder
    is_active?: SortOrder
  }

  export type employeesMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    employee_code?: SortOrder
    department_id?: SortOrder
    is_dept_head?: SortOrder
    is_active?: SortOrder
  }

  export type employeesSumOrderByAggregateInput = {
    id?: SortOrder
    department_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type InventoryCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InventoryCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type InventoryCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type InventoryCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InventoryCategoryRelationFilter = {
    is?: InventoryCategoryWhereInput
    isNot?: InventoryCategoryWhereInput
  }

  export type InventorySupplierNullableRelationFilter = {
    is?: InventorySupplierWhereInput | null
    isNot?: InventorySupplierWhereInput | null
  }

  export type InventoryTransactionListRelationFilter = {
    every?: InventoryTransactionWhereInput
    some?: InventoryTransactionWhereInput
    none?: InventoryTransactionWhereInput
  }

  export type InventoryTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    barcode?: SortOrder
    serialNumber?: SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    unit?: SortOrder
    imagePath?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    barcode?: SortOrder
    serialNumber?: SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    unit?: SortOrder
    imagePath?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    barcode?: SortOrder
    serialNumber?: SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    unit?: SortOrder
    imagePath?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
  }

  export type InventorySupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type InventorySupplierAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InventorySupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type InventorySupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type InventorySupplierSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InventoryItemRelationFilter = {
    is?: InventoryItemWhereInput
    isNot?: InventoryItemWhereInput
  }

  export type InventoryTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    qty?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    note?: SortOrder
    barcode?: SortOrder
  }

  export type InventoryTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    userId?: SortOrder
  }

  export type InventoryTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    qty?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    note?: SortOrder
    barcode?: SortOrder
  }

  export type InventoryTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    qty?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    note?: SortOrder
    barcode?: SortOrder
  }

  export type InventoryTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    userId?: SortOrder
  }

  export type It_employeesListRelationFilter = {
    every?: it_employeesWhereInput
    some?: it_employeesWhereInput
    none?: it_employeesWhereInput
  }

  export type it_employeesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type it_departmentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type it_departmentsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type it_departmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type it_departmentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type it_departmentsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type It_employeesRelationFilter = {
    is?: it_employeesWhereInput
    isNot?: it_employeesWhereInput
  }

  export type It_rolesRelationFilter = {
    is?: it_rolesWhereInput
    isNot?: it_rolesWhereInput
  }

  export type it_employee_rolesEmployee_idRole_idCompoundUniqueInput = {
    employee_id: number
    role_id: number
  }

  export type it_employee_rolesCountOrderByAggregateInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
  }

  export type it_employee_rolesAvgOrderByAggregateInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
  }

  export type it_employee_rolesMaxOrderByAggregateInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
  }

  export type it_employee_rolesMinOrderByAggregateInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
  }

  export type it_employee_rolesSumOrderByAggregateInput = {
    employee_id?: SortOrder
    role_id?: SortOrder
  }

  export type It_employee_rolesListRelationFilter = {
    every?: it_employee_rolesWhereInput
    some?: it_employee_rolesWhereInput
    none?: it_employee_rolesWhereInput
  }

  export type It_departmentsRelationFilter = {
    is?: it_departmentsWhereInput
    isNot?: it_departmentsWhereInput
  }

  export type it_employee_rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type it_employeesCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    employee_code?: SortOrder
    department_id?: SortOrder
    is_dept_head?: SortOrder
    is_active?: SortOrder
  }

  export type it_employeesAvgOrderByAggregateInput = {
    id?: SortOrder
    department_id?: SortOrder
  }

  export type it_employeesMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    employee_code?: SortOrder
    department_id?: SortOrder
    is_dept_head?: SortOrder
    is_active?: SortOrder
  }

  export type it_employeesMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    employee_code?: SortOrder
    department_id?: SortOrder
    is_dept_head?: SortOrder
    is_active?: SortOrder
  }

  export type it_employeesSumOrderByAggregateInput = {
    id?: SortOrder
    department_id?: SortOrder
  }

  export type it_rolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type it_rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type it_rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type it_rolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type it_rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TicketNullableRelationFilter = {
    is?: TicketWhereInput | null
    isNot?: TicketWhereInput | null
  }

  export type KnowledgeBaseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    createdById?: SortOrder
    linkedTicketId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    linkedTicketId?: SortOrder
  }

  export type KnowledgeBaseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    createdById?: SortOrder
    linkedTicketId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    createdById?: SortOrder
    linkedTicketId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    linkedTicketId?: SortOrder
  }

  export type LicenseCountOrderByAggregateInput = {
    id?: SortOrder
    softwareName?: SortOrder
    licenseKey?: SortOrder
    expireDate?: SortOrder
    assetId?: SortOrder
  }

  export type LicenseAvgOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
  }

  export type LicenseMaxOrderByAggregateInput = {
    id?: SortOrder
    softwareName?: SortOrder
    licenseKey?: SortOrder
    expireDate?: SortOrder
    assetId?: SortOrder
  }

  export type LicenseMinOrderByAggregateInput = {
    id?: SortOrder
    softwareName?: SortOrder
    licenseKey?: SortOrder
    expireDate?: SortOrder
    assetId?: SortOrder
  }

  export type LicenseSumOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
  }

  export type MonitorCountOrderByAggregateInput = {
    id?: SortOrder
    targetName?: SortOrder
    ipAddress?: SortOrder
    status?: SortOrder
    lastCheck?: SortOrder
    assetId?: SortOrder
  }

  export type MonitorAvgOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
  }

  export type MonitorMaxOrderByAggregateInput = {
    id?: SortOrder
    targetName?: SortOrder
    ipAddress?: SortOrder
    status?: SortOrder
    lastCheck?: SortOrder
    assetId?: SortOrder
  }

  export type MonitorMinOrderByAggregateInput = {
    id?: SortOrder
    targetName?: SortOrder
    ipAddress?: SortOrder
    status?: SortOrder
    lastCheck?: SortOrder
    assetId?: SortOrder
  }

  export type MonitorSumOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type KnowledgeBaseListRelationFilter = {
    every?: KnowledgeBaseWhereInput
    some?: KnowledgeBaseWhereInput
    none?: KnowledgeBaseWhereInput
  }

  export type AssetNullableRelationFilter = {
    is?: AssetWhereInput | null
    isNot?: AssetWhereInput | null
  }

  export type TicketAttachmentListRelationFilter = {
    every?: TicketAttachmentWhereInput
    some?: TicketAttachmentWhereInput
    none?: TicketAttachmentWhereInput
  }

  export type TicketCommentListRelationFilter = {
    every?: TicketCommentWhereInput
    some?: TicketCommentWhereInput
    none?: TicketCommentWhereInput
  }

  export type TicketHistoryListRelationFilter = {
    every?: TicketHistoryWhereInput
    some?: TicketHistoryWhereInput
    none?: TicketHistoryWhereInput
  }

  export type KnowledgeBaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resolutionNote?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    assetId?: SortOrder
    requestedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type TicketAvgOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    requestedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resolutionNote?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    assetId?: SortOrder
    requestedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resolutionNote?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    assetId?: SortOrder
    requestedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type TicketSumOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    requestedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type TicketRelationFilter = {
    is?: TicketWhereInput
    isNot?: TicketWhereInput
  }

  export type TicketAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    ticketId?: SortOrder
    uploadedById?: SortOrder
  }

  export type TicketAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    uploadedById?: SortOrder
  }

  export type TicketAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    ticketId?: SortOrder
    uploadedById?: SortOrder
  }

  export type TicketAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    ticketId?: SortOrder
    uploadedById?: SortOrder
  }

  export type TicketAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    uploadedById?: SortOrder
  }

  export type TicketCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
    createdById?: SortOrder
  }

  export type TicketCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    createdById?: SortOrder
  }

  export type TicketCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
    createdById?: SortOrder
  }

  export type TicketCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    ticketId?: SortOrder
    createdById?: SortOrder
  }

  export type TicketCommentSumOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    createdById?: SortOrder
  }

  export type TicketHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
    note?: SortOrder
  }

  export type TicketHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    changedById?: SortOrder
  }

  export type TicketHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
    note?: SortOrder
  }

  export type TicketHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
    note?: SortOrder
  }

  export type TicketHistorySumOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    changedById?: SortOrder
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    empId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    empId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    empId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    address?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    address?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    address?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Webmes_UserRoleListRelationFilter = {
    every?: webmes_UserRoleWhereInput
    some?: webmes_UserRoleWhereInput
    none?: webmes_UserRoleWhereInput
  }

  export type webmes_UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type webmes_UserCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fullName?: SortOrder
    department?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type webmes_UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type webmes_UserMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fullName?: SortOrder
    department?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type webmes_UserMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fullName?: SortOrder
    department?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type webmes_UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Webmes_RolePermissionListRelationFilter = {
    every?: webmes_RolePermissionWhereInput
    some?: webmes_RolePermissionWhereInput
    none?: webmes_RolePermissionWhereInput
  }

  export type webmes_RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type webmes_RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type webmes_RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type webmes_RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type webmes_RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type webmes_RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type webmes_PermissionNameModuleCompoundUniqueInput = {
    name: string
    module: string
  }

  export type webmes_PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    module?: SortOrder
  }

  export type webmes_PermissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type webmes_PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    module?: SortOrder
  }

  export type webmes_PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    module?: SortOrder
  }

  export type webmes_PermissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Webmes_UserRelationFilter = {
    is?: webmes_UserWhereInput
    isNot?: webmes_UserWhereInput
  }

  export type Webmes_RoleRelationFilter = {
    is?: webmes_RoleWhereInput
    isNot?: webmes_RoleWhereInput
  }

  export type webmes_UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: number
    roleId: number
  }

  export type webmes_UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type webmes_UserRoleAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type webmes_UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type webmes_UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type webmes_UserRoleSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type Webmes_PermissionRelationFilter = {
    is?: webmes_PermissionWhereInput
    isNot?: webmes_PermissionWhereInput
  }

  export type webmes_RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: number
    permissionId: number
  }

  export type webmes_RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type webmes_RolePermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type webmes_RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type webmes_RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type webmes_RolePermissionSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type UserCreateNestedOneWithoutAssetInput = {
    create?: XOR<UserCreateWithoutAssetInput, UserUncheckedCreateWithoutAssetInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetInput
    connect?: UserWhereUniqueInput
  }

  export type AssetHistoryCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetHistoryCreateWithoutAssetInput, AssetHistoryUncheckedCreateWithoutAssetInput> | AssetHistoryCreateWithoutAssetInput[] | AssetHistoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutAssetInput | AssetHistoryCreateOrConnectWithoutAssetInput[]
    createMany?: AssetHistoryCreateManyAssetInputEnvelope
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
  }

  export type LicenseCreateNestedManyWithoutAssetInput = {
    create?: XOR<LicenseCreateWithoutAssetInput, LicenseUncheckedCreateWithoutAssetInput> | LicenseCreateWithoutAssetInput[] | LicenseUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutAssetInput | LicenseCreateOrConnectWithoutAssetInput[]
    createMany?: LicenseCreateManyAssetInputEnvelope
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
  }

  export type MonitorCreateNestedOneWithoutAssetInput = {
    create?: XOR<MonitorCreateWithoutAssetInput, MonitorUncheckedCreateWithoutAssetInput>
    connectOrCreate?: MonitorCreateOrConnectWithoutAssetInput
    connect?: MonitorWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutAssetInput = {
    create?: XOR<TicketCreateWithoutAssetInput, TicketUncheckedCreateWithoutAssetInput> | TicketCreateWithoutAssetInput[] | TicketUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssetInput | TicketCreateOrConnectWithoutAssetInput[]
    createMany?: TicketCreateManyAssetInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type ContractCreateNestedManyWithoutAssetInput = {
    create?: XOR<ContractCreateWithoutAssetInput, ContractUncheckedCreateWithoutAssetInput> | ContractCreateWithoutAssetInput[] | ContractUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutAssetInput | ContractCreateOrConnectWithoutAssetInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type AssetHistoryUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetHistoryCreateWithoutAssetInput, AssetHistoryUncheckedCreateWithoutAssetInput> | AssetHistoryCreateWithoutAssetInput[] | AssetHistoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutAssetInput | AssetHistoryCreateOrConnectWithoutAssetInput[]
    createMany?: AssetHistoryCreateManyAssetInputEnvelope
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
  }

  export type LicenseUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<LicenseCreateWithoutAssetInput, LicenseUncheckedCreateWithoutAssetInput> | LicenseCreateWithoutAssetInput[] | LicenseUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutAssetInput | LicenseCreateOrConnectWithoutAssetInput[]
    createMany?: LicenseCreateManyAssetInputEnvelope
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
  }

  export type MonitorUncheckedCreateNestedOneWithoutAssetInput = {
    create?: XOR<MonitorCreateWithoutAssetInput, MonitorUncheckedCreateWithoutAssetInput>
    connectOrCreate?: MonitorCreateOrConnectWithoutAssetInput
    connect?: MonitorWhereUniqueInput
  }

  export type TicketUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<TicketCreateWithoutAssetInput, TicketUncheckedCreateWithoutAssetInput> | TicketCreateWithoutAssetInput[] | TicketUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssetInput | TicketCreateOrConnectWithoutAssetInput[]
    createMany?: TicketCreateManyAssetInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<ContractCreateWithoutAssetInput, ContractUncheckedCreateWithoutAssetInput> | ContractCreateWithoutAssetInput[] | ContractUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutAssetInput | ContractCreateOrConnectWithoutAssetInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneWithoutAssetNestedInput = {
    create?: XOR<UserCreateWithoutAssetInput, UserUncheckedCreateWithoutAssetInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetInput
    upsert?: UserUpsertWithoutAssetInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssetInput, UserUpdateWithoutAssetInput>, UserUncheckedUpdateWithoutAssetInput>
  }

  export type AssetHistoryUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetHistoryCreateWithoutAssetInput, AssetHistoryUncheckedCreateWithoutAssetInput> | AssetHistoryCreateWithoutAssetInput[] | AssetHistoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutAssetInput | AssetHistoryCreateOrConnectWithoutAssetInput[]
    upsert?: AssetHistoryUpsertWithWhereUniqueWithoutAssetInput | AssetHistoryUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetHistoryCreateManyAssetInputEnvelope
    set?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    disconnect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    delete?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    update?: AssetHistoryUpdateWithWhereUniqueWithoutAssetInput | AssetHistoryUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetHistoryUpdateManyWithWhereWithoutAssetInput | AssetHistoryUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetHistoryScalarWhereInput | AssetHistoryScalarWhereInput[]
  }

  export type LicenseUpdateManyWithoutAssetNestedInput = {
    create?: XOR<LicenseCreateWithoutAssetInput, LicenseUncheckedCreateWithoutAssetInput> | LicenseCreateWithoutAssetInput[] | LicenseUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutAssetInput | LicenseCreateOrConnectWithoutAssetInput[]
    upsert?: LicenseUpsertWithWhereUniqueWithoutAssetInput | LicenseUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: LicenseCreateManyAssetInputEnvelope
    set?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    disconnect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    delete?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    update?: LicenseUpdateWithWhereUniqueWithoutAssetInput | LicenseUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: LicenseUpdateManyWithWhereWithoutAssetInput | LicenseUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
  }

  export type MonitorUpdateOneWithoutAssetNestedInput = {
    create?: XOR<MonitorCreateWithoutAssetInput, MonitorUncheckedCreateWithoutAssetInput>
    connectOrCreate?: MonitorCreateOrConnectWithoutAssetInput
    upsert?: MonitorUpsertWithoutAssetInput
    disconnect?: MonitorWhereInput | boolean
    delete?: MonitorWhereInput | boolean
    connect?: MonitorWhereUniqueInput
    update?: XOR<XOR<MonitorUpdateToOneWithWhereWithoutAssetInput, MonitorUpdateWithoutAssetInput>, MonitorUncheckedUpdateWithoutAssetInput>
  }

  export type TicketUpdateManyWithoutAssetNestedInput = {
    create?: XOR<TicketCreateWithoutAssetInput, TicketUncheckedCreateWithoutAssetInput> | TicketCreateWithoutAssetInput[] | TicketUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssetInput | TicketCreateOrConnectWithoutAssetInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssetInput | TicketUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: TicketCreateManyAssetInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssetInput | TicketUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssetInput | TicketUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type ContractUpdateManyWithoutAssetNestedInput = {
    create?: XOR<ContractCreateWithoutAssetInput, ContractUncheckedCreateWithoutAssetInput> | ContractCreateWithoutAssetInput[] | ContractUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutAssetInput | ContractCreateOrConnectWithoutAssetInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutAssetInput | ContractUpsertWithWhereUniqueWithoutAssetInput[]
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutAssetInput | ContractUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutAssetInput | ContractUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetHistoryCreateWithoutAssetInput, AssetHistoryUncheckedCreateWithoutAssetInput> | AssetHistoryCreateWithoutAssetInput[] | AssetHistoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutAssetInput | AssetHistoryCreateOrConnectWithoutAssetInput[]
    upsert?: AssetHistoryUpsertWithWhereUniqueWithoutAssetInput | AssetHistoryUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetHistoryCreateManyAssetInputEnvelope
    set?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    disconnect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    delete?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    update?: AssetHistoryUpdateWithWhereUniqueWithoutAssetInput | AssetHistoryUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetHistoryUpdateManyWithWhereWithoutAssetInput | AssetHistoryUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetHistoryScalarWhereInput | AssetHistoryScalarWhereInput[]
  }

  export type LicenseUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<LicenseCreateWithoutAssetInput, LicenseUncheckedCreateWithoutAssetInput> | LicenseCreateWithoutAssetInput[] | LicenseUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutAssetInput | LicenseCreateOrConnectWithoutAssetInput[]
    upsert?: LicenseUpsertWithWhereUniqueWithoutAssetInput | LicenseUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: LicenseCreateManyAssetInputEnvelope
    set?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    disconnect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    delete?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    update?: LicenseUpdateWithWhereUniqueWithoutAssetInput | LicenseUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: LicenseUpdateManyWithWhereWithoutAssetInput | LicenseUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
  }

  export type MonitorUncheckedUpdateOneWithoutAssetNestedInput = {
    create?: XOR<MonitorCreateWithoutAssetInput, MonitorUncheckedCreateWithoutAssetInput>
    connectOrCreate?: MonitorCreateOrConnectWithoutAssetInput
    upsert?: MonitorUpsertWithoutAssetInput
    disconnect?: MonitorWhereInput | boolean
    delete?: MonitorWhereInput | boolean
    connect?: MonitorWhereUniqueInput
    update?: XOR<XOR<MonitorUpdateToOneWithWhereWithoutAssetInput, MonitorUpdateWithoutAssetInput>, MonitorUncheckedUpdateWithoutAssetInput>
  }

  export type TicketUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<TicketCreateWithoutAssetInput, TicketUncheckedCreateWithoutAssetInput> | TicketCreateWithoutAssetInput[] | TicketUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssetInput | TicketCreateOrConnectWithoutAssetInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssetInput | TicketUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: TicketCreateManyAssetInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssetInput | TicketUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssetInput | TicketUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<ContractCreateWithoutAssetInput, ContractUncheckedCreateWithoutAssetInput> | ContractCreateWithoutAssetInput[] | ContractUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutAssetInput | ContractCreateOrConnectWithoutAssetInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutAssetInput | ContractUpsertWithWhereUniqueWithoutAssetInput[]
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutAssetInput | ContractUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutAssetInput | ContractUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type AssetCreateNestedOneWithoutAssetHistoryInput = {
    create?: XOR<AssetCreateWithoutAssetHistoryInput, AssetUncheckedCreateWithoutAssetHistoryInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAssetHistoryInput
    connect?: AssetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput = {
    create?: XOR<UserCreateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput, UserUncheckedCreateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput = {
    create?: XOR<UserCreateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput, UserUncheckedCreateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AssetUpdateOneRequiredWithoutAssetHistoryNestedInput = {
    create?: XOR<AssetCreateWithoutAssetHistoryInput, AssetUncheckedCreateWithoutAssetHistoryInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAssetHistoryInput
    upsert?: AssetUpsertWithoutAssetHistoryInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutAssetHistoryInput, AssetUpdateWithoutAssetHistoryInput>, AssetUncheckedUpdateWithoutAssetHistoryInput>
  }

  export type UserUpdateOneWithoutAssetHistory_AssetHistory_newOwnerIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput, UserUncheckedCreateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput
    upsert?: UserUpsertWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput, UserUpdateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput>, UserUncheckedUpdateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput>
  }

  export type UserUpdateOneWithoutAssetHistory_AssetHistory_oldOwnerIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput, UserUncheckedCreateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput
    upsert?: UserUpsertWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput, UserUpdateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput>, UserUncheckedUpdateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput>
  }

  export type UserCreateNestedOneWithoutAuditLogInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput
    upsert?: UserUpsertWithoutAuditLogInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogInput, UserUpdateWithoutAuditLogInput>, UserUncheckedUpdateWithoutAuditLogInput>
  }

  export type VendorCreateNestedOneWithoutContractInput = {
    create?: XOR<VendorCreateWithoutContractInput, VendorUncheckedCreateWithoutContractInput>
    connectOrCreate?: VendorCreateOrConnectWithoutContractInput
    connect?: VendorWhereUniqueInput
  }

  export type AssetCreateNestedManyWithoutContractInput = {
    create?: XOR<AssetCreateWithoutContractInput, AssetUncheckedCreateWithoutContractInput> | AssetCreateWithoutContractInput[] | AssetUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutContractInput | AssetCreateOrConnectWithoutContractInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<AssetCreateWithoutContractInput, AssetUncheckedCreateWithoutContractInput> | AssetCreateWithoutContractInput[] | AssetUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutContractInput | AssetCreateOrConnectWithoutContractInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VendorUpdateOneRequiredWithoutContractNestedInput = {
    create?: XOR<VendorCreateWithoutContractInput, VendorUncheckedCreateWithoutContractInput>
    connectOrCreate?: VendorCreateOrConnectWithoutContractInput
    upsert?: VendorUpsertWithoutContractInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutContractInput, VendorUpdateWithoutContractInput>, VendorUncheckedUpdateWithoutContractInput>
  }

  export type AssetUpdateManyWithoutContractNestedInput = {
    create?: XOR<AssetCreateWithoutContractInput, AssetUncheckedCreateWithoutContractInput> | AssetCreateWithoutContractInput[] | AssetUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutContractInput | AssetCreateOrConnectWithoutContractInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutContractInput | AssetUpsertWithWhereUniqueWithoutContractInput[]
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutContractInput | AssetUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutContractInput | AssetUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<AssetCreateWithoutContractInput, AssetUncheckedCreateWithoutContractInput> | AssetCreateWithoutContractInput[] | AssetUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutContractInput | AssetCreateOrConnectWithoutContractInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutContractInput | AssetUpsertWithWhereUniqueWithoutContractInput[]
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutContractInput | AssetUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutContractInput | AssetUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type employeesCreateNestedManyWithoutDepartmentsInput = {
    create?: XOR<employeesCreateWithoutDepartmentsInput, employeesUncheckedCreateWithoutDepartmentsInput> | employeesCreateWithoutDepartmentsInput[] | employeesUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: employeesCreateOrConnectWithoutDepartmentsInput | employeesCreateOrConnectWithoutDepartmentsInput[]
    createMany?: employeesCreateManyDepartmentsInputEnvelope
    connect?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
  }

  export type employeesUncheckedCreateNestedManyWithoutDepartmentsInput = {
    create?: XOR<employeesCreateWithoutDepartmentsInput, employeesUncheckedCreateWithoutDepartmentsInput> | employeesCreateWithoutDepartmentsInput[] | employeesUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: employeesCreateOrConnectWithoutDepartmentsInput | employeesCreateOrConnectWithoutDepartmentsInput[]
    createMany?: employeesCreateManyDepartmentsInputEnvelope
    connect?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
  }

  export type employeesUpdateManyWithoutDepartmentsNestedInput = {
    create?: XOR<employeesCreateWithoutDepartmentsInput, employeesUncheckedCreateWithoutDepartmentsInput> | employeesCreateWithoutDepartmentsInput[] | employeesUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: employeesCreateOrConnectWithoutDepartmentsInput | employeesCreateOrConnectWithoutDepartmentsInput[]
    upsert?: employeesUpsertWithWhereUniqueWithoutDepartmentsInput | employeesUpsertWithWhereUniqueWithoutDepartmentsInput[]
    createMany?: employeesCreateManyDepartmentsInputEnvelope
    set?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    disconnect?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    delete?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    connect?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    update?: employeesUpdateWithWhereUniqueWithoutDepartmentsInput | employeesUpdateWithWhereUniqueWithoutDepartmentsInput[]
    updateMany?: employeesUpdateManyWithWhereWithoutDepartmentsInput | employeesUpdateManyWithWhereWithoutDepartmentsInput[]
    deleteMany?: employeesScalarWhereInput | employeesScalarWhereInput[]
  }

  export type employeesUncheckedUpdateManyWithoutDepartmentsNestedInput = {
    create?: XOR<employeesCreateWithoutDepartmentsInput, employeesUncheckedCreateWithoutDepartmentsInput> | employeesCreateWithoutDepartmentsInput[] | employeesUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: employeesCreateOrConnectWithoutDepartmentsInput | employeesCreateOrConnectWithoutDepartmentsInput[]
    upsert?: employeesUpsertWithWhereUniqueWithoutDepartmentsInput | employeesUpsertWithWhereUniqueWithoutDepartmentsInput[]
    createMany?: employeesCreateManyDepartmentsInputEnvelope
    set?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    disconnect?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    delete?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    connect?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    update?: employeesUpdateWithWhereUniqueWithoutDepartmentsInput | employeesUpdateWithWhereUniqueWithoutDepartmentsInput[]
    updateMany?: employeesUpdateManyWithWhereWithoutDepartmentsInput | employeesUpdateManyWithWhereWithoutDepartmentsInput[]
    deleteMany?: employeesScalarWhereInput | employeesScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDocumentInput = {
    create?: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDocumentNestedInput = {
    create?: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentInput
    upsert?: UserUpsertWithoutDocumentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentInput, UserUpdateWithoutDocumentInput>, UserUncheckedUpdateWithoutDocumentInput>
  }

  export type employeesCreateNestedOneWithoutEmployee_rolesInput = {
    create?: XOR<employeesCreateWithoutEmployee_rolesInput, employeesUncheckedCreateWithoutEmployee_rolesInput>
    connectOrCreate?: employeesCreateOrConnectWithoutEmployee_rolesInput
    connect?: employeesWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutEmployee_rolesInput = {
    create?: XOR<rolesCreateWithoutEmployee_rolesInput, rolesUncheckedCreateWithoutEmployee_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutEmployee_rolesInput
    connect?: rolesWhereUniqueInput
  }

  export type employeesUpdateOneRequiredWithoutEmployee_rolesNestedInput = {
    create?: XOR<employeesCreateWithoutEmployee_rolesInput, employeesUncheckedCreateWithoutEmployee_rolesInput>
    connectOrCreate?: employeesCreateOrConnectWithoutEmployee_rolesInput
    upsert?: employeesUpsertWithoutEmployee_rolesInput
    connect?: employeesWhereUniqueInput
    update?: XOR<XOR<employeesUpdateToOneWithWhereWithoutEmployee_rolesInput, employeesUpdateWithoutEmployee_rolesInput>, employeesUncheckedUpdateWithoutEmployee_rolesInput>
  }

  export type rolesUpdateOneRequiredWithoutEmployee_rolesNestedInput = {
    create?: XOR<rolesCreateWithoutEmployee_rolesInput, rolesUncheckedCreateWithoutEmployee_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutEmployee_rolesInput
    upsert?: rolesUpsertWithoutEmployee_rolesInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutEmployee_rolesInput, rolesUpdateWithoutEmployee_rolesInput>, rolesUncheckedUpdateWithoutEmployee_rolesInput>
  }

  export type employee_rolesCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<employee_rolesCreateWithoutEmployeesInput, employee_rolesUncheckedCreateWithoutEmployeesInput> | employee_rolesCreateWithoutEmployeesInput[] | employee_rolesUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: employee_rolesCreateOrConnectWithoutEmployeesInput | employee_rolesCreateOrConnectWithoutEmployeesInput[]
    createMany?: employee_rolesCreateManyEmployeesInputEnvelope
    connect?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
  }

  export type departmentsCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<departmentsCreateWithoutEmployeesInput, departmentsUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: departmentsCreateOrConnectWithoutEmployeesInput
    connect?: departmentsWhereUniqueInput
  }

  export type employee_rolesUncheckedCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<employee_rolesCreateWithoutEmployeesInput, employee_rolesUncheckedCreateWithoutEmployeesInput> | employee_rolesCreateWithoutEmployeesInput[] | employee_rolesUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: employee_rolesCreateOrConnectWithoutEmployeesInput | employee_rolesCreateOrConnectWithoutEmployeesInput[]
    createMany?: employee_rolesCreateManyEmployeesInputEnvelope
    connect?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type employee_rolesUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<employee_rolesCreateWithoutEmployeesInput, employee_rolesUncheckedCreateWithoutEmployeesInput> | employee_rolesCreateWithoutEmployeesInput[] | employee_rolesUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: employee_rolesCreateOrConnectWithoutEmployeesInput | employee_rolesCreateOrConnectWithoutEmployeesInput[]
    upsert?: employee_rolesUpsertWithWhereUniqueWithoutEmployeesInput | employee_rolesUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: employee_rolesCreateManyEmployeesInputEnvelope
    set?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    disconnect?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    delete?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    connect?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    update?: employee_rolesUpdateWithWhereUniqueWithoutEmployeesInput | employee_rolesUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: employee_rolesUpdateManyWithWhereWithoutEmployeesInput | employee_rolesUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: employee_rolesScalarWhereInput | employee_rolesScalarWhereInput[]
  }

  export type departmentsUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<departmentsCreateWithoutEmployeesInput, departmentsUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: departmentsCreateOrConnectWithoutEmployeesInput
    upsert?: departmentsUpsertWithoutEmployeesInput
    connect?: departmentsWhereUniqueInput
    update?: XOR<XOR<departmentsUpdateToOneWithWhereWithoutEmployeesInput, departmentsUpdateWithoutEmployeesInput>, departmentsUncheckedUpdateWithoutEmployeesInput>
  }

  export type employee_rolesUncheckedUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<employee_rolesCreateWithoutEmployeesInput, employee_rolesUncheckedCreateWithoutEmployeesInput> | employee_rolesCreateWithoutEmployeesInput[] | employee_rolesUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: employee_rolesCreateOrConnectWithoutEmployeesInput | employee_rolesCreateOrConnectWithoutEmployeesInput[]
    upsert?: employee_rolesUpsertWithWhereUniqueWithoutEmployeesInput | employee_rolesUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: employee_rolesCreateManyEmployeesInputEnvelope
    set?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    disconnect?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    delete?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    connect?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    update?: employee_rolesUpdateWithWhereUniqueWithoutEmployeesInput | employee_rolesUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: employee_rolesUpdateManyWithWhereWithoutEmployeesInput | employee_rolesUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: employee_rolesScalarWhereInput | employee_rolesScalarWhereInput[]
  }

  export type InventoryItemCreateNestedManyWithoutInventoryCategoryInput = {
    create?: XOR<InventoryItemCreateWithoutInventoryCategoryInput, InventoryItemUncheckedCreateWithoutInventoryCategoryInput> | InventoryItemCreateWithoutInventoryCategoryInput[] | InventoryItemUncheckedCreateWithoutInventoryCategoryInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutInventoryCategoryInput | InventoryItemCreateOrConnectWithoutInventoryCategoryInput[]
    createMany?: InventoryItemCreateManyInventoryCategoryInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutInventoryCategoryInput = {
    create?: XOR<InventoryItemCreateWithoutInventoryCategoryInput, InventoryItemUncheckedCreateWithoutInventoryCategoryInput> | InventoryItemCreateWithoutInventoryCategoryInput[] | InventoryItemUncheckedCreateWithoutInventoryCategoryInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutInventoryCategoryInput | InventoryItemCreateOrConnectWithoutInventoryCategoryInput[]
    createMany?: InventoryItemCreateManyInventoryCategoryInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryItemUpdateManyWithoutInventoryCategoryNestedInput = {
    create?: XOR<InventoryItemCreateWithoutInventoryCategoryInput, InventoryItemUncheckedCreateWithoutInventoryCategoryInput> | InventoryItemCreateWithoutInventoryCategoryInput[] | InventoryItemUncheckedCreateWithoutInventoryCategoryInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutInventoryCategoryInput | InventoryItemCreateOrConnectWithoutInventoryCategoryInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutInventoryCategoryInput | InventoryItemUpsertWithWhereUniqueWithoutInventoryCategoryInput[]
    createMany?: InventoryItemCreateManyInventoryCategoryInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutInventoryCategoryInput | InventoryItemUpdateWithWhereUniqueWithoutInventoryCategoryInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutInventoryCategoryInput | InventoryItemUpdateManyWithWhereWithoutInventoryCategoryInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutInventoryCategoryNestedInput = {
    create?: XOR<InventoryItemCreateWithoutInventoryCategoryInput, InventoryItemUncheckedCreateWithoutInventoryCategoryInput> | InventoryItemCreateWithoutInventoryCategoryInput[] | InventoryItemUncheckedCreateWithoutInventoryCategoryInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutInventoryCategoryInput | InventoryItemCreateOrConnectWithoutInventoryCategoryInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutInventoryCategoryInput | InventoryItemUpsertWithWhereUniqueWithoutInventoryCategoryInput[]
    createMany?: InventoryItemCreateManyInventoryCategoryInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutInventoryCategoryInput | InventoryItemUpdateWithWhereUniqueWithoutInventoryCategoryInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutInventoryCategoryInput | InventoryItemUpdateManyWithWhereWithoutInventoryCategoryInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryCategoryCreateNestedOneWithoutInventoryItemInput = {
    create?: XOR<InventoryCategoryCreateWithoutInventoryItemInput, InventoryCategoryUncheckedCreateWithoutInventoryItemInput>
    connectOrCreate?: InventoryCategoryCreateOrConnectWithoutInventoryItemInput
    connect?: InventoryCategoryWhereUniqueInput
  }

  export type InventorySupplierCreateNestedOneWithoutInventoryItemInput = {
    create?: XOR<InventorySupplierCreateWithoutInventoryItemInput, InventorySupplierUncheckedCreateWithoutInventoryItemInput>
    connectOrCreate?: InventorySupplierCreateOrConnectWithoutInventoryItemInput
    connect?: InventorySupplierWhereUniqueInput
  }

  export type InventoryTransactionCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<InventoryTransactionCreateWithoutInventoryItemInput, InventoryTransactionUncheckedCreateWithoutInventoryItemInput> | InventoryTransactionCreateWithoutInventoryItemInput[] | InventoryTransactionUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutInventoryItemInput | InventoryTransactionCreateOrConnectWithoutInventoryItemInput[]
    createMany?: InventoryTransactionCreateManyInventoryItemInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type InventoryTransactionUncheckedCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<InventoryTransactionCreateWithoutInventoryItemInput, InventoryTransactionUncheckedCreateWithoutInventoryItemInput> | InventoryTransactionCreateWithoutInventoryItemInput[] | InventoryTransactionUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutInventoryItemInput | InventoryTransactionCreateOrConnectWithoutInventoryItemInput[]
    createMany?: InventoryTransactionCreateManyInventoryItemInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type InventoryCategoryUpdateOneRequiredWithoutInventoryItemNestedInput = {
    create?: XOR<InventoryCategoryCreateWithoutInventoryItemInput, InventoryCategoryUncheckedCreateWithoutInventoryItemInput>
    connectOrCreate?: InventoryCategoryCreateOrConnectWithoutInventoryItemInput
    upsert?: InventoryCategoryUpsertWithoutInventoryItemInput
    connect?: InventoryCategoryWhereUniqueInput
    update?: XOR<XOR<InventoryCategoryUpdateToOneWithWhereWithoutInventoryItemInput, InventoryCategoryUpdateWithoutInventoryItemInput>, InventoryCategoryUncheckedUpdateWithoutInventoryItemInput>
  }

  export type InventorySupplierUpdateOneWithoutInventoryItemNestedInput = {
    create?: XOR<InventorySupplierCreateWithoutInventoryItemInput, InventorySupplierUncheckedCreateWithoutInventoryItemInput>
    connectOrCreate?: InventorySupplierCreateOrConnectWithoutInventoryItemInput
    upsert?: InventorySupplierUpsertWithoutInventoryItemInput
    disconnect?: InventorySupplierWhereInput | boolean
    delete?: InventorySupplierWhereInput | boolean
    connect?: InventorySupplierWhereUniqueInput
    update?: XOR<XOR<InventorySupplierUpdateToOneWithWhereWithoutInventoryItemInput, InventorySupplierUpdateWithoutInventoryItemInput>, InventorySupplierUncheckedUpdateWithoutInventoryItemInput>
  }

  export type InventoryTransactionUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutInventoryItemInput, InventoryTransactionUncheckedCreateWithoutInventoryItemInput> | InventoryTransactionCreateWithoutInventoryItemInput[] | InventoryTransactionUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutInventoryItemInput | InventoryTransactionCreateOrConnectWithoutInventoryItemInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutInventoryItemInput | InventoryTransactionUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: InventoryTransactionCreateManyInventoryItemInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutInventoryItemInput | InventoryTransactionUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutInventoryItemInput | InventoryTransactionUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutInventoryItemInput, InventoryTransactionUncheckedCreateWithoutInventoryItemInput> | InventoryTransactionCreateWithoutInventoryItemInput[] | InventoryTransactionUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutInventoryItemInput | InventoryTransactionCreateOrConnectWithoutInventoryItemInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutInventoryItemInput | InventoryTransactionUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: InventoryTransactionCreateManyInventoryItemInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutInventoryItemInput | InventoryTransactionUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutInventoryItemInput | InventoryTransactionUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type InventoryItemCreateNestedManyWithoutInventorySupplierInput = {
    create?: XOR<InventoryItemCreateWithoutInventorySupplierInput, InventoryItemUncheckedCreateWithoutInventorySupplierInput> | InventoryItemCreateWithoutInventorySupplierInput[] | InventoryItemUncheckedCreateWithoutInventorySupplierInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutInventorySupplierInput | InventoryItemCreateOrConnectWithoutInventorySupplierInput[]
    createMany?: InventoryItemCreateManyInventorySupplierInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutInventorySupplierInput = {
    create?: XOR<InventoryItemCreateWithoutInventorySupplierInput, InventoryItemUncheckedCreateWithoutInventorySupplierInput> | InventoryItemCreateWithoutInventorySupplierInput[] | InventoryItemUncheckedCreateWithoutInventorySupplierInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutInventorySupplierInput | InventoryItemCreateOrConnectWithoutInventorySupplierInput[]
    createMany?: InventoryItemCreateManyInventorySupplierInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryItemUpdateManyWithoutInventorySupplierNestedInput = {
    create?: XOR<InventoryItemCreateWithoutInventorySupplierInput, InventoryItemUncheckedCreateWithoutInventorySupplierInput> | InventoryItemCreateWithoutInventorySupplierInput[] | InventoryItemUncheckedCreateWithoutInventorySupplierInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutInventorySupplierInput | InventoryItemCreateOrConnectWithoutInventorySupplierInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutInventorySupplierInput | InventoryItemUpsertWithWhereUniqueWithoutInventorySupplierInput[]
    createMany?: InventoryItemCreateManyInventorySupplierInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutInventorySupplierInput | InventoryItemUpdateWithWhereUniqueWithoutInventorySupplierInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutInventorySupplierInput | InventoryItemUpdateManyWithWhereWithoutInventorySupplierInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutInventorySupplierNestedInput = {
    create?: XOR<InventoryItemCreateWithoutInventorySupplierInput, InventoryItemUncheckedCreateWithoutInventorySupplierInput> | InventoryItemCreateWithoutInventorySupplierInput[] | InventoryItemUncheckedCreateWithoutInventorySupplierInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutInventorySupplierInput | InventoryItemCreateOrConnectWithoutInventorySupplierInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutInventorySupplierInput | InventoryItemUpsertWithWhereUniqueWithoutInventorySupplierInput[]
    createMany?: InventoryItemCreateManyInventorySupplierInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutInventorySupplierInput | InventoryItemUpdateWithWhereUniqueWithoutInventorySupplierInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutInventorySupplierInput | InventoryItemUpdateManyWithWhereWithoutInventorySupplierInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryItemCreateNestedOneWithoutInventoryTransactionInput = {
    create?: XOR<InventoryItemCreateWithoutInventoryTransactionInput, InventoryItemUncheckedCreateWithoutInventoryTransactionInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutInventoryTransactionInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryTransactionInput = {
    create?: XOR<UserCreateWithoutInventoryTransactionInput, UserUncheckedCreateWithoutInventoryTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryTransactionInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryItemUpdateOneRequiredWithoutInventoryTransactionNestedInput = {
    create?: XOR<InventoryItemCreateWithoutInventoryTransactionInput, InventoryItemUncheckedCreateWithoutInventoryTransactionInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutInventoryTransactionInput
    upsert?: InventoryItemUpsertWithoutInventoryTransactionInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutInventoryTransactionInput, InventoryItemUpdateWithoutInventoryTransactionInput>, InventoryItemUncheckedUpdateWithoutInventoryTransactionInput>
  }

  export type UserUpdateOneWithoutInventoryTransactionNestedInput = {
    create?: XOR<UserCreateWithoutInventoryTransactionInput, UserUncheckedCreateWithoutInventoryTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryTransactionInput
    upsert?: UserUpsertWithoutInventoryTransactionInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryTransactionInput, UserUpdateWithoutInventoryTransactionInput>, UserUncheckedUpdateWithoutInventoryTransactionInput>
  }

  export type it_employeesCreateNestedManyWithoutIt_departmentsInput = {
    create?: XOR<it_employeesCreateWithoutIt_departmentsInput, it_employeesUncheckedCreateWithoutIt_departmentsInput> | it_employeesCreateWithoutIt_departmentsInput[] | it_employeesUncheckedCreateWithoutIt_departmentsInput[]
    connectOrCreate?: it_employeesCreateOrConnectWithoutIt_departmentsInput | it_employeesCreateOrConnectWithoutIt_departmentsInput[]
    createMany?: it_employeesCreateManyIt_departmentsInputEnvelope
    connect?: it_employeesWhereUniqueInput | it_employeesWhereUniqueInput[]
  }

  export type it_employeesUncheckedCreateNestedManyWithoutIt_departmentsInput = {
    create?: XOR<it_employeesCreateWithoutIt_departmentsInput, it_employeesUncheckedCreateWithoutIt_departmentsInput> | it_employeesCreateWithoutIt_departmentsInput[] | it_employeesUncheckedCreateWithoutIt_departmentsInput[]
    connectOrCreate?: it_employeesCreateOrConnectWithoutIt_departmentsInput | it_employeesCreateOrConnectWithoutIt_departmentsInput[]
    createMany?: it_employeesCreateManyIt_departmentsInputEnvelope
    connect?: it_employeesWhereUniqueInput | it_employeesWhereUniqueInput[]
  }

  export type it_employeesUpdateManyWithoutIt_departmentsNestedInput = {
    create?: XOR<it_employeesCreateWithoutIt_departmentsInput, it_employeesUncheckedCreateWithoutIt_departmentsInput> | it_employeesCreateWithoutIt_departmentsInput[] | it_employeesUncheckedCreateWithoutIt_departmentsInput[]
    connectOrCreate?: it_employeesCreateOrConnectWithoutIt_departmentsInput | it_employeesCreateOrConnectWithoutIt_departmentsInput[]
    upsert?: it_employeesUpsertWithWhereUniqueWithoutIt_departmentsInput | it_employeesUpsertWithWhereUniqueWithoutIt_departmentsInput[]
    createMany?: it_employeesCreateManyIt_departmentsInputEnvelope
    set?: it_employeesWhereUniqueInput | it_employeesWhereUniqueInput[]
    disconnect?: it_employeesWhereUniqueInput | it_employeesWhereUniqueInput[]
    delete?: it_employeesWhereUniqueInput | it_employeesWhereUniqueInput[]
    connect?: it_employeesWhereUniqueInput | it_employeesWhereUniqueInput[]
    update?: it_employeesUpdateWithWhereUniqueWithoutIt_departmentsInput | it_employeesUpdateWithWhereUniqueWithoutIt_departmentsInput[]
    updateMany?: it_employeesUpdateManyWithWhereWithoutIt_departmentsInput | it_employeesUpdateManyWithWhereWithoutIt_departmentsInput[]
    deleteMany?: it_employeesScalarWhereInput | it_employeesScalarWhereInput[]
  }

  export type it_employeesUncheckedUpdateManyWithoutIt_departmentsNestedInput = {
    create?: XOR<it_employeesCreateWithoutIt_departmentsInput, it_employeesUncheckedCreateWithoutIt_departmentsInput> | it_employeesCreateWithoutIt_departmentsInput[] | it_employeesUncheckedCreateWithoutIt_departmentsInput[]
    connectOrCreate?: it_employeesCreateOrConnectWithoutIt_departmentsInput | it_employeesCreateOrConnectWithoutIt_departmentsInput[]
    upsert?: it_employeesUpsertWithWhereUniqueWithoutIt_departmentsInput | it_employeesUpsertWithWhereUniqueWithoutIt_departmentsInput[]
    createMany?: it_employeesCreateManyIt_departmentsInputEnvelope
    set?: it_employeesWhereUniqueInput | it_employeesWhereUniqueInput[]
    disconnect?: it_employeesWhereUniqueInput | it_employeesWhereUniqueInput[]
    delete?: it_employeesWhereUniqueInput | it_employeesWhereUniqueInput[]
    connect?: it_employeesWhereUniqueInput | it_employeesWhereUniqueInput[]
    update?: it_employeesUpdateWithWhereUniqueWithoutIt_departmentsInput | it_employeesUpdateWithWhereUniqueWithoutIt_departmentsInput[]
    updateMany?: it_employeesUpdateManyWithWhereWithoutIt_departmentsInput | it_employeesUpdateManyWithWhereWithoutIt_departmentsInput[]
    deleteMany?: it_employeesScalarWhereInput | it_employeesScalarWhereInput[]
  }

  export type it_employeesCreateNestedOneWithoutIt_employee_rolesInput = {
    create?: XOR<it_employeesCreateWithoutIt_employee_rolesInput, it_employeesUncheckedCreateWithoutIt_employee_rolesInput>
    connectOrCreate?: it_employeesCreateOrConnectWithoutIt_employee_rolesInput
    connect?: it_employeesWhereUniqueInput
  }

  export type it_rolesCreateNestedOneWithoutIt_employee_rolesInput = {
    create?: XOR<it_rolesCreateWithoutIt_employee_rolesInput, it_rolesUncheckedCreateWithoutIt_employee_rolesInput>
    connectOrCreate?: it_rolesCreateOrConnectWithoutIt_employee_rolesInput
    connect?: it_rolesWhereUniqueInput
  }

  export type it_employeesUpdateOneRequiredWithoutIt_employee_rolesNestedInput = {
    create?: XOR<it_employeesCreateWithoutIt_employee_rolesInput, it_employeesUncheckedCreateWithoutIt_employee_rolesInput>
    connectOrCreate?: it_employeesCreateOrConnectWithoutIt_employee_rolesInput
    upsert?: it_employeesUpsertWithoutIt_employee_rolesInput
    connect?: it_employeesWhereUniqueInput
    update?: XOR<XOR<it_employeesUpdateToOneWithWhereWithoutIt_employee_rolesInput, it_employeesUpdateWithoutIt_employee_rolesInput>, it_employeesUncheckedUpdateWithoutIt_employee_rolesInput>
  }

  export type it_rolesUpdateOneRequiredWithoutIt_employee_rolesNestedInput = {
    create?: XOR<it_rolesCreateWithoutIt_employee_rolesInput, it_rolesUncheckedCreateWithoutIt_employee_rolesInput>
    connectOrCreate?: it_rolesCreateOrConnectWithoutIt_employee_rolesInput
    upsert?: it_rolesUpsertWithoutIt_employee_rolesInput
    connect?: it_rolesWhereUniqueInput
    update?: XOR<XOR<it_rolesUpdateToOneWithWhereWithoutIt_employee_rolesInput, it_rolesUpdateWithoutIt_employee_rolesInput>, it_rolesUncheckedUpdateWithoutIt_employee_rolesInput>
  }

  export type it_employee_rolesCreateNestedManyWithoutIt_employeesInput = {
    create?: XOR<it_employee_rolesCreateWithoutIt_employeesInput, it_employee_rolesUncheckedCreateWithoutIt_employeesInput> | it_employee_rolesCreateWithoutIt_employeesInput[] | it_employee_rolesUncheckedCreateWithoutIt_employeesInput[]
    connectOrCreate?: it_employee_rolesCreateOrConnectWithoutIt_employeesInput | it_employee_rolesCreateOrConnectWithoutIt_employeesInput[]
    createMany?: it_employee_rolesCreateManyIt_employeesInputEnvelope
    connect?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
  }

  export type it_departmentsCreateNestedOneWithoutIt_employeesInput = {
    create?: XOR<it_departmentsCreateWithoutIt_employeesInput, it_departmentsUncheckedCreateWithoutIt_employeesInput>
    connectOrCreate?: it_departmentsCreateOrConnectWithoutIt_employeesInput
    connect?: it_departmentsWhereUniqueInput
  }

  export type it_employee_rolesUncheckedCreateNestedManyWithoutIt_employeesInput = {
    create?: XOR<it_employee_rolesCreateWithoutIt_employeesInput, it_employee_rolesUncheckedCreateWithoutIt_employeesInput> | it_employee_rolesCreateWithoutIt_employeesInput[] | it_employee_rolesUncheckedCreateWithoutIt_employeesInput[]
    connectOrCreate?: it_employee_rolesCreateOrConnectWithoutIt_employeesInput | it_employee_rolesCreateOrConnectWithoutIt_employeesInput[]
    createMany?: it_employee_rolesCreateManyIt_employeesInputEnvelope
    connect?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
  }

  export type it_employee_rolesUpdateManyWithoutIt_employeesNestedInput = {
    create?: XOR<it_employee_rolesCreateWithoutIt_employeesInput, it_employee_rolesUncheckedCreateWithoutIt_employeesInput> | it_employee_rolesCreateWithoutIt_employeesInput[] | it_employee_rolesUncheckedCreateWithoutIt_employeesInput[]
    connectOrCreate?: it_employee_rolesCreateOrConnectWithoutIt_employeesInput | it_employee_rolesCreateOrConnectWithoutIt_employeesInput[]
    upsert?: it_employee_rolesUpsertWithWhereUniqueWithoutIt_employeesInput | it_employee_rolesUpsertWithWhereUniqueWithoutIt_employeesInput[]
    createMany?: it_employee_rolesCreateManyIt_employeesInputEnvelope
    set?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    disconnect?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    delete?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    connect?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    update?: it_employee_rolesUpdateWithWhereUniqueWithoutIt_employeesInput | it_employee_rolesUpdateWithWhereUniqueWithoutIt_employeesInput[]
    updateMany?: it_employee_rolesUpdateManyWithWhereWithoutIt_employeesInput | it_employee_rolesUpdateManyWithWhereWithoutIt_employeesInput[]
    deleteMany?: it_employee_rolesScalarWhereInput | it_employee_rolesScalarWhereInput[]
  }

  export type it_departmentsUpdateOneRequiredWithoutIt_employeesNestedInput = {
    create?: XOR<it_departmentsCreateWithoutIt_employeesInput, it_departmentsUncheckedCreateWithoutIt_employeesInput>
    connectOrCreate?: it_departmentsCreateOrConnectWithoutIt_employeesInput
    upsert?: it_departmentsUpsertWithoutIt_employeesInput
    connect?: it_departmentsWhereUniqueInput
    update?: XOR<XOR<it_departmentsUpdateToOneWithWhereWithoutIt_employeesInput, it_departmentsUpdateWithoutIt_employeesInput>, it_departmentsUncheckedUpdateWithoutIt_employeesInput>
  }

  export type it_employee_rolesUncheckedUpdateManyWithoutIt_employeesNestedInput = {
    create?: XOR<it_employee_rolesCreateWithoutIt_employeesInput, it_employee_rolesUncheckedCreateWithoutIt_employeesInput> | it_employee_rolesCreateWithoutIt_employeesInput[] | it_employee_rolesUncheckedCreateWithoutIt_employeesInput[]
    connectOrCreate?: it_employee_rolesCreateOrConnectWithoutIt_employeesInput | it_employee_rolesCreateOrConnectWithoutIt_employeesInput[]
    upsert?: it_employee_rolesUpsertWithWhereUniqueWithoutIt_employeesInput | it_employee_rolesUpsertWithWhereUniqueWithoutIt_employeesInput[]
    createMany?: it_employee_rolesCreateManyIt_employeesInputEnvelope
    set?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    disconnect?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    delete?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    connect?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    update?: it_employee_rolesUpdateWithWhereUniqueWithoutIt_employeesInput | it_employee_rolesUpdateWithWhereUniqueWithoutIt_employeesInput[]
    updateMany?: it_employee_rolesUpdateManyWithWhereWithoutIt_employeesInput | it_employee_rolesUpdateManyWithWhereWithoutIt_employeesInput[]
    deleteMany?: it_employee_rolesScalarWhereInput | it_employee_rolesScalarWhereInput[]
  }

  export type it_employee_rolesCreateNestedManyWithoutIt_rolesInput = {
    create?: XOR<it_employee_rolesCreateWithoutIt_rolesInput, it_employee_rolesUncheckedCreateWithoutIt_rolesInput> | it_employee_rolesCreateWithoutIt_rolesInput[] | it_employee_rolesUncheckedCreateWithoutIt_rolesInput[]
    connectOrCreate?: it_employee_rolesCreateOrConnectWithoutIt_rolesInput | it_employee_rolesCreateOrConnectWithoutIt_rolesInput[]
    createMany?: it_employee_rolesCreateManyIt_rolesInputEnvelope
    connect?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
  }

  export type it_employee_rolesUncheckedCreateNestedManyWithoutIt_rolesInput = {
    create?: XOR<it_employee_rolesCreateWithoutIt_rolesInput, it_employee_rolesUncheckedCreateWithoutIt_rolesInput> | it_employee_rolesCreateWithoutIt_rolesInput[] | it_employee_rolesUncheckedCreateWithoutIt_rolesInput[]
    connectOrCreate?: it_employee_rolesCreateOrConnectWithoutIt_rolesInput | it_employee_rolesCreateOrConnectWithoutIt_rolesInput[]
    createMany?: it_employee_rolesCreateManyIt_rolesInputEnvelope
    connect?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
  }

  export type it_employee_rolesUpdateManyWithoutIt_rolesNestedInput = {
    create?: XOR<it_employee_rolesCreateWithoutIt_rolesInput, it_employee_rolesUncheckedCreateWithoutIt_rolesInput> | it_employee_rolesCreateWithoutIt_rolesInput[] | it_employee_rolesUncheckedCreateWithoutIt_rolesInput[]
    connectOrCreate?: it_employee_rolesCreateOrConnectWithoutIt_rolesInput | it_employee_rolesCreateOrConnectWithoutIt_rolesInput[]
    upsert?: it_employee_rolesUpsertWithWhereUniqueWithoutIt_rolesInput | it_employee_rolesUpsertWithWhereUniqueWithoutIt_rolesInput[]
    createMany?: it_employee_rolesCreateManyIt_rolesInputEnvelope
    set?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    disconnect?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    delete?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    connect?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    update?: it_employee_rolesUpdateWithWhereUniqueWithoutIt_rolesInput | it_employee_rolesUpdateWithWhereUniqueWithoutIt_rolesInput[]
    updateMany?: it_employee_rolesUpdateManyWithWhereWithoutIt_rolesInput | it_employee_rolesUpdateManyWithWhereWithoutIt_rolesInput[]
    deleteMany?: it_employee_rolesScalarWhereInput | it_employee_rolesScalarWhereInput[]
  }

  export type it_employee_rolesUncheckedUpdateManyWithoutIt_rolesNestedInput = {
    create?: XOR<it_employee_rolesCreateWithoutIt_rolesInput, it_employee_rolesUncheckedCreateWithoutIt_rolesInput> | it_employee_rolesCreateWithoutIt_rolesInput[] | it_employee_rolesUncheckedCreateWithoutIt_rolesInput[]
    connectOrCreate?: it_employee_rolesCreateOrConnectWithoutIt_rolesInput | it_employee_rolesCreateOrConnectWithoutIt_rolesInput[]
    upsert?: it_employee_rolesUpsertWithWhereUniqueWithoutIt_rolesInput | it_employee_rolesUpsertWithWhereUniqueWithoutIt_rolesInput[]
    createMany?: it_employee_rolesCreateManyIt_rolesInputEnvelope
    set?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    disconnect?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    delete?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    connect?: it_employee_rolesWhereUniqueInput | it_employee_rolesWhereUniqueInput[]
    update?: it_employee_rolesUpdateWithWhereUniqueWithoutIt_rolesInput | it_employee_rolesUpdateWithWhereUniqueWithoutIt_rolesInput[]
    updateMany?: it_employee_rolesUpdateManyWithWhereWithoutIt_rolesInput | it_employee_rolesUpdateManyWithWhereWithoutIt_rolesInput[]
    deleteMany?: it_employee_rolesScalarWhereInput | it_employee_rolesScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutKnowledgeBaseInput = {
    create?: XOR<UserCreateWithoutKnowledgeBaseInput, UserUncheckedCreateWithoutKnowledgeBaseInput>
    connectOrCreate?: UserCreateOrConnectWithoutKnowledgeBaseInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutKnowledgeBaseInput = {
    create?: XOR<TicketCreateWithoutKnowledgeBaseInput, TicketUncheckedCreateWithoutKnowledgeBaseInput>
    connectOrCreate?: TicketCreateOrConnectWithoutKnowledgeBaseInput
    connect?: TicketWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutKnowledgeBaseNestedInput = {
    create?: XOR<UserCreateWithoutKnowledgeBaseInput, UserUncheckedCreateWithoutKnowledgeBaseInput>
    connectOrCreate?: UserCreateOrConnectWithoutKnowledgeBaseInput
    upsert?: UserUpsertWithoutKnowledgeBaseInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKnowledgeBaseInput, UserUpdateWithoutKnowledgeBaseInput>, UserUncheckedUpdateWithoutKnowledgeBaseInput>
  }

  export type TicketUpdateOneWithoutKnowledgeBaseNestedInput = {
    create?: XOR<TicketCreateWithoutKnowledgeBaseInput, TicketUncheckedCreateWithoutKnowledgeBaseInput>
    connectOrCreate?: TicketCreateOrConnectWithoutKnowledgeBaseInput
    upsert?: TicketUpsertWithoutKnowledgeBaseInput
    disconnect?: TicketWhereInput | boolean
    delete?: TicketWhereInput | boolean
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutKnowledgeBaseInput, TicketUpdateWithoutKnowledgeBaseInput>, TicketUncheckedUpdateWithoutKnowledgeBaseInput>
  }

  export type AssetCreateNestedOneWithoutLicenseInput = {
    create?: XOR<AssetCreateWithoutLicenseInput, AssetUncheckedCreateWithoutLicenseInput>
    connectOrCreate?: AssetCreateOrConnectWithoutLicenseInput
    connect?: AssetWhereUniqueInput
  }

  export type AssetUpdateOneRequiredWithoutLicenseNestedInput = {
    create?: XOR<AssetCreateWithoutLicenseInput, AssetUncheckedCreateWithoutLicenseInput>
    connectOrCreate?: AssetCreateOrConnectWithoutLicenseInput
    upsert?: AssetUpsertWithoutLicenseInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutLicenseInput, AssetUpdateWithoutLicenseInput>, AssetUncheckedUpdateWithoutLicenseInput>
  }

  export type AssetCreateNestedOneWithoutMonitorInput = {
    create?: XOR<AssetCreateWithoutMonitorInput, AssetUncheckedCreateWithoutMonitorInput>
    connectOrCreate?: AssetCreateOrConnectWithoutMonitorInput
    connect?: AssetWhereUniqueInput
  }

  export type AssetUpdateOneRequiredWithoutMonitorNestedInput = {
    create?: XOR<AssetCreateWithoutMonitorInput, AssetUncheckedCreateWithoutMonitorInput>
    connectOrCreate?: AssetCreateOrConnectWithoutMonitorInput
    upsert?: AssetUpsertWithoutMonitorInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutMonitorInput, AssetUpdateWithoutMonitorInput>, AssetUncheckedUpdateWithoutMonitorInput>
  }

  export type employee_rolesCreateNestedManyWithoutRolesInput = {
    create?: XOR<employee_rolesCreateWithoutRolesInput, employee_rolesUncheckedCreateWithoutRolesInput> | employee_rolesCreateWithoutRolesInput[] | employee_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: employee_rolesCreateOrConnectWithoutRolesInput | employee_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: employee_rolesCreateManyRolesInputEnvelope
    connect?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
  }

  export type employee_rolesUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<employee_rolesCreateWithoutRolesInput, employee_rolesUncheckedCreateWithoutRolesInput> | employee_rolesCreateWithoutRolesInput[] | employee_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: employee_rolesCreateOrConnectWithoutRolesInput | employee_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: employee_rolesCreateManyRolesInputEnvelope
    connect?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
  }

  export type employee_rolesUpdateManyWithoutRolesNestedInput = {
    create?: XOR<employee_rolesCreateWithoutRolesInput, employee_rolesUncheckedCreateWithoutRolesInput> | employee_rolesCreateWithoutRolesInput[] | employee_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: employee_rolesCreateOrConnectWithoutRolesInput | employee_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: employee_rolesUpsertWithWhereUniqueWithoutRolesInput | employee_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: employee_rolesCreateManyRolesInputEnvelope
    set?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    disconnect?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    delete?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    connect?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    update?: employee_rolesUpdateWithWhereUniqueWithoutRolesInput | employee_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: employee_rolesUpdateManyWithWhereWithoutRolesInput | employee_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: employee_rolesScalarWhereInput | employee_rolesScalarWhereInput[]
  }

  export type employee_rolesUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<employee_rolesCreateWithoutRolesInput, employee_rolesUncheckedCreateWithoutRolesInput> | employee_rolesCreateWithoutRolesInput[] | employee_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: employee_rolesCreateOrConnectWithoutRolesInput | employee_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: employee_rolesUpsertWithWhereUniqueWithoutRolesInput | employee_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: employee_rolesCreateManyRolesInputEnvelope
    set?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    disconnect?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    delete?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    connect?: employee_rolesWhereUniqueInput | employee_rolesWhereUniqueInput[]
    update?: employee_rolesUpdateWithWhereUniqueWithoutRolesInput | employee_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: employee_rolesUpdateManyWithWhereWithoutRolesInput | employee_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: employee_rolesScalarWhereInput | employee_rolesScalarWhereInput[]
  }

  export type KnowledgeBaseCreateNestedManyWithoutTicketInput = {
    create?: XOR<KnowledgeBaseCreateWithoutTicketInput, KnowledgeBaseUncheckedCreateWithoutTicketInput> | KnowledgeBaseCreateWithoutTicketInput[] | KnowledgeBaseUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutTicketInput | KnowledgeBaseCreateOrConnectWithoutTicketInput[]
    createMany?: KnowledgeBaseCreateManyTicketInputEnvelope
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
  }

  export type AssetCreateNestedOneWithoutTicketInput = {
    create?: XOR<AssetCreateWithoutTicketInput, AssetUncheckedCreateWithoutTicketInput>
    connectOrCreate?: AssetCreateOrConnectWithoutTicketInput
    connect?: AssetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicket_Ticket_assignedToIdToUserInput = {
    create?: XOR<UserCreateWithoutTicket_Ticket_assignedToIdToUserInput, UserUncheckedCreateWithoutTicket_Ticket_assignedToIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicket_Ticket_assignedToIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicket_Ticket_requestedByIdToUserInput = {
    create?: XOR<UserCreateWithoutTicket_Ticket_requestedByIdToUserInput, UserUncheckedCreateWithoutTicket_Ticket_requestedByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicket_Ticket_requestedByIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type TicketAttachmentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketCommentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TicketHistoryCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketHistoryCreateWithoutTicketInput, TicketHistoryUncheckedCreateWithoutTicketInput> | TicketHistoryCreateWithoutTicketInput[] | TicketHistoryUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutTicketInput | TicketHistoryCreateOrConnectWithoutTicketInput[]
    createMany?: TicketHistoryCreateManyTicketInputEnvelope
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
  }

  export type KnowledgeBaseUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<KnowledgeBaseCreateWithoutTicketInput, KnowledgeBaseUncheckedCreateWithoutTicketInput> | KnowledgeBaseCreateWithoutTicketInput[] | KnowledgeBaseUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutTicketInput | KnowledgeBaseCreateOrConnectWithoutTicketInput[]
    createMany?: KnowledgeBaseCreateManyTicketInputEnvelope
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
  }

  export type TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TicketHistoryUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketHistoryCreateWithoutTicketInput, TicketHistoryUncheckedCreateWithoutTicketInput> | TicketHistoryCreateWithoutTicketInput[] | TicketHistoryUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutTicketInput | TicketHistoryCreateOrConnectWithoutTicketInput[]
    createMany?: TicketHistoryCreateManyTicketInputEnvelope
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
  }

  export type KnowledgeBaseUpdateManyWithoutTicketNestedInput = {
    create?: XOR<KnowledgeBaseCreateWithoutTicketInput, KnowledgeBaseUncheckedCreateWithoutTicketInput> | KnowledgeBaseCreateWithoutTicketInput[] | KnowledgeBaseUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutTicketInput | KnowledgeBaseCreateOrConnectWithoutTicketInput[]
    upsert?: KnowledgeBaseUpsertWithWhereUniqueWithoutTicketInput | KnowledgeBaseUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: KnowledgeBaseCreateManyTicketInputEnvelope
    set?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    disconnect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    delete?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    update?: KnowledgeBaseUpdateWithWhereUniqueWithoutTicketInput | KnowledgeBaseUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: KnowledgeBaseUpdateManyWithWhereWithoutTicketInput | KnowledgeBaseUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: KnowledgeBaseScalarWhereInput | KnowledgeBaseScalarWhereInput[]
  }

  export type AssetUpdateOneWithoutTicketNestedInput = {
    create?: XOR<AssetCreateWithoutTicketInput, AssetUncheckedCreateWithoutTicketInput>
    connectOrCreate?: AssetCreateOrConnectWithoutTicketInput
    upsert?: AssetUpsertWithoutTicketInput
    disconnect?: AssetWhereInput | boolean
    delete?: AssetWhereInput | boolean
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutTicketInput, AssetUpdateWithoutTicketInput>, AssetUncheckedUpdateWithoutTicketInput>
  }

  export type UserUpdateOneWithoutTicket_Ticket_assignedToIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutTicket_Ticket_assignedToIdToUserInput, UserUncheckedCreateWithoutTicket_Ticket_assignedToIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicket_Ticket_assignedToIdToUserInput
    upsert?: UserUpsertWithoutTicket_Ticket_assignedToIdToUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicket_Ticket_assignedToIdToUserInput, UserUpdateWithoutTicket_Ticket_assignedToIdToUserInput>, UserUncheckedUpdateWithoutTicket_Ticket_assignedToIdToUserInput>
  }

  export type UserUpdateOneRequiredWithoutTicket_Ticket_requestedByIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutTicket_Ticket_requestedByIdToUserInput, UserUncheckedCreateWithoutTicket_Ticket_requestedByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicket_Ticket_requestedByIdToUserInput
    upsert?: UserUpsertWithoutTicket_Ticket_requestedByIdToUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicket_Ticket_requestedByIdToUserInput, UserUpdateWithoutTicket_Ticket_requestedByIdToUserInput>, UserUncheckedUpdateWithoutTicket_Ticket_requestedByIdToUserInput>
  }

  export type TicketAttachmentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput | TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput | TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutTicketInput | TicketAttachmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TicketCommentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketHistoryUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketHistoryCreateWithoutTicketInput, TicketHistoryUncheckedCreateWithoutTicketInput> | TicketHistoryCreateWithoutTicketInput[] | TicketHistoryUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutTicketInput | TicketHistoryCreateOrConnectWithoutTicketInput[]
    upsert?: TicketHistoryUpsertWithWhereUniqueWithoutTicketInput | TicketHistoryUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketHistoryCreateManyTicketInputEnvelope
    set?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    disconnect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    delete?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    update?: TicketHistoryUpdateWithWhereUniqueWithoutTicketInput | TicketHistoryUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketHistoryUpdateManyWithWhereWithoutTicketInput | TicketHistoryUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketHistoryScalarWhereInput | TicketHistoryScalarWhereInput[]
  }

  export type KnowledgeBaseUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<KnowledgeBaseCreateWithoutTicketInput, KnowledgeBaseUncheckedCreateWithoutTicketInput> | KnowledgeBaseCreateWithoutTicketInput[] | KnowledgeBaseUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutTicketInput | KnowledgeBaseCreateOrConnectWithoutTicketInput[]
    upsert?: KnowledgeBaseUpsertWithWhereUniqueWithoutTicketInput | KnowledgeBaseUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: KnowledgeBaseCreateManyTicketInputEnvelope
    set?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    disconnect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    delete?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    update?: KnowledgeBaseUpdateWithWhereUniqueWithoutTicketInput | KnowledgeBaseUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: KnowledgeBaseUpdateManyWithWhereWithoutTicketInput | KnowledgeBaseUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: KnowledgeBaseScalarWhereInput | KnowledgeBaseScalarWhereInput[]
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput | TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput | TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutTicketInput | TicketAttachmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketHistoryCreateWithoutTicketInput, TicketHistoryUncheckedCreateWithoutTicketInput> | TicketHistoryCreateWithoutTicketInput[] | TicketHistoryUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutTicketInput | TicketHistoryCreateOrConnectWithoutTicketInput[]
    upsert?: TicketHistoryUpsertWithWhereUniqueWithoutTicketInput | TicketHistoryUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketHistoryCreateManyTicketInputEnvelope
    set?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    disconnect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    delete?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    update?: TicketHistoryUpdateWithWhereUniqueWithoutTicketInput | TicketHistoryUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketHistoryUpdateManyWithWhereWithoutTicketInput | TicketHistoryUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketHistoryScalarWhereInput | TicketHistoryScalarWhereInput[]
  }

  export type TicketCreateNestedOneWithoutTicketAttachmentInput = {
    create?: XOR<TicketCreateWithoutTicketAttachmentInput, TicketUncheckedCreateWithoutTicketAttachmentInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicketAttachmentInput
    connect?: TicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketAttachmentInput = {
    create?: XOR<UserCreateWithoutTicketAttachmentInput, UserUncheckedCreateWithoutTicketAttachmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketAttachmentInput
    connect?: UserWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutTicketAttachmentNestedInput = {
    create?: XOR<TicketCreateWithoutTicketAttachmentInput, TicketUncheckedCreateWithoutTicketAttachmentInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicketAttachmentInput
    upsert?: TicketUpsertWithoutTicketAttachmentInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutTicketAttachmentInput, TicketUpdateWithoutTicketAttachmentInput>, TicketUncheckedUpdateWithoutTicketAttachmentInput>
  }

  export type UserUpdateOneRequiredWithoutTicketAttachmentNestedInput = {
    create?: XOR<UserCreateWithoutTicketAttachmentInput, UserUncheckedCreateWithoutTicketAttachmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketAttachmentInput
    upsert?: UserUpsertWithoutTicketAttachmentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketAttachmentInput, UserUpdateWithoutTicketAttachmentInput>, UserUncheckedUpdateWithoutTicketAttachmentInput>
  }

  export type UserCreateNestedOneWithoutTicketCommentInput = {
    create?: XOR<UserCreateWithoutTicketCommentInput, UserUncheckedCreateWithoutTicketCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketCommentInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutTicketCommentInput = {
    create?: XOR<TicketCreateWithoutTicketCommentInput, TicketUncheckedCreateWithoutTicketCommentInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicketCommentInput
    connect?: TicketWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTicketCommentNestedInput = {
    create?: XOR<UserCreateWithoutTicketCommentInput, UserUncheckedCreateWithoutTicketCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketCommentInput
    upsert?: UserUpsertWithoutTicketCommentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketCommentInput, UserUpdateWithoutTicketCommentInput>, UserUncheckedUpdateWithoutTicketCommentInput>
  }

  export type TicketUpdateOneRequiredWithoutTicketCommentNestedInput = {
    create?: XOR<TicketCreateWithoutTicketCommentInput, TicketUncheckedCreateWithoutTicketCommentInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicketCommentInput
    upsert?: TicketUpsertWithoutTicketCommentInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutTicketCommentInput, TicketUpdateWithoutTicketCommentInput>, TicketUncheckedUpdateWithoutTicketCommentInput>
  }

  export type UserCreateNestedOneWithoutTicketHistoryInput = {
    create?: XOR<UserCreateWithoutTicketHistoryInput, UserUncheckedCreateWithoutTicketHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutTicketHistoryInput = {
    create?: XOR<TicketCreateWithoutTicketHistoryInput, TicketUncheckedCreateWithoutTicketHistoryInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicketHistoryInput
    connect?: TicketWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTicketHistoryNestedInput = {
    create?: XOR<UserCreateWithoutTicketHistoryInput, UserUncheckedCreateWithoutTicketHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketHistoryInput
    upsert?: UserUpsertWithoutTicketHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketHistoryInput, UserUpdateWithoutTicketHistoryInput>, UserUncheckedUpdateWithoutTicketHistoryInput>
  }

  export type TicketUpdateOneRequiredWithoutTicketHistoryNestedInput = {
    create?: XOR<TicketCreateWithoutTicketHistoryInput, TicketUncheckedCreateWithoutTicketHistoryInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicketHistoryInput
    upsert?: TicketUpsertWithoutTicketHistoryInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutTicketHistoryInput, TicketUpdateWithoutTicketHistoryInput>, TicketUncheckedUpdateWithoutTicketHistoryInput>
  }

  export type AssetCreateNestedManyWithoutUserInput = {
    create?: XOR<AssetCreateWithoutUserInput, AssetUncheckedCreateWithoutUserInput> | AssetCreateWithoutUserInput[] | AssetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutUserInput | AssetCreateOrConnectWithoutUserInput[]
    createMany?: AssetCreateManyUserInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetHistoryCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput = {
    create?: XOR<AssetHistoryCreateWithoutUser_AssetHistory_newOwnerIdToUserInput, AssetHistoryUncheckedCreateWithoutUser_AssetHistory_newOwnerIdToUserInput> | AssetHistoryCreateWithoutUser_AssetHistory_newOwnerIdToUserInput[] | AssetHistoryUncheckedCreateWithoutUser_AssetHistory_newOwnerIdToUserInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutUser_AssetHistory_newOwnerIdToUserInput | AssetHistoryCreateOrConnectWithoutUser_AssetHistory_newOwnerIdToUserInput[]
    createMany?: AssetHistoryCreateManyUser_AssetHistory_newOwnerIdToUserInputEnvelope
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
  }

  export type AssetHistoryCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput = {
    create?: XOR<AssetHistoryCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput, AssetHistoryUncheckedCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput> | AssetHistoryCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput[] | AssetHistoryUncheckedCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutUser_AssetHistory_oldOwnerIdToUserInput | AssetHistoryCreateOrConnectWithoutUser_AssetHistory_oldOwnerIdToUserInput[]
    createMany?: AssetHistoryCreateManyUser_AssetHistory_oldOwnerIdToUserInputEnvelope
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type InventoryTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput> | InventoryTransactionCreateWithoutUserInput[] | InventoryTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutUserInput | InventoryTransactionCreateOrConnectWithoutUserInput[]
    createMany?: InventoryTransactionCreateManyUserInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type KnowledgeBaseCreateNestedManyWithoutUserInput = {
    create?: XOR<KnowledgeBaseCreateWithoutUserInput, KnowledgeBaseUncheckedCreateWithoutUserInput> | KnowledgeBaseCreateWithoutUserInput[] | KnowledgeBaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutUserInput | KnowledgeBaseCreateOrConnectWithoutUserInput[]
    createMany?: KnowledgeBaseCreateManyUserInputEnvelope
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput = {
    create?: XOR<TicketCreateWithoutUser_Ticket_assignedToIdToUserInput, TicketUncheckedCreateWithoutUser_Ticket_assignedToIdToUserInput> | TicketCreateWithoutUser_Ticket_assignedToIdToUserInput[] | TicketUncheckedCreateWithoutUser_Ticket_assignedToIdToUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUser_Ticket_assignedToIdToUserInput | TicketCreateOrConnectWithoutUser_Ticket_assignedToIdToUserInput[]
    createMany?: TicketCreateManyUser_Ticket_assignedToIdToUserInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput = {
    create?: XOR<TicketCreateWithoutUser_Ticket_requestedByIdToUserInput, TicketUncheckedCreateWithoutUser_Ticket_requestedByIdToUserInput> | TicketCreateWithoutUser_Ticket_requestedByIdToUserInput[] | TicketUncheckedCreateWithoutUser_Ticket_requestedByIdToUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUser_Ticket_requestedByIdToUserInput | TicketCreateOrConnectWithoutUser_Ticket_requestedByIdToUserInput[]
    createMany?: TicketCreateManyUser_Ticket_requestedByIdToUserInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketAttachmentCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketAttachmentCreateWithoutUserInput, TicketAttachmentUncheckedCreateWithoutUserInput> | TicketAttachmentCreateWithoutUserInput[] | TicketAttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutUserInput | TicketAttachmentCreateOrConnectWithoutUserInput[]
    createMany?: TicketAttachmentCreateManyUserInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TicketHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketHistoryCreateWithoutUserInput, TicketHistoryUncheckedCreateWithoutUserInput> | TicketHistoryCreateWithoutUserInput[] | TicketHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutUserInput | TicketHistoryCreateOrConnectWithoutUserInput[]
    createMany?: TicketHistoryCreateManyUserInputEnvelope
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AssetCreateWithoutUserInput, AssetUncheckedCreateWithoutUserInput> | AssetCreateWithoutUserInput[] | AssetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutUserInput | AssetCreateOrConnectWithoutUserInput[]
    createMany?: AssetCreateManyUserInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput = {
    create?: XOR<AssetHistoryCreateWithoutUser_AssetHistory_newOwnerIdToUserInput, AssetHistoryUncheckedCreateWithoutUser_AssetHistory_newOwnerIdToUserInput> | AssetHistoryCreateWithoutUser_AssetHistory_newOwnerIdToUserInput[] | AssetHistoryUncheckedCreateWithoutUser_AssetHistory_newOwnerIdToUserInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutUser_AssetHistory_newOwnerIdToUserInput | AssetHistoryCreateOrConnectWithoutUser_AssetHistory_newOwnerIdToUserInput[]
    createMany?: AssetHistoryCreateManyUser_AssetHistory_newOwnerIdToUserInputEnvelope
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
  }

  export type AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput = {
    create?: XOR<AssetHistoryCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput, AssetHistoryUncheckedCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput> | AssetHistoryCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput[] | AssetHistoryUncheckedCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutUser_AssetHistory_oldOwnerIdToUserInput | AssetHistoryCreateOrConnectWithoutUser_AssetHistory_oldOwnerIdToUserInput[]
    createMany?: AssetHistoryCreateManyUser_AssetHistory_oldOwnerIdToUserInputEnvelope
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type InventoryTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput> | InventoryTransactionCreateWithoutUserInput[] | InventoryTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutUserInput | InventoryTransactionCreateOrConnectWithoutUserInput[]
    createMany?: InventoryTransactionCreateManyUserInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type KnowledgeBaseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<KnowledgeBaseCreateWithoutUserInput, KnowledgeBaseUncheckedCreateWithoutUserInput> | KnowledgeBaseCreateWithoutUserInput[] | KnowledgeBaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutUserInput | KnowledgeBaseCreateOrConnectWithoutUserInput[]
    createMany?: KnowledgeBaseCreateManyUserInputEnvelope
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput = {
    create?: XOR<TicketCreateWithoutUser_Ticket_assignedToIdToUserInput, TicketUncheckedCreateWithoutUser_Ticket_assignedToIdToUserInput> | TicketCreateWithoutUser_Ticket_assignedToIdToUserInput[] | TicketUncheckedCreateWithoutUser_Ticket_assignedToIdToUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUser_Ticket_assignedToIdToUserInput | TicketCreateOrConnectWithoutUser_Ticket_assignedToIdToUserInput[]
    createMany?: TicketCreateManyUser_Ticket_assignedToIdToUserInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput = {
    create?: XOR<TicketCreateWithoutUser_Ticket_requestedByIdToUserInput, TicketUncheckedCreateWithoutUser_Ticket_requestedByIdToUserInput> | TicketCreateWithoutUser_Ticket_requestedByIdToUserInput[] | TicketUncheckedCreateWithoutUser_Ticket_requestedByIdToUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUser_Ticket_requestedByIdToUserInput | TicketCreateOrConnectWithoutUser_Ticket_requestedByIdToUserInput[]
    createMany?: TicketCreateManyUser_Ticket_requestedByIdToUserInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketAttachmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketAttachmentCreateWithoutUserInput, TicketAttachmentUncheckedCreateWithoutUserInput> | TicketAttachmentCreateWithoutUserInput[] | TicketAttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutUserInput | TicketAttachmentCreateOrConnectWithoutUserInput[]
    createMany?: TicketAttachmentCreateManyUserInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TicketHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketHistoryCreateWithoutUserInput, TicketHistoryUncheckedCreateWithoutUserInput> | TicketHistoryCreateWithoutUserInput[] | TicketHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutUserInput | TicketHistoryCreateOrConnectWithoutUserInput[]
    createMany?: TicketHistoryCreateManyUserInputEnvelope
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
  }

  export type AssetUpdateManyWithoutUserNestedInput = {
    create?: XOR<AssetCreateWithoutUserInput, AssetUncheckedCreateWithoutUserInput> | AssetCreateWithoutUserInput[] | AssetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutUserInput | AssetCreateOrConnectWithoutUserInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutUserInput | AssetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AssetCreateManyUserInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutUserInput | AssetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutUserInput | AssetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetHistoryUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput = {
    create?: XOR<AssetHistoryCreateWithoutUser_AssetHistory_newOwnerIdToUserInput, AssetHistoryUncheckedCreateWithoutUser_AssetHistory_newOwnerIdToUserInput> | AssetHistoryCreateWithoutUser_AssetHistory_newOwnerIdToUserInput[] | AssetHistoryUncheckedCreateWithoutUser_AssetHistory_newOwnerIdToUserInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutUser_AssetHistory_newOwnerIdToUserInput | AssetHistoryCreateOrConnectWithoutUser_AssetHistory_newOwnerIdToUserInput[]
    upsert?: AssetHistoryUpsertWithWhereUniqueWithoutUser_AssetHistory_newOwnerIdToUserInput | AssetHistoryUpsertWithWhereUniqueWithoutUser_AssetHistory_newOwnerIdToUserInput[]
    createMany?: AssetHistoryCreateManyUser_AssetHistory_newOwnerIdToUserInputEnvelope
    set?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    disconnect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    delete?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    update?: AssetHistoryUpdateWithWhereUniqueWithoutUser_AssetHistory_newOwnerIdToUserInput | AssetHistoryUpdateWithWhereUniqueWithoutUser_AssetHistory_newOwnerIdToUserInput[]
    updateMany?: AssetHistoryUpdateManyWithWhereWithoutUser_AssetHistory_newOwnerIdToUserInput | AssetHistoryUpdateManyWithWhereWithoutUser_AssetHistory_newOwnerIdToUserInput[]
    deleteMany?: AssetHistoryScalarWhereInput | AssetHistoryScalarWhereInput[]
  }

  export type AssetHistoryUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput = {
    create?: XOR<AssetHistoryCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput, AssetHistoryUncheckedCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput> | AssetHistoryCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput[] | AssetHistoryUncheckedCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutUser_AssetHistory_oldOwnerIdToUserInput | AssetHistoryCreateOrConnectWithoutUser_AssetHistory_oldOwnerIdToUserInput[]
    upsert?: AssetHistoryUpsertWithWhereUniqueWithoutUser_AssetHistory_oldOwnerIdToUserInput | AssetHistoryUpsertWithWhereUniqueWithoutUser_AssetHistory_oldOwnerIdToUserInput[]
    createMany?: AssetHistoryCreateManyUser_AssetHistory_oldOwnerIdToUserInputEnvelope
    set?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    disconnect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    delete?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    update?: AssetHistoryUpdateWithWhereUniqueWithoutUser_AssetHistory_oldOwnerIdToUserInput | AssetHistoryUpdateWithWhereUniqueWithoutUser_AssetHistory_oldOwnerIdToUserInput[]
    updateMany?: AssetHistoryUpdateManyWithWhereWithoutUser_AssetHistory_oldOwnerIdToUserInput | AssetHistoryUpdateManyWithWhereWithoutUser_AssetHistory_oldOwnerIdToUserInput[]
    deleteMany?: AssetHistoryScalarWhereInput | AssetHistoryScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type InventoryTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput> | InventoryTransactionCreateWithoutUserInput[] | InventoryTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutUserInput | InventoryTransactionCreateOrConnectWithoutUserInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutUserInput | InventoryTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryTransactionCreateManyUserInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutUserInput | InventoryTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutUserInput | InventoryTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type KnowledgeBaseUpdateManyWithoutUserNestedInput = {
    create?: XOR<KnowledgeBaseCreateWithoutUserInput, KnowledgeBaseUncheckedCreateWithoutUserInput> | KnowledgeBaseCreateWithoutUserInput[] | KnowledgeBaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutUserInput | KnowledgeBaseCreateOrConnectWithoutUserInput[]
    upsert?: KnowledgeBaseUpsertWithWhereUniqueWithoutUserInput | KnowledgeBaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: KnowledgeBaseCreateManyUserInputEnvelope
    set?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    disconnect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    delete?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    update?: KnowledgeBaseUpdateWithWhereUniqueWithoutUserInput | KnowledgeBaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: KnowledgeBaseUpdateManyWithWhereWithoutUserInput | KnowledgeBaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: KnowledgeBaseScalarWhereInput | KnowledgeBaseScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput = {
    create?: XOR<TicketCreateWithoutUser_Ticket_assignedToIdToUserInput, TicketUncheckedCreateWithoutUser_Ticket_assignedToIdToUserInput> | TicketCreateWithoutUser_Ticket_assignedToIdToUserInput[] | TicketUncheckedCreateWithoutUser_Ticket_assignedToIdToUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUser_Ticket_assignedToIdToUserInput | TicketCreateOrConnectWithoutUser_Ticket_assignedToIdToUserInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutUser_Ticket_assignedToIdToUserInput | TicketUpsertWithWhereUniqueWithoutUser_Ticket_assignedToIdToUserInput[]
    createMany?: TicketCreateManyUser_Ticket_assignedToIdToUserInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutUser_Ticket_assignedToIdToUserInput | TicketUpdateWithWhereUniqueWithoutUser_Ticket_assignedToIdToUserInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutUser_Ticket_assignedToIdToUserInput | TicketUpdateManyWithWhereWithoutUser_Ticket_assignedToIdToUserInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput = {
    create?: XOR<TicketCreateWithoutUser_Ticket_requestedByIdToUserInput, TicketUncheckedCreateWithoutUser_Ticket_requestedByIdToUserInput> | TicketCreateWithoutUser_Ticket_requestedByIdToUserInput[] | TicketUncheckedCreateWithoutUser_Ticket_requestedByIdToUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUser_Ticket_requestedByIdToUserInput | TicketCreateOrConnectWithoutUser_Ticket_requestedByIdToUserInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutUser_Ticket_requestedByIdToUserInput | TicketUpsertWithWhereUniqueWithoutUser_Ticket_requestedByIdToUserInput[]
    createMany?: TicketCreateManyUser_Ticket_requestedByIdToUserInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutUser_Ticket_requestedByIdToUserInput | TicketUpdateWithWhereUniqueWithoutUser_Ticket_requestedByIdToUserInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutUser_Ticket_requestedByIdToUserInput | TicketUpdateManyWithWhereWithoutUser_Ticket_requestedByIdToUserInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketAttachmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutUserInput, TicketAttachmentUncheckedCreateWithoutUserInput> | TicketAttachmentCreateWithoutUserInput[] | TicketAttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutUserInput | TicketAttachmentCreateOrConnectWithoutUserInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutUserInput | TicketAttachmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketAttachmentCreateManyUserInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutUserInput | TicketAttachmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutUserInput | TicketAttachmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TicketCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutUserInput | TicketCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutUserInput | TicketCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutUserInput | TicketCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketHistoryCreateWithoutUserInput, TicketHistoryUncheckedCreateWithoutUserInput> | TicketHistoryCreateWithoutUserInput[] | TicketHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutUserInput | TicketHistoryCreateOrConnectWithoutUserInput[]
    upsert?: TicketHistoryUpsertWithWhereUniqueWithoutUserInput | TicketHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketHistoryCreateManyUserInputEnvelope
    set?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    disconnect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    delete?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    update?: TicketHistoryUpdateWithWhereUniqueWithoutUserInput | TicketHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketHistoryUpdateManyWithWhereWithoutUserInput | TicketHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketHistoryScalarWhereInput | TicketHistoryScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AssetCreateWithoutUserInput, AssetUncheckedCreateWithoutUserInput> | AssetCreateWithoutUserInput[] | AssetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutUserInput | AssetCreateOrConnectWithoutUserInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutUserInput | AssetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AssetCreateManyUserInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutUserInput | AssetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutUserInput | AssetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput = {
    create?: XOR<AssetHistoryCreateWithoutUser_AssetHistory_newOwnerIdToUserInput, AssetHistoryUncheckedCreateWithoutUser_AssetHistory_newOwnerIdToUserInput> | AssetHistoryCreateWithoutUser_AssetHistory_newOwnerIdToUserInput[] | AssetHistoryUncheckedCreateWithoutUser_AssetHistory_newOwnerIdToUserInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutUser_AssetHistory_newOwnerIdToUserInput | AssetHistoryCreateOrConnectWithoutUser_AssetHistory_newOwnerIdToUserInput[]
    upsert?: AssetHistoryUpsertWithWhereUniqueWithoutUser_AssetHistory_newOwnerIdToUserInput | AssetHistoryUpsertWithWhereUniqueWithoutUser_AssetHistory_newOwnerIdToUserInput[]
    createMany?: AssetHistoryCreateManyUser_AssetHistory_newOwnerIdToUserInputEnvelope
    set?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    disconnect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    delete?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    update?: AssetHistoryUpdateWithWhereUniqueWithoutUser_AssetHistory_newOwnerIdToUserInput | AssetHistoryUpdateWithWhereUniqueWithoutUser_AssetHistory_newOwnerIdToUserInput[]
    updateMany?: AssetHistoryUpdateManyWithWhereWithoutUser_AssetHistory_newOwnerIdToUserInput | AssetHistoryUpdateManyWithWhereWithoutUser_AssetHistory_newOwnerIdToUserInput[]
    deleteMany?: AssetHistoryScalarWhereInput | AssetHistoryScalarWhereInput[]
  }

  export type AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput = {
    create?: XOR<AssetHistoryCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput, AssetHistoryUncheckedCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput> | AssetHistoryCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput[] | AssetHistoryUncheckedCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput[]
    connectOrCreate?: AssetHistoryCreateOrConnectWithoutUser_AssetHistory_oldOwnerIdToUserInput | AssetHistoryCreateOrConnectWithoutUser_AssetHistory_oldOwnerIdToUserInput[]
    upsert?: AssetHistoryUpsertWithWhereUniqueWithoutUser_AssetHistory_oldOwnerIdToUserInput | AssetHistoryUpsertWithWhereUniqueWithoutUser_AssetHistory_oldOwnerIdToUserInput[]
    createMany?: AssetHistoryCreateManyUser_AssetHistory_oldOwnerIdToUserInputEnvelope
    set?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    disconnect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    delete?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    connect?: AssetHistoryWhereUniqueInput | AssetHistoryWhereUniqueInput[]
    update?: AssetHistoryUpdateWithWhereUniqueWithoutUser_AssetHistory_oldOwnerIdToUserInput | AssetHistoryUpdateWithWhereUniqueWithoutUser_AssetHistory_oldOwnerIdToUserInput[]
    updateMany?: AssetHistoryUpdateManyWithWhereWithoutUser_AssetHistory_oldOwnerIdToUserInput | AssetHistoryUpdateManyWithWhereWithoutUser_AssetHistory_oldOwnerIdToUserInput[]
    deleteMany?: AssetHistoryScalarWhereInput | AssetHistoryScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput> | InventoryTransactionCreateWithoutUserInput[] | InventoryTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutUserInput | InventoryTransactionCreateOrConnectWithoutUserInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutUserInput | InventoryTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryTransactionCreateManyUserInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutUserInput | InventoryTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutUserInput | InventoryTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type KnowledgeBaseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<KnowledgeBaseCreateWithoutUserInput, KnowledgeBaseUncheckedCreateWithoutUserInput> | KnowledgeBaseCreateWithoutUserInput[] | KnowledgeBaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutUserInput | KnowledgeBaseCreateOrConnectWithoutUserInput[]
    upsert?: KnowledgeBaseUpsertWithWhereUniqueWithoutUserInput | KnowledgeBaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: KnowledgeBaseCreateManyUserInputEnvelope
    set?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    disconnect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    delete?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    update?: KnowledgeBaseUpdateWithWhereUniqueWithoutUserInput | KnowledgeBaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: KnowledgeBaseUpdateManyWithWhereWithoutUserInput | KnowledgeBaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: KnowledgeBaseScalarWhereInput | KnowledgeBaseScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput = {
    create?: XOR<TicketCreateWithoutUser_Ticket_assignedToIdToUserInput, TicketUncheckedCreateWithoutUser_Ticket_assignedToIdToUserInput> | TicketCreateWithoutUser_Ticket_assignedToIdToUserInput[] | TicketUncheckedCreateWithoutUser_Ticket_assignedToIdToUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUser_Ticket_assignedToIdToUserInput | TicketCreateOrConnectWithoutUser_Ticket_assignedToIdToUserInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutUser_Ticket_assignedToIdToUserInput | TicketUpsertWithWhereUniqueWithoutUser_Ticket_assignedToIdToUserInput[]
    createMany?: TicketCreateManyUser_Ticket_assignedToIdToUserInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutUser_Ticket_assignedToIdToUserInput | TicketUpdateWithWhereUniqueWithoutUser_Ticket_assignedToIdToUserInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutUser_Ticket_assignedToIdToUserInput | TicketUpdateManyWithWhereWithoutUser_Ticket_assignedToIdToUserInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput = {
    create?: XOR<TicketCreateWithoutUser_Ticket_requestedByIdToUserInput, TicketUncheckedCreateWithoutUser_Ticket_requestedByIdToUserInput> | TicketCreateWithoutUser_Ticket_requestedByIdToUserInput[] | TicketUncheckedCreateWithoutUser_Ticket_requestedByIdToUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUser_Ticket_requestedByIdToUserInput | TicketCreateOrConnectWithoutUser_Ticket_requestedByIdToUserInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutUser_Ticket_requestedByIdToUserInput | TicketUpsertWithWhereUniqueWithoutUser_Ticket_requestedByIdToUserInput[]
    createMany?: TicketCreateManyUser_Ticket_requestedByIdToUserInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutUser_Ticket_requestedByIdToUserInput | TicketUpdateWithWhereUniqueWithoutUser_Ticket_requestedByIdToUserInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutUser_Ticket_requestedByIdToUserInput | TicketUpdateManyWithWhereWithoutUser_Ticket_requestedByIdToUserInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutUserInput, TicketAttachmentUncheckedCreateWithoutUserInput> | TicketAttachmentCreateWithoutUserInput[] | TicketAttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutUserInput | TicketAttachmentCreateOrConnectWithoutUserInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutUserInput | TicketAttachmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketAttachmentCreateManyUserInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutUserInput | TicketAttachmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutUserInput | TicketAttachmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutUserInput | TicketCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutUserInput | TicketCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutUserInput | TicketCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketHistoryCreateWithoutUserInput, TicketHistoryUncheckedCreateWithoutUserInput> | TicketHistoryCreateWithoutUserInput[] | TicketHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutUserInput | TicketHistoryCreateOrConnectWithoutUserInput[]
    upsert?: TicketHistoryUpsertWithWhereUniqueWithoutUserInput | TicketHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketHistoryCreateManyUserInputEnvelope
    set?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    disconnect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    delete?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    update?: TicketHistoryUpdateWithWhereUniqueWithoutUserInput | TicketHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketHistoryUpdateManyWithWhereWithoutUserInput | TicketHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketHistoryScalarWhereInput | TicketHistoryScalarWhereInput[]
  }

  export type ContractCreateNestedManyWithoutVendorInput = {
    create?: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput> | ContractCreateWithoutVendorInput[] | ContractUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutVendorInput | ContractCreateOrConnectWithoutVendorInput[]
    createMany?: ContractCreateManyVendorInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput> | ContractCreateWithoutVendorInput[] | ContractUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutVendorInput | ContractCreateOrConnectWithoutVendorInput[]
    createMany?: ContractCreateManyVendorInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type ContractUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput> | ContractCreateWithoutVendorInput[] | ContractUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutVendorInput | ContractCreateOrConnectWithoutVendorInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutVendorInput | ContractUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ContractCreateManyVendorInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutVendorInput | ContractUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutVendorInput | ContractUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput> | ContractCreateWithoutVendorInput[] | ContractUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutVendorInput | ContractCreateOrConnectWithoutVendorInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutVendorInput | ContractUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ContractCreateManyVendorInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutVendorInput | ContractUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutVendorInput | ContractUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type webmes_UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<webmes_UserRoleCreateWithoutUserInput, webmes_UserRoleUncheckedCreateWithoutUserInput> | webmes_UserRoleCreateWithoutUserInput[] | webmes_UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: webmes_UserRoleCreateOrConnectWithoutUserInput | webmes_UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: webmes_UserRoleCreateManyUserInputEnvelope
    connect?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
  }

  export type webmes_UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<webmes_UserRoleCreateWithoutUserInput, webmes_UserRoleUncheckedCreateWithoutUserInput> | webmes_UserRoleCreateWithoutUserInput[] | webmes_UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: webmes_UserRoleCreateOrConnectWithoutUserInput | webmes_UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: webmes_UserRoleCreateManyUserInputEnvelope
    connect?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
  }

  export type webmes_UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<webmes_UserRoleCreateWithoutUserInput, webmes_UserRoleUncheckedCreateWithoutUserInput> | webmes_UserRoleCreateWithoutUserInput[] | webmes_UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: webmes_UserRoleCreateOrConnectWithoutUserInput | webmes_UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: webmes_UserRoleUpsertWithWhereUniqueWithoutUserInput | webmes_UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: webmes_UserRoleCreateManyUserInputEnvelope
    set?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    disconnect?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    delete?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    connect?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    update?: webmes_UserRoleUpdateWithWhereUniqueWithoutUserInput | webmes_UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: webmes_UserRoleUpdateManyWithWhereWithoutUserInput | webmes_UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: webmes_UserRoleScalarWhereInput | webmes_UserRoleScalarWhereInput[]
  }

  export type webmes_UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<webmes_UserRoleCreateWithoutUserInput, webmes_UserRoleUncheckedCreateWithoutUserInput> | webmes_UserRoleCreateWithoutUserInput[] | webmes_UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: webmes_UserRoleCreateOrConnectWithoutUserInput | webmes_UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: webmes_UserRoleUpsertWithWhereUniqueWithoutUserInput | webmes_UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: webmes_UserRoleCreateManyUserInputEnvelope
    set?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    disconnect?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    delete?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    connect?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    update?: webmes_UserRoleUpdateWithWhereUniqueWithoutUserInput | webmes_UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: webmes_UserRoleUpdateManyWithWhereWithoutUserInput | webmes_UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: webmes_UserRoleScalarWhereInput | webmes_UserRoleScalarWhereInput[]
  }

  export type webmes_RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<webmes_RolePermissionCreateWithoutRoleInput, webmes_RolePermissionUncheckedCreateWithoutRoleInput> | webmes_RolePermissionCreateWithoutRoleInput[] | webmes_RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: webmes_RolePermissionCreateOrConnectWithoutRoleInput | webmes_RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: webmes_RolePermissionCreateManyRoleInputEnvelope
    connect?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
  }

  export type webmes_UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<webmes_UserRoleCreateWithoutRoleInput, webmes_UserRoleUncheckedCreateWithoutRoleInput> | webmes_UserRoleCreateWithoutRoleInput[] | webmes_UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: webmes_UserRoleCreateOrConnectWithoutRoleInput | webmes_UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: webmes_UserRoleCreateManyRoleInputEnvelope
    connect?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
  }

  export type webmes_RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<webmes_RolePermissionCreateWithoutRoleInput, webmes_RolePermissionUncheckedCreateWithoutRoleInput> | webmes_RolePermissionCreateWithoutRoleInput[] | webmes_RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: webmes_RolePermissionCreateOrConnectWithoutRoleInput | webmes_RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: webmes_RolePermissionCreateManyRoleInputEnvelope
    connect?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
  }

  export type webmes_UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<webmes_UserRoleCreateWithoutRoleInput, webmes_UserRoleUncheckedCreateWithoutRoleInput> | webmes_UserRoleCreateWithoutRoleInput[] | webmes_UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: webmes_UserRoleCreateOrConnectWithoutRoleInput | webmes_UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: webmes_UserRoleCreateManyRoleInputEnvelope
    connect?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
  }

  export type webmes_RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<webmes_RolePermissionCreateWithoutRoleInput, webmes_RolePermissionUncheckedCreateWithoutRoleInput> | webmes_RolePermissionCreateWithoutRoleInput[] | webmes_RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: webmes_RolePermissionCreateOrConnectWithoutRoleInput | webmes_RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: webmes_RolePermissionUpsertWithWhereUniqueWithoutRoleInput | webmes_RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: webmes_RolePermissionCreateManyRoleInputEnvelope
    set?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    disconnect?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    delete?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    connect?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    update?: webmes_RolePermissionUpdateWithWhereUniqueWithoutRoleInput | webmes_RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: webmes_RolePermissionUpdateManyWithWhereWithoutRoleInput | webmes_RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: webmes_RolePermissionScalarWhereInput | webmes_RolePermissionScalarWhereInput[]
  }

  export type webmes_UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<webmes_UserRoleCreateWithoutRoleInput, webmes_UserRoleUncheckedCreateWithoutRoleInput> | webmes_UserRoleCreateWithoutRoleInput[] | webmes_UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: webmes_UserRoleCreateOrConnectWithoutRoleInput | webmes_UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: webmes_UserRoleUpsertWithWhereUniqueWithoutRoleInput | webmes_UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: webmes_UserRoleCreateManyRoleInputEnvelope
    set?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    disconnect?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    delete?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    connect?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    update?: webmes_UserRoleUpdateWithWhereUniqueWithoutRoleInput | webmes_UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: webmes_UserRoleUpdateManyWithWhereWithoutRoleInput | webmes_UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: webmes_UserRoleScalarWhereInput | webmes_UserRoleScalarWhereInput[]
  }

  export type webmes_RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<webmes_RolePermissionCreateWithoutRoleInput, webmes_RolePermissionUncheckedCreateWithoutRoleInput> | webmes_RolePermissionCreateWithoutRoleInput[] | webmes_RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: webmes_RolePermissionCreateOrConnectWithoutRoleInput | webmes_RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: webmes_RolePermissionUpsertWithWhereUniqueWithoutRoleInput | webmes_RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: webmes_RolePermissionCreateManyRoleInputEnvelope
    set?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    disconnect?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    delete?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    connect?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    update?: webmes_RolePermissionUpdateWithWhereUniqueWithoutRoleInput | webmes_RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: webmes_RolePermissionUpdateManyWithWhereWithoutRoleInput | webmes_RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: webmes_RolePermissionScalarWhereInput | webmes_RolePermissionScalarWhereInput[]
  }

  export type webmes_UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<webmes_UserRoleCreateWithoutRoleInput, webmes_UserRoleUncheckedCreateWithoutRoleInput> | webmes_UserRoleCreateWithoutRoleInput[] | webmes_UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: webmes_UserRoleCreateOrConnectWithoutRoleInput | webmes_UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: webmes_UserRoleUpsertWithWhereUniqueWithoutRoleInput | webmes_UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: webmes_UserRoleCreateManyRoleInputEnvelope
    set?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    disconnect?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    delete?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    connect?: webmes_UserRoleWhereUniqueInput | webmes_UserRoleWhereUniqueInput[]
    update?: webmes_UserRoleUpdateWithWhereUniqueWithoutRoleInput | webmes_UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: webmes_UserRoleUpdateManyWithWhereWithoutRoleInput | webmes_UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: webmes_UserRoleScalarWhereInput | webmes_UserRoleScalarWhereInput[]
  }

  export type webmes_RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<webmes_RolePermissionCreateWithoutPermissionInput, webmes_RolePermissionUncheckedCreateWithoutPermissionInput> | webmes_RolePermissionCreateWithoutPermissionInput[] | webmes_RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: webmes_RolePermissionCreateOrConnectWithoutPermissionInput | webmes_RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: webmes_RolePermissionCreateManyPermissionInputEnvelope
    connect?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
  }

  export type webmes_RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<webmes_RolePermissionCreateWithoutPermissionInput, webmes_RolePermissionUncheckedCreateWithoutPermissionInput> | webmes_RolePermissionCreateWithoutPermissionInput[] | webmes_RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: webmes_RolePermissionCreateOrConnectWithoutPermissionInput | webmes_RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: webmes_RolePermissionCreateManyPermissionInputEnvelope
    connect?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
  }

  export type webmes_RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<webmes_RolePermissionCreateWithoutPermissionInput, webmes_RolePermissionUncheckedCreateWithoutPermissionInput> | webmes_RolePermissionCreateWithoutPermissionInput[] | webmes_RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: webmes_RolePermissionCreateOrConnectWithoutPermissionInput | webmes_RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: webmes_RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | webmes_RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: webmes_RolePermissionCreateManyPermissionInputEnvelope
    set?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    disconnect?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    delete?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    connect?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    update?: webmes_RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | webmes_RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: webmes_RolePermissionUpdateManyWithWhereWithoutPermissionInput | webmes_RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: webmes_RolePermissionScalarWhereInput | webmes_RolePermissionScalarWhereInput[]
  }

  export type webmes_RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<webmes_RolePermissionCreateWithoutPermissionInput, webmes_RolePermissionUncheckedCreateWithoutPermissionInput> | webmes_RolePermissionCreateWithoutPermissionInput[] | webmes_RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: webmes_RolePermissionCreateOrConnectWithoutPermissionInput | webmes_RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: webmes_RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | webmes_RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: webmes_RolePermissionCreateManyPermissionInputEnvelope
    set?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    disconnect?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    delete?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    connect?: webmes_RolePermissionWhereUniqueInput | webmes_RolePermissionWhereUniqueInput[]
    update?: webmes_RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | webmes_RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: webmes_RolePermissionUpdateManyWithWhereWithoutPermissionInput | webmes_RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: webmes_RolePermissionScalarWhereInput | webmes_RolePermissionScalarWhereInput[]
  }

  export type webmes_UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<webmes_UserCreateWithoutRolesInput, webmes_UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: webmes_UserCreateOrConnectWithoutRolesInput
    connect?: webmes_UserWhereUniqueInput
  }

  export type webmes_RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<webmes_RoleCreateWithoutUsersInput, webmes_RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: webmes_RoleCreateOrConnectWithoutUsersInput
    connect?: webmes_RoleWhereUniqueInput
  }

  export type webmes_UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<webmes_UserCreateWithoutRolesInput, webmes_UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: webmes_UserCreateOrConnectWithoutRolesInput
    upsert?: webmes_UserUpsertWithoutRolesInput
    connect?: webmes_UserWhereUniqueInput
    update?: XOR<XOR<webmes_UserUpdateToOneWithWhereWithoutRolesInput, webmes_UserUpdateWithoutRolesInput>, webmes_UserUncheckedUpdateWithoutRolesInput>
  }

  export type webmes_RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<webmes_RoleCreateWithoutUsersInput, webmes_RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: webmes_RoleCreateOrConnectWithoutUsersInput
    upsert?: webmes_RoleUpsertWithoutUsersInput
    connect?: webmes_RoleWhereUniqueInput
    update?: XOR<XOR<webmes_RoleUpdateToOneWithWhereWithoutUsersInput, webmes_RoleUpdateWithoutUsersInput>, webmes_RoleUncheckedUpdateWithoutUsersInput>
  }

  export type webmes_RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<webmes_RoleCreateWithoutPermissionsInput, webmes_RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: webmes_RoleCreateOrConnectWithoutPermissionsInput
    connect?: webmes_RoleWhereUniqueInput
  }

  export type webmes_PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<webmes_PermissionCreateWithoutRolesInput, webmes_PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: webmes_PermissionCreateOrConnectWithoutRolesInput
    connect?: webmes_PermissionWhereUniqueInput
  }

  export type webmes_RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<webmes_RoleCreateWithoutPermissionsInput, webmes_RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: webmes_RoleCreateOrConnectWithoutPermissionsInput
    upsert?: webmes_RoleUpsertWithoutPermissionsInput
    connect?: webmes_RoleWhereUniqueInput
    update?: XOR<XOR<webmes_RoleUpdateToOneWithWhereWithoutPermissionsInput, webmes_RoleUpdateWithoutPermissionsInput>, webmes_RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type webmes_PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<webmes_PermissionCreateWithoutRolesInput, webmes_PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: webmes_PermissionCreateOrConnectWithoutRolesInput
    upsert?: webmes_PermissionUpsertWithoutRolesInput
    connect?: webmes_PermissionWhereUniqueInput
    update?: XOR<XOR<webmes_PermissionUpdateToOneWithWhereWithoutRolesInput, webmes_PermissionUpdateWithoutRolesInput>, webmes_PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserCreateWithoutAssetInput = {
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Document?: DocumentCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssetInput = {
    id?: number
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssetInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssetInput, UserUncheckedCreateWithoutAssetInput>
  }

  export type AssetHistoryCreateWithoutAssetInput = {
    changedAt?: Date | string
    reason?: string | null
    User_AssetHistory_newOwnerIdToUser?: UserCreateNestedOneWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput
    User_AssetHistory_oldOwnerIdToUser?: UserCreateNestedOneWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput
  }

  export type AssetHistoryUncheckedCreateWithoutAssetInput = {
    id?: number
    oldOwnerId?: number | null
    newOwnerId?: number | null
    changedAt?: Date | string
    reason?: string | null
  }

  export type AssetHistoryCreateOrConnectWithoutAssetInput = {
    where: AssetHistoryWhereUniqueInput
    create: XOR<AssetHistoryCreateWithoutAssetInput, AssetHistoryUncheckedCreateWithoutAssetInput>
  }

  export type AssetHistoryCreateManyAssetInputEnvelope = {
    data: AssetHistoryCreateManyAssetInput | AssetHistoryCreateManyAssetInput[]
  }

  export type LicenseCreateWithoutAssetInput = {
    softwareName: string
    licenseKey: string
    expireDate: Date | string
  }

  export type LicenseUncheckedCreateWithoutAssetInput = {
    id?: number
    softwareName: string
    licenseKey: string
    expireDate: Date | string
  }

  export type LicenseCreateOrConnectWithoutAssetInput = {
    where: LicenseWhereUniqueInput
    create: XOR<LicenseCreateWithoutAssetInput, LicenseUncheckedCreateWithoutAssetInput>
  }

  export type LicenseCreateManyAssetInputEnvelope = {
    data: LicenseCreateManyAssetInput | LicenseCreateManyAssetInput[]
  }

  export type MonitorCreateWithoutAssetInput = {
    targetName: string
    ipAddress: string
    status: string
    lastCheck: Date | string
  }

  export type MonitorUncheckedCreateWithoutAssetInput = {
    id?: number
    targetName: string
    ipAddress: string
    status: string
    lastCheck: Date | string
  }

  export type MonitorCreateOrConnectWithoutAssetInput = {
    where: MonitorWhereUniqueInput
    create: XOR<MonitorCreateWithoutAssetInput, MonitorUncheckedCreateWithoutAssetInput>
  }

  export type TicketCreateWithoutAssetInput = {
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutTicketInput
    User_Ticket_assignedToIdToUser?: UserCreateNestedOneWithoutTicket_Ticket_assignedToIdToUserInput
    User_Ticket_requestedByIdToUser: UserCreateNestedOneWithoutTicket_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutTicketInput
    TicketComment?: TicketCommentCreateNestedManyWithoutTicketInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutAssetInput = {
    id?: number
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    requestedById: number
    assignedToId?: number | null
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutTicketInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutAssetInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAssetInput, TicketUncheckedCreateWithoutAssetInput>
  }

  export type TicketCreateManyAssetInputEnvelope = {
    data: TicketCreateManyAssetInput | TicketCreateManyAssetInput[]
  }

  export type ContractCreateWithoutAssetInput = {
    title: string
    contractNo: string
    startDate: Date | string
    endDate: Date | string
    amount?: number | null
    description?: string | null
    Vendor: VendorCreateNestedOneWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutAssetInput = {
    id?: number
    title: string
    contractNo: string
    startDate: Date | string
    endDate: Date | string
    amount?: number | null
    description?: string | null
    vendorId: number
  }

  export type ContractCreateOrConnectWithoutAssetInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutAssetInput, ContractUncheckedCreateWithoutAssetInput>
  }

  export type UserUpsertWithoutAssetInput = {
    update: XOR<UserUpdateWithoutAssetInput, UserUncheckedUpdateWithoutAssetInput>
    create: XOR<UserCreateWithoutAssetInput, UserUncheckedCreateWithoutAssetInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssetInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssetInput, UserUncheckedUpdateWithoutAssetInput>
  }

  export type UserUpdateWithoutAssetInput = {
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Document?: DocumentUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AssetHistoryUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetHistoryWhereUniqueInput
    update: XOR<AssetHistoryUpdateWithoutAssetInput, AssetHistoryUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetHistoryCreateWithoutAssetInput, AssetHistoryUncheckedCreateWithoutAssetInput>
  }

  export type AssetHistoryUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetHistoryWhereUniqueInput
    data: XOR<AssetHistoryUpdateWithoutAssetInput, AssetHistoryUncheckedUpdateWithoutAssetInput>
  }

  export type AssetHistoryUpdateManyWithWhereWithoutAssetInput = {
    where: AssetHistoryScalarWhereInput
    data: XOR<AssetHistoryUpdateManyMutationInput, AssetHistoryUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetHistoryScalarWhereInput = {
    AND?: AssetHistoryScalarWhereInput | AssetHistoryScalarWhereInput[]
    OR?: AssetHistoryScalarWhereInput[]
    NOT?: AssetHistoryScalarWhereInput | AssetHistoryScalarWhereInput[]
    id?: IntFilter<"AssetHistory"> | number
    assetId?: IntFilter<"AssetHistory"> | number
    oldOwnerId?: IntNullableFilter<"AssetHistory"> | number | null
    newOwnerId?: IntNullableFilter<"AssetHistory"> | number | null
    changedAt?: DateTimeFilter<"AssetHistory"> | Date | string
    reason?: StringNullableFilter<"AssetHistory"> | string | null
  }

  export type LicenseUpsertWithWhereUniqueWithoutAssetInput = {
    where: LicenseWhereUniqueInput
    update: XOR<LicenseUpdateWithoutAssetInput, LicenseUncheckedUpdateWithoutAssetInput>
    create: XOR<LicenseCreateWithoutAssetInput, LicenseUncheckedCreateWithoutAssetInput>
  }

  export type LicenseUpdateWithWhereUniqueWithoutAssetInput = {
    where: LicenseWhereUniqueInput
    data: XOR<LicenseUpdateWithoutAssetInput, LicenseUncheckedUpdateWithoutAssetInput>
  }

  export type LicenseUpdateManyWithWhereWithoutAssetInput = {
    where: LicenseScalarWhereInput
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyWithoutAssetInput>
  }

  export type LicenseScalarWhereInput = {
    AND?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
    OR?: LicenseScalarWhereInput[]
    NOT?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
    id?: IntFilter<"License"> | number
    softwareName?: StringFilter<"License"> | string
    licenseKey?: StringFilter<"License"> | string
    expireDate?: DateTimeFilter<"License"> | Date | string
    assetId?: IntFilter<"License"> | number
  }

  export type MonitorUpsertWithoutAssetInput = {
    update: XOR<MonitorUpdateWithoutAssetInput, MonitorUncheckedUpdateWithoutAssetInput>
    create: XOR<MonitorCreateWithoutAssetInput, MonitorUncheckedCreateWithoutAssetInput>
    where?: MonitorWhereInput
  }

  export type MonitorUpdateToOneWithWhereWithoutAssetInput = {
    where?: MonitorWhereInput
    data: XOR<MonitorUpdateWithoutAssetInput, MonitorUncheckedUpdateWithoutAssetInput>
  }

  export type MonitorUpdateWithoutAssetInput = {
    targetName?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitorUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetName?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutAssetInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutAssetInput, TicketUncheckedUpdateWithoutAssetInput>
    create: XOR<TicketCreateWithoutAssetInput, TicketUncheckedCreateWithoutAssetInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutAssetInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutAssetInput, TicketUncheckedUpdateWithoutAssetInput>
  }

  export type TicketUpdateManyWithWhereWithoutAssetInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutAssetInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: IntFilter<"Ticket"> | number
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    resolutionNote?: StringNullableFilter<"Ticket"> | string | null
    status?: StringFilter<"Ticket"> | string
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    assetId?: IntNullableFilter<"Ticket"> | number | null
    requestedById?: IntFilter<"Ticket"> | number
    assignedToId?: IntNullableFilter<"Ticket"> | number | null
  }

  export type ContractUpsertWithWhereUniqueWithoutAssetInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutAssetInput, ContractUncheckedUpdateWithoutAssetInput>
    create: XOR<ContractCreateWithoutAssetInput, ContractUncheckedCreateWithoutAssetInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutAssetInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutAssetInput, ContractUncheckedUpdateWithoutAssetInput>
  }

  export type ContractUpdateManyWithWhereWithoutAssetInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutAssetInput>
  }

  export type ContractScalarWhereInput = {
    AND?: ContractScalarWhereInput | ContractScalarWhereInput[]
    OR?: ContractScalarWhereInput[]
    NOT?: ContractScalarWhereInput | ContractScalarWhereInput[]
    id?: IntFilter<"Contract"> | number
    title?: StringFilter<"Contract"> | string
    contractNo?: StringFilter<"Contract"> | string
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeFilter<"Contract"> | Date | string
    amount?: FloatNullableFilter<"Contract"> | number | null
    description?: StringNullableFilter<"Contract"> | string | null
    vendorId?: IntFilter<"Contract"> | number
  }

  export type AssetCreateWithoutAssetHistoryInput = {
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    User?: UserCreateNestedOneWithoutAssetInput
    License?: LicenseCreateNestedManyWithoutAssetInput
    Monitor?: MonitorCreateNestedOneWithoutAssetInput
    Ticket?: TicketCreateNestedManyWithoutAssetInput
    Contract?: ContractCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutAssetHistoryInput = {
    id?: number
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    ownerId?: number | null
    License?: LicenseUncheckedCreateNestedManyWithoutAssetInput
    Monitor?: MonitorUncheckedCreateNestedOneWithoutAssetInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutAssetInput
    Contract?: ContractUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutAssetHistoryInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutAssetHistoryInput, AssetUncheckedCreateWithoutAssetHistoryInput>
  }

  export type UserCreateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput = {
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Document?: DocumentCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput = {
    id?: number
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetUncheckedCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput, UserUncheckedCreateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput>
  }

  export type UserCreateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput = {
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Document?: DocumentCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput = {
    id?: number
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetUncheckedCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput, UserUncheckedCreateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput>
  }

  export type AssetUpsertWithoutAssetHistoryInput = {
    update: XOR<AssetUpdateWithoutAssetHistoryInput, AssetUncheckedUpdateWithoutAssetHistoryInput>
    create: XOR<AssetCreateWithoutAssetHistoryInput, AssetUncheckedCreateWithoutAssetHistoryInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutAssetHistoryInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutAssetHistoryInput, AssetUncheckedUpdateWithoutAssetHistoryInput>
  }

  export type AssetUpdateWithoutAssetHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutAssetNestedInput
    License?: LicenseUpdateManyWithoutAssetNestedInput
    Monitor?: MonitorUpdateOneWithoutAssetNestedInput
    Ticket?: TicketUpdateManyWithoutAssetNestedInput
    Contract?: ContractUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutAssetHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    License?: LicenseUncheckedUpdateManyWithoutAssetNestedInput
    Monitor?: MonitorUncheckedUpdateOneWithoutAssetNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutAssetNestedInput
    Contract?: ContractUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type UserUpsertWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput = {
    update: XOR<UserUpdateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput, UserUncheckedUpdateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput>
    create: XOR<UserCreateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput, UserUncheckedCreateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput, UserUncheckedUpdateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput>
  }

  export type UserUpdateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Document?: DocumentUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUncheckedUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput = {
    update: XOR<UserUpdateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput, UserUncheckedUpdateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput>
    create: XOR<UserCreateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput, UserUncheckedCreateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput, UserUncheckedUpdateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput>
  }

  export type UserUpdateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Document?: DocumentUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUncheckedUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogInput = {
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    Document?: DocumentCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogInput = {
    id?: number
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetUncheckedCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
  }

  export type UserUpsertWithoutAuditLogInput = {
    update: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>
  }

  export type UserUpdateWithoutAuditLogInput = {
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    Document?: DocumentUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUncheckedUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VendorCreateWithoutContractInput = {
    name: string
    contact?: string | null
    email?: string | null
    phone?: string | null
    website?: string | null
    address?: string | null
  }

  export type VendorUncheckedCreateWithoutContractInput = {
    id?: number
    name: string
    contact?: string | null
    email?: string | null
    phone?: string | null
    website?: string | null
    address?: string | null
  }

  export type VendorCreateOrConnectWithoutContractInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutContractInput, VendorUncheckedCreateWithoutContractInput>
  }

  export type AssetCreateWithoutContractInput = {
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    User?: UserCreateNestedOneWithoutAssetInput
    AssetHistory?: AssetHistoryCreateNestedManyWithoutAssetInput
    License?: LicenseCreateNestedManyWithoutAssetInput
    Monitor?: MonitorCreateNestedOneWithoutAssetInput
    Ticket?: TicketCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutContractInput = {
    id?: number
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    ownerId?: number | null
    AssetHistory?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
    License?: LicenseUncheckedCreateNestedManyWithoutAssetInput
    Monitor?: MonitorUncheckedCreateNestedOneWithoutAssetInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutContractInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutContractInput, AssetUncheckedCreateWithoutContractInput>
  }

  export type VendorUpsertWithoutContractInput = {
    update: XOR<VendorUpdateWithoutContractInput, VendorUncheckedUpdateWithoutContractInput>
    create: XOR<VendorCreateWithoutContractInput, VendorUncheckedCreateWithoutContractInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutContractInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutContractInput, VendorUncheckedUpdateWithoutContractInput>
  }

  export type VendorUpdateWithoutContractInput = {
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendorUncheckedUpdateWithoutContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetUpsertWithWhereUniqueWithoutContractInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutContractInput, AssetUncheckedUpdateWithoutContractInput>
    create: XOR<AssetCreateWithoutContractInput, AssetUncheckedCreateWithoutContractInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutContractInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutContractInput, AssetUncheckedUpdateWithoutContractInput>
  }

  export type AssetUpdateManyWithWhereWithoutContractInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutContractInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: IntFilter<"Asset"> | number
    name?: StringFilter<"Asset"> | string
    serialNumber?: StringFilter<"Asset"> | string
    assetTag?: StringNullableFilter<"Asset"> | string | null
    type?: StringFilter<"Asset"> | string
    brand?: StringNullableFilter<"Asset"> | string | null
    model?: StringNullableFilter<"Asset"> | string | null
    spec?: StringNullableFilter<"Asset"> | string | null
    purchaseDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
    warrantyUntil?: DateTimeNullableFilter<"Asset"> | Date | string | null
    location?: StringNullableFilter<"Asset"> | string | null
    status?: StringFilter<"Asset"> | string
    ownerId?: IntNullableFilter<"Asset"> | number | null
  }

  export type employeesCreateWithoutDepartmentsInput = {
    first_name: string
    last_name: string
    employee_code: string
    is_dept_head?: boolean
    is_active?: boolean
    employee_roles?: employee_rolesCreateNestedManyWithoutEmployeesInput
  }

  export type employeesUncheckedCreateWithoutDepartmentsInput = {
    id?: number
    first_name: string
    last_name: string
    employee_code: string
    is_dept_head?: boolean
    is_active?: boolean
    employee_roles?: employee_rolesUncheckedCreateNestedManyWithoutEmployeesInput
  }

  export type employeesCreateOrConnectWithoutDepartmentsInput = {
    where: employeesWhereUniqueInput
    create: XOR<employeesCreateWithoutDepartmentsInput, employeesUncheckedCreateWithoutDepartmentsInput>
  }

  export type employeesCreateManyDepartmentsInputEnvelope = {
    data: employeesCreateManyDepartmentsInput | employeesCreateManyDepartmentsInput[]
  }

  export type employeesUpsertWithWhereUniqueWithoutDepartmentsInput = {
    where: employeesWhereUniqueInput
    update: XOR<employeesUpdateWithoutDepartmentsInput, employeesUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<employeesCreateWithoutDepartmentsInput, employeesUncheckedCreateWithoutDepartmentsInput>
  }

  export type employeesUpdateWithWhereUniqueWithoutDepartmentsInput = {
    where: employeesWhereUniqueInput
    data: XOR<employeesUpdateWithoutDepartmentsInput, employeesUncheckedUpdateWithoutDepartmentsInput>
  }

  export type employeesUpdateManyWithWhereWithoutDepartmentsInput = {
    where: employeesScalarWhereInput
    data: XOR<employeesUpdateManyMutationInput, employeesUncheckedUpdateManyWithoutDepartmentsInput>
  }

  export type employeesScalarWhereInput = {
    AND?: employeesScalarWhereInput | employeesScalarWhereInput[]
    OR?: employeesScalarWhereInput[]
    NOT?: employeesScalarWhereInput | employeesScalarWhereInput[]
    id?: IntFilter<"employees"> | number
    first_name?: StringFilter<"employees"> | string
    last_name?: StringFilter<"employees"> | string
    employee_code?: StringFilter<"employees"> | string
    department_id?: IntFilter<"employees"> | number
    is_dept_head?: BoolFilter<"employees"> | boolean
    is_active?: BoolFilter<"employees"> | boolean
  }

  export type UserCreateWithoutDocumentInput = {
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentInput = {
    id?: number
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetUncheckedCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
  }

  export type UserUpsertWithoutDocumentInput = {
    update: XOR<UserUpdateWithoutDocumentInput, UserUncheckedUpdateWithoutDocumentInput>
    create: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentInput, UserUncheckedUpdateWithoutDocumentInput>
  }

  export type UserUpdateWithoutDocumentInput = {
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUncheckedUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type employeesCreateWithoutEmployee_rolesInput = {
    first_name: string
    last_name: string
    employee_code: string
    is_dept_head?: boolean
    is_active?: boolean
    departments: departmentsCreateNestedOneWithoutEmployeesInput
  }

  export type employeesUncheckedCreateWithoutEmployee_rolesInput = {
    id?: number
    first_name: string
    last_name: string
    employee_code: string
    department_id: number
    is_dept_head?: boolean
    is_active?: boolean
  }

  export type employeesCreateOrConnectWithoutEmployee_rolesInput = {
    where: employeesWhereUniqueInput
    create: XOR<employeesCreateWithoutEmployee_rolesInput, employeesUncheckedCreateWithoutEmployee_rolesInput>
  }

  export type rolesCreateWithoutEmployee_rolesInput = {
    name: string
  }

  export type rolesUncheckedCreateWithoutEmployee_rolesInput = {
    id?: number
    name: string
  }

  export type rolesCreateOrConnectWithoutEmployee_rolesInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutEmployee_rolesInput, rolesUncheckedCreateWithoutEmployee_rolesInput>
  }

  export type employeesUpsertWithoutEmployee_rolesInput = {
    update: XOR<employeesUpdateWithoutEmployee_rolesInput, employeesUncheckedUpdateWithoutEmployee_rolesInput>
    create: XOR<employeesCreateWithoutEmployee_rolesInput, employeesUncheckedCreateWithoutEmployee_rolesInput>
    where?: employeesWhereInput
  }

  export type employeesUpdateToOneWithWhereWithoutEmployee_rolesInput = {
    where?: employeesWhereInput
    data: XOR<employeesUpdateWithoutEmployee_rolesInput, employeesUncheckedUpdateWithoutEmployee_rolesInput>
  }

  export type employeesUpdateWithoutEmployee_rolesInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    departments?: departmentsUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type employeesUncheckedUpdateWithoutEmployee_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type rolesUpsertWithoutEmployee_rolesInput = {
    update: XOR<rolesUpdateWithoutEmployee_rolesInput, rolesUncheckedUpdateWithoutEmployee_rolesInput>
    create: XOR<rolesCreateWithoutEmployee_rolesInput, rolesUncheckedCreateWithoutEmployee_rolesInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutEmployee_rolesInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutEmployee_rolesInput, rolesUncheckedUpdateWithoutEmployee_rolesInput>
  }

  export type rolesUpdateWithoutEmployee_rolesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type rolesUncheckedUpdateWithoutEmployee_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type employee_rolesCreateWithoutEmployeesInput = {
    roles: rolesCreateNestedOneWithoutEmployee_rolesInput
  }

  export type employee_rolesUncheckedCreateWithoutEmployeesInput = {
    role_id: number
  }

  export type employee_rolesCreateOrConnectWithoutEmployeesInput = {
    where: employee_rolesWhereUniqueInput
    create: XOR<employee_rolesCreateWithoutEmployeesInput, employee_rolesUncheckedCreateWithoutEmployeesInput>
  }

  export type employee_rolesCreateManyEmployeesInputEnvelope = {
    data: employee_rolesCreateManyEmployeesInput | employee_rolesCreateManyEmployeesInput[]
  }

  export type departmentsCreateWithoutEmployeesInput = {
    name: string
  }

  export type departmentsUncheckedCreateWithoutEmployeesInput = {
    id?: number
    name: string
  }

  export type departmentsCreateOrConnectWithoutEmployeesInput = {
    where: departmentsWhereUniqueInput
    create: XOR<departmentsCreateWithoutEmployeesInput, departmentsUncheckedCreateWithoutEmployeesInput>
  }

  export type employee_rolesUpsertWithWhereUniqueWithoutEmployeesInput = {
    where: employee_rolesWhereUniqueInput
    update: XOR<employee_rolesUpdateWithoutEmployeesInput, employee_rolesUncheckedUpdateWithoutEmployeesInput>
    create: XOR<employee_rolesCreateWithoutEmployeesInput, employee_rolesUncheckedCreateWithoutEmployeesInput>
  }

  export type employee_rolesUpdateWithWhereUniqueWithoutEmployeesInput = {
    where: employee_rolesWhereUniqueInput
    data: XOR<employee_rolesUpdateWithoutEmployeesInput, employee_rolesUncheckedUpdateWithoutEmployeesInput>
  }

  export type employee_rolesUpdateManyWithWhereWithoutEmployeesInput = {
    where: employee_rolesScalarWhereInput
    data: XOR<employee_rolesUpdateManyMutationInput, employee_rolesUncheckedUpdateManyWithoutEmployeesInput>
  }

  export type employee_rolesScalarWhereInput = {
    AND?: employee_rolesScalarWhereInput | employee_rolesScalarWhereInput[]
    OR?: employee_rolesScalarWhereInput[]
    NOT?: employee_rolesScalarWhereInput | employee_rolesScalarWhereInput[]
    employee_id?: IntFilter<"employee_roles"> | number
    role_id?: IntFilter<"employee_roles"> | number
  }

  export type departmentsUpsertWithoutEmployeesInput = {
    update: XOR<departmentsUpdateWithoutEmployeesInput, departmentsUncheckedUpdateWithoutEmployeesInput>
    create: XOR<departmentsCreateWithoutEmployeesInput, departmentsUncheckedCreateWithoutEmployeesInput>
    where?: departmentsWhereInput
  }

  export type departmentsUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: departmentsWhereInput
    data: XOR<departmentsUpdateWithoutEmployeesInput, departmentsUncheckedUpdateWithoutEmployeesInput>
  }

  export type departmentsUpdateWithoutEmployeesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type departmentsUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryItemCreateWithoutInventoryCategoryInput = {
    name: string
    description?: string | null
    barcode?: string | null
    serialNumber?: string | null
    stock?: number
    minStock?: number
    unit?: string | null
    imagePath?: string | null
    InventorySupplier?: InventorySupplierCreateNestedOneWithoutInventoryItemInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutInventoryCategoryInput = {
    id?: number
    name: string
    description?: string | null
    barcode?: string | null
    serialNumber?: string | null
    supplierId?: number | null
    stock?: number
    minStock?: number
    unit?: string | null
    imagePath?: string | null
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutInventoryCategoryInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutInventoryCategoryInput, InventoryItemUncheckedCreateWithoutInventoryCategoryInput>
  }

  export type InventoryItemCreateManyInventoryCategoryInputEnvelope = {
    data: InventoryItemCreateManyInventoryCategoryInput | InventoryItemCreateManyInventoryCategoryInput[]
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutInventoryCategoryInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutInventoryCategoryInput, InventoryItemUncheckedUpdateWithoutInventoryCategoryInput>
    create: XOR<InventoryItemCreateWithoutInventoryCategoryInput, InventoryItemUncheckedCreateWithoutInventoryCategoryInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutInventoryCategoryInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutInventoryCategoryInput, InventoryItemUncheckedUpdateWithoutInventoryCategoryInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutInventoryCategoryInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutInventoryCategoryInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    id?: IntFilter<"InventoryItem"> | number
    name?: StringFilter<"InventoryItem"> | string
    description?: StringNullableFilter<"InventoryItem"> | string | null
    barcode?: StringNullableFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableFilter<"InventoryItem"> | string | null
    categoryId?: IntFilter<"InventoryItem"> | number
    supplierId?: IntNullableFilter<"InventoryItem"> | number | null
    stock?: IntFilter<"InventoryItem"> | number
    minStock?: IntFilter<"InventoryItem"> | number
    unit?: StringNullableFilter<"InventoryItem"> | string | null
    imagePath?: StringNullableFilter<"InventoryItem"> | string | null
  }

  export type InventoryCategoryCreateWithoutInventoryItemInput = {
    name: string
  }

  export type InventoryCategoryUncheckedCreateWithoutInventoryItemInput = {
    id?: number
    name: string
  }

  export type InventoryCategoryCreateOrConnectWithoutInventoryItemInput = {
    where: InventoryCategoryWhereUniqueInput
    create: XOR<InventoryCategoryCreateWithoutInventoryItemInput, InventoryCategoryUncheckedCreateWithoutInventoryItemInput>
  }

  export type InventorySupplierCreateWithoutInventoryItemInput = {
    name: string
    contact?: string | null
    email?: string | null
    phone?: string | null
  }

  export type InventorySupplierUncheckedCreateWithoutInventoryItemInput = {
    id?: number
    name: string
    contact?: string | null
    email?: string | null
    phone?: string | null
  }

  export type InventorySupplierCreateOrConnectWithoutInventoryItemInput = {
    where: InventorySupplierWhereUniqueInput
    create: XOR<InventorySupplierCreateWithoutInventoryItemInput, InventorySupplierUncheckedCreateWithoutInventoryItemInput>
  }

  export type InventoryTransactionCreateWithoutInventoryItemInput = {
    type: string
    qty: number
    date?: Date | string
    note?: string | null
    barcode?: string | null
    User?: UserCreateNestedOneWithoutInventoryTransactionInput
  }

  export type InventoryTransactionUncheckedCreateWithoutInventoryItemInput = {
    id?: number
    type: string
    qty: number
    userId?: number | null
    date?: Date | string
    note?: string | null
    barcode?: string | null
  }

  export type InventoryTransactionCreateOrConnectWithoutInventoryItemInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutInventoryItemInput, InventoryTransactionUncheckedCreateWithoutInventoryItemInput>
  }

  export type InventoryTransactionCreateManyInventoryItemInputEnvelope = {
    data: InventoryTransactionCreateManyInventoryItemInput | InventoryTransactionCreateManyInventoryItemInput[]
  }

  export type InventoryCategoryUpsertWithoutInventoryItemInput = {
    update: XOR<InventoryCategoryUpdateWithoutInventoryItemInput, InventoryCategoryUncheckedUpdateWithoutInventoryItemInput>
    create: XOR<InventoryCategoryCreateWithoutInventoryItemInput, InventoryCategoryUncheckedCreateWithoutInventoryItemInput>
    where?: InventoryCategoryWhereInput
  }

  export type InventoryCategoryUpdateToOneWithWhereWithoutInventoryItemInput = {
    where?: InventoryCategoryWhereInput
    data: XOR<InventoryCategoryUpdateWithoutInventoryItemInput, InventoryCategoryUncheckedUpdateWithoutInventoryItemInput>
  }

  export type InventoryCategoryUpdateWithoutInventoryItemInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryCategoryUncheckedUpdateWithoutInventoryItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InventorySupplierUpsertWithoutInventoryItemInput = {
    update: XOR<InventorySupplierUpdateWithoutInventoryItemInput, InventorySupplierUncheckedUpdateWithoutInventoryItemInput>
    create: XOR<InventorySupplierCreateWithoutInventoryItemInput, InventorySupplierUncheckedCreateWithoutInventoryItemInput>
    where?: InventorySupplierWhereInput
  }

  export type InventorySupplierUpdateToOneWithWhereWithoutInventoryItemInput = {
    where?: InventorySupplierWhereInput
    data: XOR<InventorySupplierUpdateWithoutInventoryItemInput, InventorySupplierUncheckedUpdateWithoutInventoryItemInput>
  }

  export type InventorySupplierUpdateWithoutInventoryItemInput = {
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventorySupplierUncheckedUpdateWithoutInventoryItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryTransactionUpsertWithWhereUniqueWithoutInventoryItemInput = {
    where: InventoryTransactionWhereUniqueInput
    update: XOR<InventoryTransactionUpdateWithoutInventoryItemInput, InventoryTransactionUncheckedUpdateWithoutInventoryItemInput>
    create: XOR<InventoryTransactionCreateWithoutInventoryItemInput, InventoryTransactionUncheckedCreateWithoutInventoryItemInput>
  }

  export type InventoryTransactionUpdateWithWhereUniqueWithoutInventoryItemInput = {
    where: InventoryTransactionWhereUniqueInput
    data: XOR<InventoryTransactionUpdateWithoutInventoryItemInput, InventoryTransactionUncheckedUpdateWithoutInventoryItemInput>
  }

  export type InventoryTransactionUpdateManyWithWhereWithoutInventoryItemInput = {
    where: InventoryTransactionScalarWhereInput
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyWithoutInventoryItemInput>
  }

  export type InventoryTransactionScalarWhereInput = {
    AND?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
    OR?: InventoryTransactionScalarWhereInput[]
    NOT?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
    id?: IntFilter<"InventoryTransaction"> | number
    itemId?: IntFilter<"InventoryTransaction"> | number
    type?: StringFilter<"InventoryTransaction"> | string
    qty?: IntFilter<"InventoryTransaction"> | number
    userId?: IntNullableFilter<"InventoryTransaction"> | number | null
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
    note?: StringNullableFilter<"InventoryTransaction"> | string | null
    barcode?: StringNullableFilter<"InventoryTransaction"> | string | null
  }

  export type InventoryItemCreateWithoutInventorySupplierInput = {
    name: string
    description?: string | null
    barcode?: string | null
    serialNumber?: string | null
    stock?: number
    minStock?: number
    unit?: string | null
    imagePath?: string | null
    InventoryCategory: InventoryCategoryCreateNestedOneWithoutInventoryItemInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutInventorySupplierInput = {
    id?: number
    name: string
    description?: string | null
    barcode?: string | null
    serialNumber?: string | null
    categoryId: number
    stock?: number
    minStock?: number
    unit?: string | null
    imagePath?: string | null
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutInventorySupplierInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutInventorySupplierInput, InventoryItemUncheckedCreateWithoutInventorySupplierInput>
  }

  export type InventoryItemCreateManyInventorySupplierInputEnvelope = {
    data: InventoryItemCreateManyInventorySupplierInput | InventoryItemCreateManyInventorySupplierInput[]
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutInventorySupplierInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutInventorySupplierInput, InventoryItemUncheckedUpdateWithoutInventorySupplierInput>
    create: XOR<InventoryItemCreateWithoutInventorySupplierInput, InventoryItemUncheckedCreateWithoutInventorySupplierInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutInventorySupplierInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutInventorySupplierInput, InventoryItemUncheckedUpdateWithoutInventorySupplierInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutInventorySupplierInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutInventorySupplierInput>
  }

  export type InventoryItemCreateWithoutInventoryTransactionInput = {
    name: string
    description?: string | null
    barcode?: string | null
    serialNumber?: string | null
    stock?: number
    minStock?: number
    unit?: string | null
    imagePath?: string | null
    InventoryCategory: InventoryCategoryCreateNestedOneWithoutInventoryItemInput
    InventorySupplier?: InventorySupplierCreateNestedOneWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutInventoryTransactionInput = {
    id?: number
    name: string
    description?: string | null
    barcode?: string | null
    serialNumber?: string | null
    categoryId: number
    supplierId?: number | null
    stock?: number
    minStock?: number
    unit?: string | null
    imagePath?: string | null
  }

  export type InventoryItemCreateOrConnectWithoutInventoryTransactionInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutInventoryTransactionInput, InventoryItemUncheckedCreateWithoutInventoryTransactionInput>
  }

  export type UserCreateWithoutInventoryTransactionInput = {
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Document?: DocumentCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInventoryTransactionInput = {
    id?: number
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetUncheckedCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInventoryTransactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryTransactionInput, UserUncheckedCreateWithoutInventoryTransactionInput>
  }

  export type InventoryItemUpsertWithoutInventoryTransactionInput = {
    update: XOR<InventoryItemUpdateWithoutInventoryTransactionInput, InventoryItemUncheckedUpdateWithoutInventoryTransactionInput>
    create: XOR<InventoryItemCreateWithoutInventoryTransactionInput, InventoryItemUncheckedCreateWithoutInventoryTransactionInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutInventoryTransactionInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutInventoryTransactionInput, InventoryItemUncheckedUpdateWithoutInventoryTransactionInput>
  }

  export type InventoryItemUpdateWithoutInventoryTransactionInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    InventoryCategory?: InventoryCategoryUpdateOneRequiredWithoutInventoryItemNestedInput
    InventorySupplier?: InventorySupplierUpdateOneWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutInventoryTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutInventoryTransactionInput = {
    update: XOR<UserUpdateWithoutInventoryTransactionInput, UserUncheckedUpdateWithoutInventoryTransactionInput>
    create: XOR<UserCreateWithoutInventoryTransactionInput, UserUncheckedCreateWithoutInventoryTransactionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryTransactionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryTransactionInput, UserUncheckedUpdateWithoutInventoryTransactionInput>
  }

  export type UserUpdateWithoutInventoryTransactionInput = {
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Document?: DocumentUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUncheckedUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type it_employeesCreateWithoutIt_departmentsInput = {
    first_name: string
    last_name: string
    employee_code: string
    is_dept_head?: boolean
    is_active?: boolean
    it_employee_roles?: it_employee_rolesCreateNestedManyWithoutIt_employeesInput
  }

  export type it_employeesUncheckedCreateWithoutIt_departmentsInput = {
    id?: number
    first_name: string
    last_name: string
    employee_code: string
    is_dept_head?: boolean
    is_active?: boolean
    it_employee_roles?: it_employee_rolesUncheckedCreateNestedManyWithoutIt_employeesInput
  }

  export type it_employeesCreateOrConnectWithoutIt_departmentsInput = {
    where: it_employeesWhereUniqueInput
    create: XOR<it_employeesCreateWithoutIt_departmentsInput, it_employeesUncheckedCreateWithoutIt_departmentsInput>
  }

  export type it_employeesCreateManyIt_departmentsInputEnvelope = {
    data: it_employeesCreateManyIt_departmentsInput | it_employeesCreateManyIt_departmentsInput[]
  }

  export type it_employeesUpsertWithWhereUniqueWithoutIt_departmentsInput = {
    where: it_employeesWhereUniqueInput
    update: XOR<it_employeesUpdateWithoutIt_departmentsInput, it_employeesUncheckedUpdateWithoutIt_departmentsInput>
    create: XOR<it_employeesCreateWithoutIt_departmentsInput, it_employeesUncheckedCreateWithoutIt_departmentsInput>
  }

  export type it_employeesUpdateWithWhereUniqueWithoutIt_departmentsInput = {
    where: it_employeesWhereUniqueInput
    data: XOR<it_employeesUpdateWithoutIt_departmentsInput, it_employeesUncheckedUpdateWithoutIt_departmentsInput>
  }

  export type it_employeesUpdateManyWithWhereWithoutIt_departmentsInput = {
    where: it_employeesScalarWhereInput
    data: XOR<it_employeesUpdateManyMutationInput, it_employeesUncheckedUpdateManyWithoutIt_departmentsInput>
  }

  export type it_employeesScalarWhereInput = {
    AND?: it_employeesScalarWhereInput | it_employeesScalarWhereInput[]
    OR?: it_employeesScalarWhereInput[]
    NOT?: it_employeesScalarWhereInput | it_employeesScalarWhereInput[]
    id?: IntFilter<"it_employees"> | number
    first_name?: StringFilter<"it_employees"> | string
    last_name?: StringFilter<"it_employees"> | string
    employee_code?: StringFilter<"it_employees"> | string
    department_id?: IntFilter<"it_employees"> | number
    is_dept_head?: BoolFilter<"it_employees"> | boolean
    is_active?: BoolFilter<"it_employees"> | boolean
  }

  export type it_employeesCreateWithoutIt_employee_rolesInput = {
    first_name: string
    last_name: string
    employee_code: string
    is_dept_head?: boolean
    is_active?: boolean
    it_departments: it_departmentsCreateNestedOneWithoutIt_employeesInput
  }

  export type it_employeesUncheckedCreateWithoutIt_employee_rolesInput = {
    id?: number
    first_name: string
    last_name: string
    employee_code: string
    department_id: number
    is_dept_head?: boolean
    is_active?: boolean
  }

  export type it_employeesCreateOrConnectWithoutIt_employee_rolesInput = {
    where: it_employeesWhereUniqueInput
    create: XOR<it_employeesCreateWithoutIt_employee_rolesInput, it_employeesUncheckedCreateWithoutIt_employee_rolesInput>
  }

  export type it_rolesCreateWithoutIt_employee_rolesInput = {
    name: string
  }

  export type it_rolesUncheckedCreateWithoutIt_employee_rolesInput = {
    id?: number
    name: string
  }

  export type it_rolesCreateOrConnectWithoutIt_employee_rolesInput = {
    where: it_rolesWhereUniqueInput
    create: XOR<it_rolesCreateWithoutIt_employee_rolesInput, it_rolesUncheckedCreateWithoutIt_employee_rolesInput>
  }

  export type it_employeesUpsertWithoutIt_employee_rolesInput = {
    update: XOR<it_employeesUpdateWithoutIt_employee_rolesInput, it_employeesUncheckedUpdateWithoutIt_employee_rolesInput>
    create: XOR<it_employeesCreateWithoutIt_employee_rolesInput, it_employeesUncheckedCreateWithoutIt_employee_rolesInput>
    where?: it_employeesWhereInput
  }

  export type it_employeesUpdateToOneWithWhereWithoutIt_employee_rolesInput = {
    where?: it_employeesWhereInput
    data: XOR<it_employeesUpdateWithoutIt_employee_rolesInput, it_employeesUncheckedUpdateWithoutIt_employee_rolesInput>
  }

  export type it_employeesUpdateWithoutIt_employee_rolesInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    it_departments?: it_departmentsUpdateOneRequiredWithoutIt_employeesNestedInput
  }

  export type it_employeesUncheckedUpdateWithoutIt_employee_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type it_rolesUpsertWithoutIt_employee_rolesInput = {
    update: XOR<it_rolesUpdateWithoutIt_employee_rolesInput, it_rolesUncheckedUpdateWithoutIt_employee_rolesInput>
    create: XOR<it_rolesCreateWithoutIt_employee_rolesInput, it_rolesUncheckedCreateWithoutIt_employee_rolesInput>
    where?: it_rolesWhereInput
  }

  export type it_rolesUpdateToOneWithWhereWithoutIt_employee_rolesInput = {
    where?: it_rolesWhereInput
    data: XOR<it_rolesUpdateWithoutIt_employee_rolesInput, it_rolesUncheckedUpdateWithoutIt_employee_rolesInput>
  }

  export type it_rolesUpdateWithoutIt_employee_rolesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type it_rolesUncheckedUpdateWithoutIt_employee_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type it_employee_rolesCreateWithoutIt_employeesInput = {
    it_roles: it_rolesCreateNestedOneWithoutIt_employee_rolesInput
  }

  export type it_employee_rolesUncheckedCreateWithoutIt_employeesInput = {
    role_id: number
  }

  export type it_employee_rolesCreateOrConnectWithoutIt_employeesInput = {
    where: it_employee_rolesWhereUniqueInput
    create: XOR<it_employee_rolesCreateWithoutIt_employeesInput, it_employee_rolesUncheckedCreateWithoutIt_employeesInput>
  }

  export type it_employee_rolesCreateManyIt_employeesInputEnvelope = {
    data: it_employee_rolesCreateManyIt_employeesInput | it_employee_rolesCreateManyIt_employeesInput[]
  }

  export type it_departmentsCreateWithoutIt_employeesInput = {
    name: string
  }

  export type it_departmentsUncheckedCreateWithoutIt_employeesInput = {
    id?: number
    name: string
  }

  export type it_departmentsCreateOrConnectWithoutIt_employeesInput = {
    where: it_departmentsWhereUniqueInput
    create: XOR<it_departmentsCreateWithoutIt_employeesInput, it_departmentsUncheckedCreateWithoutIt_employeesInput>
  }

  export type it_employee_rolesUpsertWithWhereUniqueWithoutIt_employeesInput = {
    where: it_employee_rolesWhereUniqueInput
    update: XOR<it_employee_rolesUpdateWithoutIt_employeesInput, it_employee_rolesUncheckedUpdateWithoutIt_employeesInput>
    create: XOR<it_employee_rolesCreateWithoutIt_employeesInput, it_employee_rolesUncheckedCreateWithoutIt_employeesInput>
  }

  export type it_employee_rolesUpdateWithWhereUniqueWithoutIt_employeesInput = {
    where: it_employee_rolesWhereUniqueInput
    data: XOR<it_employee_rolesUpdateWithoutIt_employeesInput, it_employee_rolesUncheckedUpdateWithoutIt_employeesInput>
  }

  export type it_employee_rolesUpdateManyWithWhereWithoutIt_employeesInput = {
    where: it_employee_rolesScalarWhereInput
    data: XOR<it_employee_rolesUpdateManyMutationInput, it_employee_rolesUncheckedUpdateManyWithoutIt_employeesInput>
  }

  export type it_employee_rolesScalarWhereInput = {
    AND?: it_employee_rolesScalarWhereInput | it_employee_rolesScalarWhereInput[]
    OR?: it_employee_rolesScalarWhereInput[]
    NOT?: it_employee_rolesScalarWhereInput | it_employee_rolesScalarWhereInput[]
    employee_id?: IntFilter<"it_employee_roles"> | number
    role_id?: IntFilter<"it_employee_roles"> | number
  }

  export type it_departmentsUpsertWithoutIt_employeesInput = {
    update: XOR<it_departmentsUpdateWithoutIt_employeesInput, it_departmentsUncheckedUpdateWithoutIt_employeesInput>
    create: XOR<it_departmentsCreateWithoutIt_employeesInput, it_departmentsUncheckedCreateWithoutIt_employeesInput>
    where?: it_departmentsWhereInput
  }

  export type it_departmentsUpdateToOneWithWhereWithoutIt_employeesInput = {
    where?: it_departmentsWhereInput
    data: XOR<it_departmentsUpdateWithoutIt_employeesInput, it_departmentsUncheckedUpdateWithoutIt_employeesInput>
  }

  export type it_departmentsUpdateWithoutIt_employeesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type it_departmentsUncheckedUpdateWithoutIt_employeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type it_employee_rolesCreateWithoutIt_rolesInput = {
    it_employees: it_employeesCreateNestedOneWithoutIt_employee_rolesInput
  }

  export type it_employee_rolesUncheckedCreateWithoutIt_rolesInput = {
    employee_id: number
  }

  export type it_employee_rolesCreateOrConnectWithoutIt_rolesInput = {
    where: it_employee_rolesWhereUniqueInput
    create: XOR<it_employee_rolesCreateWithoutIt_rolesInput, it_employee_rolesUncheckedCreateWithoutIt_rolesInput>
  }

  export type it_employee_rolesCreateManyIt_rolesInputEnvelope = {
    data: it_employee_rolesCreateManyIt_rolesInput | it_employee_rolesCreateManyIt_rolesInput[]
  }

  export type it_employee_rolesUpsertWithWhereUniqueWithoutIt_rolesInput = {
    where: it_employee_rolesWhereUniqueInput
    update: XOR<it_employee_rolesUpdateWithoutIt_rolesInput, it_employee_rolesUncheckedUpdateWithoutIt_rolesInput>
    create: XOR<it_employee_rolesCreateWithoutIt_rolesInput, it_employee_rolesUncheckedCreateWithoutIt_rolesInput>
  }

  export type it_employee_rolesUpdateWithWhereUniqueWithoutIt_rolesInput = {
    where: it_employee_rolesWhereUniqueInput
    data: XOR<it_employee_rolesUpdateWithoutIt_rolesInput, it_employee_rolesUncheckedUpdateWithoutIt_rolesInput>
  }

  export type it_employee_rolesUpdateManyWithWhereWithoutIt_rolesInput = {
    where: it_employee_rolesScalarWhereInput
    data: XOR<it_employee_rolesUpdateManyMutationInput, it_employee_rolesUncheckedUpdateManyWithoutIt_rolesInput>
  }

  export type UserCreateWithoutKnowledgeBaseInput = {
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Document?: DocumentCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutKnowledgeBaseInput = {
    id?: number
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetUncheckedCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutKnowledgeBaseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKnowledgeBaseInput, UserUncheckedCreateWithoutKnowledgeBaseInput>
  }

  export type TicketCreateWithoutKnowledgeBaseInput = {
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    Asset?: AssetCreateNestedOneWithoutTicketInput
    User_Ticket_assignedToIdToUser?: UserCreateNestedOneWithoutTicket_Ticket_assignedToIdToUserInput
    User_Ticket_requestedByIdToUser: UserCreateNestedOneWithoutTicket_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutTicketInput
    TicketComment?: TicketCommentCreateNestedManyWithoutTicketInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutKnowledgeBaseInput = {
    id?: number
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    assetId?: number | null
    requestedById: number
    assignedToId?: number | null
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutKnowledgeBaseInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutKnowledgeBaseInput, TicketUncheckedCreateWithoutKnowledgeBaseInput>
  }

  export type UserUpsertWithoutKnowledgeBaseInput = {
    update: XOR<UserUpdateWithoutKnowledgeBaseInput, UserUncheckedUpdateWithoutKnowledgeBaseInput>
    create: XOR<UserCreateWithoutKnowledgeBaseInput, UserUncheckedCreateWithoutKnowledgeBaseInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKnowledgeBaseInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKnowledgeBaseInput, UserUncheckedUpdateWithoutKnowledgeBaseInput>
  }

  export type UserUpdateWithoutKnowledgeBaseInput = {
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Document?: DocumentUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKnowledgeBaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUncheckedUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TicketUpsertWithoutKnowledgeBaseInput = {
    update: XOR<TicketUpdateWithoutKnowledgeBaseInput, TicketUncheckedUpdateWithoutKnowledgeBaseInput>
    create: XOR<TicketCreateWithoutKnowledgeBaseInput, TicketUncheckedCreateWithoutKnowledgeBaseInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutKnowledgeBaseInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutKnowledgeBaseInput, TicketUncheckedUpdateWithoutKnowledgeBaseInput>
  }

  export type TicketUpdateWithoutKnowledgeBaseInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Asset?: AssetUpdateOneWithoutTicketNestedInput
    User_Ticket_assignedToIdToUser?: UserUpdateOneWithoutTicket_Ticket_assignedToIdToUserNestedInput
    User_Ticket_requestedByIdToUser?: UserUpdateOneRequiredWithoutTicket_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutTicketNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutKnowledgeBaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type AssetCreateWithoutLicenseInput = {
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    User?: UserCreateNestedOneWithoutAssetInput
    AssetHistory?: AssetHistoryCreateNestedManyWithoutAssetInput
    Monitor?: MonitorCreateNestedOneWithoutAssetInput
    Ticket?: TicketCreateNestedManyWithoutAssetInput
    Contract?: ContractCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutLicenseInput = {
    id?: number
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    ownerId?: number | null
    AssetHistory?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
    Monitor?: MonitorUncheckedCreateNestedOneWithoutAssetInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutAssetInput
    Contract?: ContractUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutLicenseInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutLicenseInput, AssetUncheckedCreateWithoutLicenseInput>
  }

  export type AssetUpsertWithoutLicenseInput = {
    update: XOR<AssetUpdateWithoutLicenseInput, AssetUncheckedUpdateWithoutLicenseInput>
    create: XOR<AssetCreateWithoutLicenseInput, AssetUncheckedCreateWithoutLicenseInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutLicenseInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutLicenseInput, AssetUncheckedUpdateWithoutLicenseInput>
  }

  export type AssetUpdateWithoutLicenseInput = {
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutAssetNestedInput
    AssetHistory?: AssetHistoryUpdateManyWithoutAssetNestedInput
    Monitor?: MonitorUpdateOneWithoutAssetNestedInput
    Ticket?: TicketUpdateManyWithoutAssetNestedInput
    Contract?: ContractUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutLicenseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    AssetHistory?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
    Monitor?: MonitorUncheckedUpdateOneWithoutAssetNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutAssetNestedInput
    Contract?: ContractUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetCreateWithoutMonitorInput = {
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    User?: UserCreateNestedOneWithoutAssetInput
    AssetHistory?: AssetHistoryCreateNestedManyWithoutAssetInput
    License?: LicenseCreateNestedManyWithoutAssetInput
    Ticket?: TicketCreateNestedManyWithoutAssetInput
    Contract?: ContractCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutMonitorInput = {
    id?: number
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    ownerId?: number | null
    AssetHistory?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
    License?: LicenseUncheckedCreateNestedManyWithoutAssetInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutAssetInput
    Contract?: ContractUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutMonitorInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutMonitorInput, AssetUncheckedCreateWithoutMonitorInput>
  }

  export type AssetUpsertWithoutMonitorInput = {
    update: XOR<AssetUpdateWithoutMonitorInput, AssetUncheckedUpdateWithoutMonitorInput>
    create: XOR<AssetCreateWithoutMonitorInput, AssetUncheckedCreateWithoutMonitorInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutMonitorInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutMonitorInput, AssetUncheckedUpdateWithoutMonitorInput>
  }

  export type AssetUpdateWithoutMonitorInput = {
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutAssetNestedInput
    AssetHistory?: AssetHistoryUpdateManyWithoutAssetNestedInput
    License?: LicenseUpdateManyWithoutAssetNestedInput
    Ticket?: TicketUpdateManyWithoutAssetNestedInput
    Contract?: ContractUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutMonitorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    AssetHistory?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
    License?: LicenseUncheckedUpdateManyWithoutAssetNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutAssetNestedInput
    Contract?: ContractUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type employee_rolesCreateWithoutRolesInput = {
    employees: employeesCreateNestedOneWithoutEmployee_rolesInput
  }

  export type employee_rolesUncheckedCreateWithoutRolesInput = {
    employee_id: number
  }

  export type employee_rolesCreateOrConnectWithoutRolesInput = {
    where: employee_rolesWhereUniqueInput
    create: XOR<employee_rolesCreateWithoutRolesInput, employee_rolesUncheckedCreateWithoutRolesInput>
  }

  export type employee_rolesCreateManyRolesInputEnvelope = {
    data: employee_rolesCreateManyRolesInput | employee_rolesCreateManyRolesInput[]
  }

  export type employee_rolesUpsertWithWhereUniqueWithoutRolesInput = {
    where: employee_rolesWhereUniqueInput
    update: XOR<employee_rolesUpdateWithoutRolesInput, employee_rolesUncheckedUpdateWithoutRolesInput>
    create: XOR<employee_rolesCreateWithoutRolesInput, employee_rolesUncheckedCreateWithoutRolesInput>
  }

  export type employee_rolesUpdateWithWhereUniqueWithoutRolesInput = {
    where: employee_rolesWhereUniqueInput
    data: XOR<employee_rolesUpdateWithoutRolesInput, employee_rolesUncheckedUpdateWithoutRolesInput>
  }

  export type employee_rolesUpdateManyWithWhereWithoutRolesInput = {
    where: employee_rolesScalarWhereInput
    data: XOR<employee_rolesUpdateManyMutationInput, employee_rolesUncheckedUpdateManyWithoutRolesInput>
  }

  export type KnowledgeBaseCreateWithoutTicketInput = {
    title: string
    content: string
    category?: string | null
    tags?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    User: UserCreateNestedOneWithoutKnowledgeBaseInput
  }

  export type KnowledgeBaseUncheckedCreateWithoutTicketInput = {
    id?: number
    title: string
    content: string
    category?: string | null
    tags?: string | null
    isPublic?: boolean
    createdById: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type KnowledgeBaseCreateOrConnectWithoutTicketInput = {
    where: KnowledgeBaseWhereUniqueInput
    create: XOR<KnowledgeBaseCreateWithoutTicketInput, KnowledgeBaseUncheckedCreateWithoutTicketInput>
  }

  export type KnowledgeBaseCreateManyTicketInputEnvelope = {
    data: KnowledgeBaseCreateManyTicketInput | KnowledgeBaseCreateManyTicketInput[]
  }

  export type AssetCreateWithoutTicketInput = {
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    User?: UserCreateNestedOneWithoutAssetInput
    AssetHistory?: AssetHistoryCreateNestedManyWithoutAssetInput
    License?: LicenseCreateNestedManyWithoutAssetInput
    Monitor?: MonitorCreateNestedOneWithoutAssetInput
    Contract?: ContractCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutTicketInput = {
    id?: number
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    ownerId?: number | null
    AssetHistory?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
    License?: LicenseUncheckedCreateNestedManyWithoutAssetInput
    Monitor?: MonitorUncheckedCreateNestedOneWithoutAssetInput
    Contract?: ContractUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutTicketInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutTicketInput, AssetUncheckedCreateWithoutTicketInput>
  }

  export type UserCreateWithoutTicket_Ticket_assignedToIdToUserInput = {
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Document?: DocumentCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicket_Ticket_assignedToIdToUserInput = {
    id?: number
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetUncheckedCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicket_Ticket_assignedToIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicket_Ticket_assignedToIdToUserInput, UserUncheckedCreateWithoutTicket_Ticket_assignedToIdToUserInput>
  }

  export type UserCreateWithoutTicket_Ticket_requestedByIdToUserInput = {
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Document?: DocumentCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicket_Ticket_requestedByIdToUserInput = {
    id?: number
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetUncheckedCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicket_Ticket_requestedByIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicket_Ticket_requestedByIdToUserInput, UserUncheckedCreateWithoutTicket_Ticket_requestedByIdToUserInput>
  }

  export type TicketAttachmentCreateWithoutTicketInput = {
    fileName: string
    filePath: string
    uploadedAt?: Date | string
    User: UserCreateNestedOneWithoutTicketAttachmentInput
  }

  export type TicketAttachmentUncheckedCreateWithoutTicketInput = {
    id?: number
    fileName: string
    filePath: string
    uploadedAt?: Date | string
    uploadedById: number
  }

  export type TicketAttachmentCreateOrConnectWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    create: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput>
  }

  export type TicketAttachmentCreateManyTicketInputEnvelope = {
    data: TicketAttachmentCreateManyTicketInput | TicketAttachmentCreateManyTicketInput[]
  }

  export type TicketCommentCreateWithoutTicketInput = {
    content: string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutTicketCommentInput
  }

  export type TicketCommentUncheckedCreateWithoutTicketInput = {
    id?: number
    content: string
    createdAt?: Date | string
    createdById: number
  }

  export type TicketCommentCreateOrConnectWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentCreateManyTicketInputEnvelope = {
    data: TicketCommentCreateManyTicketInput | TicketCommentCreateManyTicketInput[]
  }

  export type TicketHistoryCreateWithoutTicketInput = {
    oldStatus: string
    newStatus: string
    changedAt?: Date | string
    note?: string | null
    User: UserCreateNestedOneWithoutTicketHistoryInput
  }

  export type TicketHistoryUncheckedCreateWithoutTicketInput = {
    id?: number
    oldStatus: string
    newStatus: string
    changedById: number
    changedAt?: Date | string
    note?: string | null
  }

  export type TicketHistoryCreateOrConnectWithoutTicketInput = {
    where: TicketHistoryWhereUniqueInput
    create: XOR<TicketHistoryCreateWithoutTicketInput, TicketHistoryUncheckedCreateWithoutTicketInput>
  }

  export type TicketHistoryCreateManyTicketInputEnvelope = {
    data: TicketHistoryCreateManyTicketInput | TicketHistoryCreateManyTicketInput[]
  }

  export type KnowledgeBaseUpsertWithWhereUniqueWithoutTicketInput = {
    where: KnowledgeBaseWhereUniqueInput
    update: XOR<KnowledgeBaseUpdateWithoutTicketInput, KnowledgeBaseUncheckedUpdateWithoutTicketInput>
    create: XOR<KnowledgeBaseCreateWithoutTicketInput, KnowledgeBaseUncheckedCreateWithoutTicketInput>
  }

  export type KnowledgeBaseUpdateWithWhereUniqueWithoutTicketInput = {
    where: KnowledgeBaseWhereUniqueInput
    data: XOR<KnowledgeBaseUpdateWithoutTicketInput, KnowledgeBaseUncheckedUpdateWithoutTicketInput>
  }

  export type KnowledgeBaseUpdateManyWithWhereWithoutTicketInput = {
    where: KnowledgeBaseScalarWhereInput
    data: XOR<KnowledgeBaseUpdateManyMutationInput, KnowledgeBaseUncheckedUpdateManyWithoutTicketInput>
  }

  export type KnowledgeBaseScalarWhereInput = {
    AND?: KnowledgeBaseScalarWhereInput | KnowledgeBaseScalarWhereInput[]
    OR?: KnowledgeBaseScalarWhereInput[]
    NOT?: KnowledgeBaseScalarWhereInput | KnowledgeBaseScalarWhereInput[]
    id?: IntFilter<"KnowledgeBase"> | number
    title?: StringFilter<"KnowledgeBase"> | string
    content?: StringFilter<"KnowledgeBase"> | string
    category?: StringNullableFilter<"KnowledgeBase"> | string | null
    tags?: StringNullableFilter<"KnowledgeBase"> | string | null
    isPublic?: BoolFilter<"KnowledgeBase"> | boolean
    createdById?: IntFilter<"KnowledgeBase"> | number
    linkedTicketId?: IntNullableFilter<"KnowledgeBase"> | number | null
    createdAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
  }

  export type AssetUpsertWithoutTicketInput = {
    update: XOR<AssetUpdateWithoutTicketInput, AssetUncheckedUpdateWithoutTicketInput>
    create: XOR<AssetCreateWithoutTicketInput, AssetUncheckedCreateWithoutTicketInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutTicketInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutTicketInput, AssetUncheckedUpdateWithoutTicketInput>
  }

  export type AssetUpdateWithoutTicketInput = {
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutAssetNestedInput
    AssetHistory?: AssetHistoryUpdateManyWithoutAssetNestedInput
    License?: LicenseUpdateManyWithoutAssetNestedInput
    Monitor?: MonitorUpdateOneWithoutAssetNestedInput
    Contract?: ContractUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    AssetHistory?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
    License?: LicenseUncheckedUpdateManyWithoutAssetNestedInput
    Monitor?: MonitorUncheckedUpdateOneWithoutAssetNestedInput
    Contract?: ContractUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type UserUpsertWithoutTicket_Ticket_assignedToIdToUserInput = {
    update: XOR<UserUpdateWithoutTicket_Ticket_assignedToIdToUserInput, UserUncheckedUpdateWithoutTicket_Ticket_assignedToIdToUserInput>
    create: XOR<UserCreateWithoutTicket_Ticket_assignedToIdToUserInput, UserUncheckedCreateWithoutTicket_Ticket_assignedToIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicket_Ticket_assignedToIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicket_Ticket_assignedToIdToUserInput, UserUncheckedUpdateWithoutTicket_Ticket_assignedToIdToUserInput>
  }

  export type UserUpdateWithoutTicket_Ticket_assignedToIdToUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Document?: DocumentUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicket_Ticket_assignedToIdToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUncheckedUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutTicket_Ticket_requestedByIdToUserInput = {
    update: XOR<UserUpdateWithoutTicket_Ticket_requestedByIdToUserInput, UserUncheckedUpdateWithoutTicket_Ticket_requestedByIdToUserInput>
    create: XOR<UserCreateWithoutTicket_Ticket_requestedByIdToUserInput, UserUncheckedCreateWithoutTicket_Ticket_requestedByIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicket_Ticket_requestedByIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicket_Ticket_requestedByIdToUserInput, UserUncheckedUpdateWithoutTicket_Ticket_requestedByIdToUserInput>
  }

  export type UserUpdateWithoutTicket_Ticket_requestedByIdToUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Document?: DocumentUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicket_Ticket_requestedByIdToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUncheckedUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    update: XOR<TicketAttachmentUpdateWithoutTicketInput, TicketAttachmentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput>
  }

  export type TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    data: XOR<TicketAttachmentUpdateWithoutTicketInput, TicketAttachmentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketAttachmentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketAttachmentScalarWhereInput
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketAttachmentScalarWhereInput = {
    AND?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
    OR?: TicketAttachmentScalarWhereInput[]
    NOT?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
    id?: IntFilter<"TicketAttachment"> | number
    fileName?: StringFilter<"TicketAttachment"> | string
    filePath?: StringFilter<"TicketAttachment"> | string
    uploadedAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticketId?: IntFilter<"TicketAttachment"> | number
    uploadedById?: IntFilter<"TicketAttachment"> | number
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketCommentScalarWhereInput = {
    AND?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    OR?: TicketCommentScalarWhereInput[]
    NOT?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    id?: IntFilter<"TicketComment"> | number
    content?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticketId?: IntFilter<"TicketComment"> | number
    createdById?: IntFilter<"TicketComment"> | number
  }

  export type TicketHistoryUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketHistoryWhereUniqueInput
    update: XOR<TicketHistoryUpdateWithoutTicketInput, TicketHistoryUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketHistoryCreateWithoutTicketInput, TicketHistoryUncheckedCreateWithoutTicketInput>
  }

  export type TicketHistoryUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketHistoryWhereUniqueInput
    data: XOR<TicketHistoryUpdateWithoutTicketInput, TicketHistoryUncheckedUpdateWithoutTicketInput>
  }

  export type TicketHistoryUpdateManyWithWhereWithoutTicketInput = {
    where: TicketHistoryScalarWhereInput
    data: XOR<TicketHistoryUpdateManyMutationInput, TicketHistoryUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketHistoryScalarWhereInput = {
    AND?: TicketHistoryScalarWhereInput | TicketHistoryScalarWhereInput[]
    OR?: TicketHistoryScalarWhereInput[]
    NOT?: TicketHistoryScalarWhereInput | TicketHistoryScalarWhereInput[]
    id?: IntFilter<"TicketHistory"> | number
    ticketId?: IntFilter<"TicketHistory"> | number
    oldStatus?: StringFilter<"TicketHistory"> | string
    newStatus?: StringFilter<"TicketHistory"> | string
    changedById?: IntFilter<"TicketHistory"> | number
    changedAt?: DateTimeFilter<"TicketHistory"> | Date | string
    note?: StringNullableFilter<"TicketHistory"> | string | null
  }

  export type TicketCreateWithoutTicketAttachmentInput = {
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutTicketInput
    Asset?: AssetCreateNestedOneWithoutTicketInput
    User_Ticket_assignedToIdToUser?: UserCreateNestedOneWithoutTicket_Ticket_assignedToIdToUserInput
    User_Ticket_requestedByIdToUser: UserCreateNestedOneWithoutTicket_Ticket_requestedByIdToUserInput
    TicketComment?: TicketCommentCreateNestedManyWithoutTicketInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutTicketAttachmentInput = {
    id?: number
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    assetId?: number | null
    requestedById: number
    assignedToId?: number | null
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutTicketInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutTicketAttachmentInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTicketAttachmentInput, TicketUncheckedCreateWithoutTicketAttachmentInput>
  }

  export type UserCreateWithoutTicketAttachmentInput = {
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Document?: DocumentCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketComment?: TicketCommentCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketAttachmentInput = {
    id?: number
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetUncheckedCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketAttachmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketAttachmentInput, UserUncheckedCreateWithoutTicketAttachmentInput>
  }

  export type TicketUpsertWithoutTicketAttachmentInput = {
    update: XOR<TicketUpdateWithoutTicketAttachmentInput, TicketUncheckedUpdateWithoutTicketAttachmentInput>
    create: XOR<TicketCreateWithoutTicketAttachmentInput, TicketUncheckedCreateWithoutTicketAttachmentInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutTicketAttachmentInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutTicketAttachmentInput, TicketUncheckedUpdateWithoutTicketAttachmentInput>
  }

  export type TicketUpdateWithoutTicketAttachmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutTicketNestedInput
    Asset?: AssetUpdateOneWithoutTicketNestedInput
    User_Ticket_assignedToIdToUser?: UserUpdateOneWithoutTicket_Ticket_assignedToIdToUserNestedInput
    User_Ticket_requestedByIdToUser?: UserUpdateOneRequiredWithoutTicket_Ticket_requestedByIdToUserNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutTicketNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutTicketAttachmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutTicketNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type UserUpsertWithoutTicketAttachmentInput = {
    update: XOR<UserUpdateWithoutTicketAttachmentInput, UserUncheckedUpdateWithoutTicketAttachmentInput>
    create: XOR<UserCreateWithoutTicketAttachmentInput, UserUncheckedCreateWithoutTicketAttachmentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketAttachmentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketAttachmentInput, UserUncheckedUpdateWithoutTicketAttachmentInput>
  }

  export type UserUpdateWithoutTicketAttachmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Document?: DocumentUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketAttachmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUncheckedUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTicketCommentInput = {
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Document?: DocumentCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketCommentInput = {
    id?: number
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetUncheckedCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUserInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketCommentInput, UserUncheckedCreateWithoutTicketCommentInput>
  }

  export type TicketCreateWithoutTicketCommentInput = {
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutTicketInput
    Asset?: AssetCreateNestedOneWithoutTicketInput
    User_Ticket_assignedToIdToUser?: UserCreateNestedOneWithoutTicket_Ticket_assignedToIdToUserInput
    User_Ticket_requestedByIdToUser: UserCreateNestedOneWithoutTicket_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutTicketInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutTicketCommentInput = {
    id?: number
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    assetId?: number | null
    requestedById: number
    assignedToId?: number | null
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutTicketInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutTicketCommentInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTicketCommentInput, TicketUncheckedCreateWithoutTicketCommentInput>
  }

  export type UserUpsertWithoutTicketCommentInput = {
    update: XOR<UserUpdateWithoutTicketCommentInput, UserUncheckedUpdateWithoutTicketCommentInput>
    create: XOR<UserCreateWithoutTicketCommentInput, UserUncheckedCreateWithoutTicketCommentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketCommentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketCommentInput, UserUncheckedUpdateWithoutTicketCommentInput>
  }

  export type UserUpdateWithoutTicketCommentInput = {
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Document?: DocumentUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUncheckedUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUserNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TicketUpsertWithoutTicketCommentInput = {
    update: XOR<TicketUpdateWithoutTicketCommentInput, TicketUncheckedUpdateWithoutTicketCommentInput>
    create: XOR<TicketCreateWithoutTicketCommentInput, TicketUncheckedCreateWithoutTicketCommentInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutTicketCommentInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutTicketCommentInput, TicketUncheckedUpdateWithoutTicketCommentInput>
  }

  export type TicketUpdateWithoutTicketCommentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutTicketNestedInput
    Asset?: AssetUpdateOneWithoutTicketNestedInput
    User_Ticket_assignedToIdToUser?: UserUpdateOneWithoutTicket_Ticket_assignedToIdToUserNestedInput
    User_Ticket_requestedByIdToUser?: UserUpdateOneRequiredWithoutTicket_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutTicketCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutTicketNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type UserCreateWithoutTicketHistoryInput = {
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Document?: DocumentCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketHistoryInput = {
    id?: number
    name: string
    empId: string
    email: string
    password: string
    role?: string
    department?: string | null
    Asset?: AssetUncheckedCreateNestedManyWithoutUserInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_newOwnerIdToUserInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedCreateNestedManyWithoutUser_AssetHistory_oldOwnerIdToUserInput
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Document?: DocumentUncheckedCreateNestedManyWithoutUserInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutUserInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_assignedToIdToUserInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedCreateNestedManyWithoutUser_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutUserInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketHistoryInput, UserUncheckedCreateWithoutTicketHistoryInput>
  }

  export type TicketCreateWithoutTicketHistoryInput = {
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutTicketInput
    Asset?: AssetCreateNestedOneWithoutTicketInput
    User_Ticket_assignedToIdToUser?: UserCreateNestedOneWithoutTicket_Ticket_assignedToIdToUserInput
    User_Ticket_requestedByIdToUser: UserCreateNestedOneWithoutTicket_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutTicketInput
    TicketComment?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutTicketHistoryInput = {
    id?: number
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    assetId?: number | null
    requestedById: number
    assignedToId?: number | null
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutTicketInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutTicketHistoryInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTicketHistoryInput, TicketUncheckedCreateWithoutTicketHistoryInput>
  }

  export type UserUpsertWithoutTicketHistoryInput = {
    update: XOR<UserUpdateWithoutTicketHistoryInput, UserUncheckedUpdateWithoutTicketHistoryInput>
    create: XOR<UserCreateWithoutTicketHistoryInput, UserUncheckedCreateWithoutTicketHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketHistoryInput, UserUncheckedUpdateWithoutTicketHistoryInput>
  }

  export type UserUpdateWithoutTicketHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Document?: DocumentUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    empId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUncheckedUpdateManyWithoutUserNestedInput
    AssetHistory_AssetHistory_newOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserNestedInput
    AssetHistory_AssetHistory_oldOwnerIdToUser?: AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserNestedInput
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Document?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutUserNestedInput
    Ticket_Ticket_assignedToIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserNestedInput
    Ticket_Ticket_requestedByIdToUser?: TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutUserNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TicketUpsertWithoutTicketHistoryInput = {
    update: XOR<TicketUpdateWithoutTicketHistoryInput, TicketUncheckedUpdateWithoutTicketHistoryInput>
    create: XOR<TicketCreateWithoutTicketHistoryInput, TicketUncheckedCreateWithoutTicketHistoryInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutTicketHistoryInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutTicketHistoryInput, TicketUncheckedUpdateWithoutTicketHistoryInput>
  }

  export type TicketUpdateWithoutTicketHistoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutTicketNestedInput
    Asset?: AssetUpdateOneWithoutTicketNestedInput
    User_Ticket_assignedToIdToUser?: UserUpdateOneWithoutTicket_Ticket_assignedToIdToUserNestedInput
    User_Ticket_requestedByIdToUser?: UserUpdateOneRequiredWithoutTicket_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutTicketHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutTicketNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type AssetCreateWithoutUserInput = {
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    AssetHistory?: AssetHistoryCreateNestedManyWithoutAssetInput
    License?: LicenseCreateNestedManyWithoutAssetInput
    Monitor?: MonitorCreateNestedOneWithoutAssetInput
    Ticket?: TicketCreateNestedManyWithoutAssetInput
    Contract?: ContractCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
    AssetHistory?: AssetHistoryUncheckedCreateNestedManyWithoutAssetInput
    License?: LicenseUncheckedCreateNestedManyWithoutAssetInput
    Monitor?: MonitorUncheckedCreateNestedOneWithoutAssetInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutAssetInput
    Contract?: ContractUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutUserInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutUserInput, AssetUncheckedCreateWithoutUserInput>
  }

  export type AssetCreateManyUserInputEnvelope = {
    data: AssetCreateManyUserInput | AssetCreateManyUserInput[]
  }

  export type AssetHistoryCreateWithoutUser_AssetHistory_newOwnerIdToUserInput = {
    changedAt?: Date | string
    reason?: string | null
    Asset: AssetCreateNestedOneWithoutAssetHistoryInput
    User_AssetHistory_oldOwnerIdToUser?: UserCreateNestedOneWithoutAssetHistory_AssetHistory_oldOwnerIdToUserInput
  }

  export type AssetHistoryUncheckedCreateWithoutUser_AssetHistory_newOwnerIdToUserInput = {
    id?: number
    assetId: number
    oldOwnerId?: number | null
    changedAt?: Date | string
    reason?: string | null
  }

  export type AssetHistoryCreateOrConnectWithoutUser_AssetHistory_newOwnerIdToUserInput = {
    where: AssetHistoryWhereUniqueInput
    create: XOR<AssetHistoryCreateWithoutUser_AssetHistory_newOwnerIdToUserInput, AssetHistoryUncheckedCreateWithoutUser_AssetHistory_newOwnerIdToUserInput>
  }

  export type AssetHistoryCreateManyUser_AssetHistory_newOwnerIdToUserInputEnvelope = {
    data: AssetHistoryCreateManyUser_AssetHistory_newOwnerIdToUserInput | AssetHistoryCreateManyUser_AssetHistory_newOwnerIdToUserInput[]
  }

  export type AssetHistoryCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput = {
    changedAt?: Date | string
    reason?: string | null
    Asset: AssetCreateNestedOneWithoutAssetHistoryInput
    User_AssetHistory_newOwnerIdToUser?: UserCreateNestedOneWithoutAssetHistory_AssetHistory_newOwnerIdToUserInput
  }

  export type AssetHistoryUncheckedCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput = {
    id?: number
    assetId: number
    newOwnerId?: number | null
    changedAt?: Date | string
    reason?: string | null
  }

  export type AssetHistoryCreateOrConnectWithoutUser_AssetHistory_oldOwnerIdToUserInput = {
    where: AssetHistoryWhereUniqueInput
    create: XOR<AssetHistoryCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput, AssetHistoryUncheckedCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput>
  }

  export type AssetHistoryCreateManyUser_AssetHistory_oldOwnerIdToUserInputEnvelope = {
    data: AssetHistoryCreateManyUser_AssetHistory_oldOwnerIdToUserInput | AssetHistoryCreateManyUser_AssetHistory_oldOwnerIdToUserInput[]
  }

  export type AuditLogCreateWithoutUserInput = {
    action: string
    tableName: string
    recordId?: number | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: number
    action: string
    tableName: string
    recordId?: number | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
  }

  export type DocumentCreateWithoutUserInput = {
    name: string
    filePath: string
    version: string
    permission: string
    createdAt?: Date | string
  }

  export type DocumentUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    filePath: string
    version: string
    permission: string
    createdAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutUserInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentCreateManyUserInputEnvelope = {
    data: DocumentCreateManyUserInput | DocumentCreateManyUserInput[]
  }

  export type InventoryTransactionCreateWithoutUserInput = {
    type: string
    qty: number
    date?: Date | string
    note?: string | null
    barcode?: string | null
    InventoryItem: InventoryItemCreateNestedOneWithoutInventoryTransactionInput
  }

  export type InventoryTransactionUncheckedCreateWithoutUserInput = {
    id?: number
    itemId: number
    type: string
    qty: number
    date?: Date | string
    note?: string | null
    barcode?: string | null
  }

  export type InventoryTransactionCreateOrConnectWithoutUserInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput>
  }

  export type InventoryTransactionCreateManyUserInputEnvelope = {
    data: InventoryTransactionCreateManyUserInput | InventoryTransactionCreateManyUserInput[]
  }

  export type KnowledgeBaseCreateWithoutUserInput = {
    title: string
    content: string
    category?: string | null
    tags?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    Ticket?: TicketCreateNestedOneWithoutKnowledgeBaseInput
  }

  export type KnowledgeBaseUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    content: string
    category?: string | null
    tags?: string | null
    isPublic?: boolean
    linkedTicketId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type KnowledgeBaseCreateOrConnectWithoutUserInput = {
    where: KnowledgeBaseWhereUniqueInput
    create: XOR<KnowledgeBaseCreateWithoutUserInput, KnowledgeBaseUncheckedCreateWithoutUserInput>
  }

  export type KnowledgeBaseCreateManyUserInputEnvelope = {
    data: KnowledgeBaseCreateManyUserInput | KnowledgeBaseCreateManyUserInput[]
  }

  export type TicketCreateWithoutUser_Ticket_assignedToIdToUserInput = {
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutTicketInput
    Asset?: AssetCreateNestedOneWithoutTicketInput
    User_Ticket_requestedByIdToUser: UserCreateNestedOneWithoutTicket_Ticket_requestedByIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutTicketInput
    TicketComment?: TicketCommentCreateNestedManyWithoutTicketInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutUser_Ticket_assignedToIdToUserInput = {
    id?: number
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    assetId?: number | null
    requestedById: number
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutTicketInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutUser_Ticket_assignedToIdToUserInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutUser_Ticket_assignedToIdToUserInput, TicketUncheckedCreateWithoutUser_Ticket_assignedToIdToUserInput>
  }

  export type TicketCreateManyUser_Ticket_assignedToIdToUserInputEnvelope = {
    data: TicketCreateManyUser_Ticket_assignedToIdToUserInput | TicketCreateManyUser_Ticket_assignedToIdToUserInput[]
  }

  export type TicketCreateWithoutUser_Ticket_requestedByIdToUserInput = {
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    KnowledgeBase?: KnowledgeBaseCreateNestedManyWithoutTicketInput
    Asset?: AssetCreateNestedOneWithoutTicketInput
    User_Ticket_assignedToIdToUser?: UserCreateNestedOneWithoutTicket_Ticket_assignedToIdToUserInput
    TicketAttachment?: TicketAttachmentCreateNestedManyWithoutTicketInput
    TicketComment?: TicketCommentCreateNestedManyWithoutTicketInput
    TicketHistory?: TicketHistoryCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutUser_Ticket_requestedByIdToUserInput = {
    id?: number
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    assetId?: number | null
    assignedToId?: number | null
    KnowledgeBase?: KnowledgeBaseUncheckedCreateNestedManyWithoutTicketInput
    TicketAttachment?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    TicketComment?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
    TicketHistory?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutUser_Ticket_requestedByIdToUserInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutUser_Ticket_requestedByIdToUserInput, TicketUncheckedCreateWithoutUser_Ticket_requestedByIdToUserInput>
  }

  export type TicketCreateManyUser_Ticket_requestedByIdToUserInputEnvelope = {
    data: TicketCreateManyUser_Ticket_requestedByIdToUserInput | TicketCreateManyUser_Ticket_requestedByIdToUserInput[]
  }

  export type TicketAttachmentCreateWithoutUserInput = {
    fileName: string
    filePath: string
    uploadedAt?: Date | string
    Ticket: TicketCreateNestedOneWithoutTicketAttachmentInput
  }

  export type TicketAttachmentUncheckedCreateWithoutUserInput = {
    id?: number
    fileName: string
    filePath: string
    uploadedAt?: Date | string
    ticketId: number
  }

  export type TicketAttachmentCreateOrConnectWithoutUserInput = {
    where: TicketAttachmentWhereUniqueInput
    create: XOR<TicketAttachmentCreateWithoutUserInput, TicketAttachmentUncheckedCreateWithoutUserInput>
  }

  export type TicketAttachmentCreateManyUserInputEnvelope = {
    data: TicketAttachmentCreateManyUserInput | TicketAttachmentCreateManyUserInput[]
  }

  export type TicketCommentCreateWithoutUserInput = {
    content: string
    createdAt?: Date | string
    Ticket: TicketCreateNestedOneWithoutTicketCommentInput
  }

  export type TicketCommentUncheckedCreateWithoutUserInput = {
    id?: number
    content: string
    createdAt?: Date | string
    ticketId: number
  }

  export type TicketCommentCreateOrConnectWithoutUserInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput>
  }

  export type TicketCommentCreateManyUserInputEnvelope = {
    data: TicketCommentCreateManyUserInput | TicketCommentCreateManyUserInput[]
  }

  export type TicketHistoryCreateWithoutUserInput = {
    oldStatus: string
    newStatus: string
    changedAt?: Date | string
    note?: string | null
    Ticket: TicketCreateNestedOneWithoutTicketHistoryInput
  }

  export type TicketHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    ticketId: number
    oldStatus: string
    newStatus: string
    changedAt?: Date | string
    note?: string | null
  }

  export type TicketHistoryCreateOrConnectWithoutUserInput = {
    where: TicketHistoryWhereUniqueInput
    create: XOR<TicketHistoryCreateWithoutUserInput, TicketHistoryUncheckedCreateWithoutUserInput>
  }

  export type TicketHistoryCreateManyUserInputEnvelope = {
    data: TicketHistoryCreateManyUserInput | TicketHistoryCreateManyUserInput[]
  }

  export type AssetUpsertWithWhereUniqueWithoutUserInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutUserInput, AssetUncheckedUpdateWithoutUserInput>
    create: XOR<AssetCreateWithoutUserInput, AssetUncheckedCreateWithoutUserInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutUserInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutUserInput, AssetUncheckedUpdateWithoutUserInput>
  }

  export type AssetUpdateManyWithWhereWithoutUserInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutUserInput>
  }

  export type AssetHistoryUpsertWithWhereUniqueWithoutUser_AssetHistory_newOwnerIdToUserInput = {
    where: AssetHistoryWhereUniqueInput
    update: XOR<AssetHistoryUpdateWithoutUser_AssetHistory_newOwnerIdToUserInput, AssetHistoryUncheckedUpdateWithoutUser_AssetHistory_newOwnerIdToUserInput>
    create: XOR<AssetHistoryCreateWithoutUser_AssetHistory_newOwnerIdToUserInput, AssetHistoryUncheckedCreateWithoutUser_AssetHistory_newOwnerIdToUserInput>
  }

  export type AssetHistoryUpdateWithWhereUniqueWithoutUser_AssetHistory_newOwnerIdToUserInput = {
    where: AssetHistoryWhereUniqueInput
    data: XOR<AssetHistoryUpdateWithoutUser_AssetHistory_newOwnerIdToUserInput, AssetHistoryUncheckedUpdateWithoutUser_AssetHistory_newOwnerIdToUserInput>
  }

  export type AssetHistoryUpdateManyWithWhereWithoutUser_AssetHistory_newOwnerIdToUserInput = {
    where: AssetHistoryScalarWhereInput
    data: XOR<AssetHistoryUpdateManyMutationInput, AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserInput>
  }

  export type AssetHistoryUpsertWithWhereUniqueWithoutUser_AssetHistory_oldOwnerIdToUserInput = {
    where: AssetHistoryWhereUniqueInput
    update: XOR<AssetHistoryUpdateWithoutUser_AssetHistory_oldOwnerIdToUserInput, AssetHistoryUncheckedUpdateWithoutUser_AssetHistory_oldOwnerIdToUserInput>
    create: XOR<AssetHistoryCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput, AssetHistoryUncheckedCreateWithoutUser_AssetHistory_oldOwnerIdToUserInput>
  }

  export type AssetHistoryUpdateWithWhereUniqueWithoutUser_AssetHistory_oldOwnerIdToUserInput = {
    where: AssetHistoryWhereUniqueInput
    data: XOR<AssetHistoryUpdateWithoutUser_AssetHistory_oldOwnerIdToUserInput, AssetHistoryUncheckedUpdateWithoutUser_AssetHistory_oldOwnerIdToUserInput>
  }

  export type AssetHistoryUpdateManyWithWhereWithoutUser_AssetHistory_oldOwnerIdToUserInput = {
    where: AssetHistoryScalarWhereInput
    data: XOR<AssetHistoryUpdateManyMutationInput, AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: IntNullableFilter<"AuditLog"> | number | null
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    userId?: IntFilter<"AuditLog"> | number
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUserInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: IntFilter<"Document"> | number
    name?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    version?: StringFilter<"Document"> | string
    permission?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    createdById?: IntFilter<"Document"> | number
  }

  export type InventoryTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: InventoryTransactionWhereUniqueInput
    update: XOR<InventoryTransactionUpdateWithoutUserInput, InventoryTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput>
  }

  export type InventoryTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: InventoryTransactionWhereUniqueInput
    data: XOR<InventoryTransactionUpdateWithoutUserInput, InventoryTransactionUncheckedUpdateWithoutUserInput>
  }

  export type InventoryTransactionUpdateManyWithWhereWithoutUserInput = {
    where: InventoryTransactionScalarWhereInput
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type KnowledgeBaseUpsertWithWhereUniqueWithoutUserInput = {
    where: KnowledgeBaseWhereUniqueInput
    update: XOR<KnowledgeBaseUpdateWithoutUserInput, KnowledgeBaseUncheckedUpdateWithoutUserInput>
    create: XOR<KnowledgeBaseCreateWithoutUserInput, KnowledgeBaseUncheckedCreateWithoutUserInput>
  }

  export type KnowledgeBaseUpdateWithWhereUniqueWithoutUserInput = {
    where: KnowledgeBaseWhereUniqueInput
    data: XOR<KnowledgeBaseUpdateWithoutUserInput, KnowledgeBaseUncheckedUpdateWithoutUserInput>
  }

  export type KnowledgeBaseUpdateManyWithWhereWithoutUserInput = {
    where: KnowledgeBaseScalarWhereInput
    data: XOR<KnowledgeBaseUpdateManyMutationInput, KnowledgeBaseUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutUser_Ticket_assignedToIdToUserInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutUser_Ticket_assignedToIdToUserInput, TicketUncheckedUpdateWithoutUser_Ticket_assignedToIdToUserInput>
    create: XOR<TicketCreateWithoutUser_Ticket_assignedToIdToUserInput, TicketUncheckedCreateWithoutUser_Ticket_assignedToIdToUserInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutUser_Ticket_assignedToIdToUserInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutUser_Ticket_assignedToIdToUserInput, TicketUncheckedUpdateWithoutUser_Ticket_assignedToIdToUserInput>
  }

  export type TicketUpdateManyWithWhereWithoutUser_Ticket_assignedToIdToUserInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutUser_Ticket_requestedByIdToUserInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutUser_Ticket_requestedByIdToUserInput, TicketUncheckedUpdateWithoutUser_Ticket_requestedByIdToUserInput>
    create: XOR<TicketCreateWithoutUser_Ticket_requestedByIdToUserInput, TicketUncheckedCreateWithoutUser_Ticket_requestedByIdToUserInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutUser_Ticket_requestedByIdToUserInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutUser_Ticket_requestedByIdToUserInput, TicketUncheckedUpdateWithoutUser_Ticket_requestedByIdToUserInput>
  }

  export type TicketUpdateManyWithWhereWithoutUser_Ticket_requestedByIdToUserInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserInput>
  }

  export type TicketAttachmentUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketAttachmentWhereUniqueInput
    update: XOR<TicketAttachmentUpdateWithoutUserInput, TicketAttachmentUncheckedUpdateWithoutUserInput>
    create: XOR<TicketAttachmentCreateWithoutUserInput, TicketAttachmentUncheckedCreateWithoutUserInput>
  }

  export type TicketAttachmentUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketAttachmentWhereUniqueInput
    data: XOR<TicketAttachmentUpdateWithoutUserInput, TicketAttachmentUncheckedUpdateWithoutUserInput>
  }

  export type TicketAttachmentUpdateManyWithWhereWithoutUserInput = {
    where: TicketAttachmentScalarWhereInput
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutUserInput, TicketCommentUncheckedUpdateWithoutUserInput>
    create: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutUserInput, TicketCommentUncheckedUpdateWithoutUserInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutUserInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketHistoryWhereUniqueInput
    update: XOR<TicketHistoryUpdateWithoutUserInput, TicketHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<TicketHistoryCreateWithoutUserInput, TicketHistoryUncheckedCreateWithoutUserInput>
  }

  export type TicketHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketHistoryWhereUniqueInput
    data: XOR<TicketHistoryUpdateWithoutUserInput, TicketHistoryUncheckedUpdateWithoutUserInput>
  }

  export type TicketHistoryUpdateManyWithWhereWithoutUserInput = {
    where: TicketHistoryScalarWhereInput
    data: XOR<TicketHistoryUpdateManyMutationInput, TicketHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type ContractCreateWithoutVendorInput = {
    title: string
    contractNo: string
    startDate: Date | string
    endDate: Date | string
    amount?: number | null
    description?: string | null
    Asset?: AssetCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutVendorInput = {
    id?: number
    title: string
    contractNo: string
    startDate: Date | string
    endDate: Date | string
    amount?: number | null
    description?: string | null
    Asset?: AssetUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutVendorInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput>
  }

  export type ContractCreateManyVendorInputEnvelope = {
    data: ContractCreateManyVendorInput | ContractCreateManyVendorInput[]
  }

  export type ContractUpsertWithWhereUniqueWithoutVendorInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutVendorInput, ContractUncheckedUpdateWithoutVendorInput>
    create: XOR<ContractCreateWithoutVendorInput, ContractUncheckedCreateWithoutVendorInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutVendorInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutVendorInput, ContractUncheckedUpdateWithoutVendorInput>
  }

  export type ContractUpdateManyWithWhereWithoutVendorInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutVendorInput>
  }

  export type webmes_UserRoleCreateWithoutUserInput = {
    role: webmes_RoleCreateNestedOneWithoutUsersInput
  }

  export type webmes_UserRoleUncheckedCreateWithoutUserInput = {
    id?: number
    roleId: number
  }

  export type webmes_UserRoleCreateOrConnectWithoutUserInput = {
    where: webmes_UserRoleWhereUniqueInput
    create: XOR<webmes_UserRoleCreateWithoutUserInput, webmes_UserRoleUncheckedCreateWithoutUserInput>
  }

  export type webmes_UserRoleCreateManyUserInputEnvelope = {
    data: webmes_UserRoleCreateManyUserInput | webmes_UserRoleCreateManyUserInput[]
  }

  export type webmes_UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: webmes_UserRoleWhereUniqueInput
    update: XOR<webmes_UserRoleUpdateWithoutUserInput, webmes_UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<webmes_UserRoleCreateWithoutUserInput, webmes_UserRoleUncheckedCreateWithoutUserInput>
  }

  export type webmes_UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: webmes_UserRoleWhereUniqueInput
    data: XOR<webmes_UserRoleUpdateWithoutUserInput, webmes_UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type webmes_UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: webmes_UserRoleScalarWhereInput
    data: XOR<webmes_UserRoleUpdateManyMutationInput, webmes_UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type webmes_UserRoleScalarWhereInput = {
    AND?: webmes_UserRoleScalarWhereInput | webmes_UserRoleScalarWhereInput[]
    OR?: webmes_UserRoleScalarWhereInput[]
    NOT?: webmes_UserRoleScalarWhereInput | webmes_UserRoleScalarWhereInput[]
    id?: IntFilter<"webmes_UserRole"> | number
    userId?: IntFilter<"webmes_UserRole"> | number
    roleId?: IntFilter<"webmes_UserRole"> | number
  }

  export type webmes_RolePermissionCreateWithoutRoleInput = {
    permission: webmes_PermissionCreateNestedOneWithoutRolesInput
  }

  export type webmes_RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: number
    permissionId: number
  }

  export type webmes_RolePermissionCreateOrConnectWithoutRoleInput = {
    where: webmes_RolePermissionWhereUniqueInput
    create: XOR<webmes_RolePermissionCreateWithoutRoleInput, webmes_RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type webmes_RolePermissionCreateManyRoleInputEnvelope = {
    data: webmes_RolePermissionCreateManyRoleInput | webmes_RolePermissionCreateManyRoleInput[]
  }

  export type webmes_UserRoleCreateWithoutRoleInput = {
    user: webmes_UserCreateNestedOneWithoutRolesInput
  }

  export type webmes_UserRoleUncheckedCreateWithoutRoleInput = {
    id?: number
    userId: number
  }

  export type webmes_UserRoleCreateOrConnectWithoutRoleInput = {
    where: webmes_UserRoleWhereUniqueInput
    create: XOR<webmes_UserRoleCreateWithoutRoleInput, webmes_UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type webmes_UserRoleCreateManyRoleInputEnvelope = {
    data: webmes_UserRoleCreateManyRoleInput | webmes_UserRoleCreateManyRoleInput[]
  }

  export type webmes_RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: webmes_RolePermissionWhereUniqueInput
    update: XOR<webmes_RolePermissionUpdateWithoutRoleInput, webmes_RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<webmes_RolePermissionCreateWithoutRoleInput, webmes_RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type webmes_RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: webmes_RolePermissionWhereUniqueInput
    data: XOR<webmes_RolePermissionUpdateWithoutRoleInput, webmes_RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type webmes_RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: webmes_RolePermissionScalarWhereInput
    data: XOR<webmes_RolePermissionUpdateManyMutationInput, webmes_RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type webmes_RolePermissionScalarWhereInput = {
    AND?: webmes_RolePermissionScalarWhereInput | webmes_RolePermissionScalarWhereInput[]
    OR?: webmes_RolePermissionScalarWhereInput[]
    NOT?: webmes_RolePermissionScalarWhereInput | webmes_RolePermissionScalarWhereInput[]
    id?: IntFilter<"webmes_RolePermission"> | number
    roleId?: IntFilter<"webmes_RolePermission"> | number
    permissionId?: IntFilter<"webmes_RolePermission"> | number
  }

  export type webmes_UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: webmes_UserRoleWhereUniqueInput
    update: XOR<webmes_UserRoleUpdateWithoutRoleInput, webmes_UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<webmes_UserRoleCreateWithoutRoleInput, webmes_UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type webmes_UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: webmes_UserRoleWhereUniqueInput
    data: XOR<webmes_UserRoleUpdateWithoutRoleInput, webmes_UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type webmes_UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: webmes_UserRoleScalarWhereInput
    data: XOR<webmes_UserRoleUpdateManyMutationInput, webmes_UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type webmes_RolePermissionCreateWithoutPermissionInput = {
    role: webmes_RoleCreateNestedOneWithoutPermissionsInput
  }

  export type webmes_RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: number
    roleId: number
  }

  export type webmes_RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: webmes_RolePermissionWhereUniqueInput
    create: XOR<webmes_RolePermissionCreateWithoutPermissionInput, webmes_RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type webmes_RolePermissionCreateManyPermissionInputEnvelope = {
    data: webmes_RolePermissionCreateManyPermissionInput | webmes_RolePermissionCreateManyPermissionInput[]
  }

  export type webmes_RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: webmes_RolePermissionWhereUniqueInput
    update: XOR<webmes_RolePermissionUpdateWithoutPermissionInput, webmes_RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<webmes_RolePermissionCreateWithoutPermissionInput, webmes_RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type webmes_RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: webmes_RolePermissionWhereUniqueInput
    data: XOR<webmes_RolePermissionUpdateWithoutPermissionInput, webmes_RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type webmes_RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: webmes_RolePermissionScalarWhereInput
    data: XOR<webmes_RolePermissionUpdateManyMutationInput, webmes_RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type webmes_UserCreateWithoutRolesInput = {
    employeeId: string
    fullName: string
    department: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webmes_UserUncheckedCreateWithoutRolesInput = {
    id?: number
    employeeId: string
    fullName: string
    department: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webmes_UserCreateOrConnectWithoutRolesInput = {
    where: webmes_UserWhereUniqueInput
    create: XOR<webmes_UserCreateWithoutRolesInput, webmes_UserUncheckedCreateWithoutRolesInput>
  }

  export type webmes_RoleCreateWithoutUsersInput = {
    name: string
    description?: string | null
    permissions?: webmes_RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type webmes_RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    permissions?: webmes_RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type webmes_RoleCreateOrConnectWithoutUsersInput = {
    where: webmes_RoleWhereUniqueInput
    create: XOR<webmes_RoleCreateWithoutUsersInput, webmes_RoleUncheckedCreateWithoutUsersInput>
  }

  export type webmes_UserUpsertWithoutRolesInput = {
    update: XOR<webmes_UserUpdateWithoutRolesInput, webmes_UserUncheckedUpdateWithoutRolesInput>
    create: XOR<webmes_UserCreateWithoutRolesInput, webmes_UserUncheckedCreateWithoutRolesInput>
    where?: webmes_UserWhereInput
  }

  export type webmes_UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: webmes_UserWhereInput
    data: XOR<webmes_UserUpdateWithoutRolesInput, webmes_UserUncheckedUpdateWithoutRolesInput>
  }

  export type webmes_UserUpdateWithoutRolesInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webmes_UserUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webmes_RoleUpsertWithoutUsersInput = {
    update: XOR<webmes_RoleUpdateWithoutUsersInput, webmes_RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<webmes_RoleCreateWithoutUsersInput, webmes_RoleUncheckedCreateWithoutUsersInput>
    where?: webmes_RoleWhereInput
  }

  export type webmes_RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: webmes_RoleWhereInput
    data: XOR<webmes_RoleUpdateWithoutUsersInput, webmes_RoleUncheckedUpdateWithoutUsersInput>
  }

  export type webmes_RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: webmes_RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type webmes_RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: webmes_RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type webmes_RoleCreateWithoutPermissionsInput = {
    name: string
    description?: string | null
    users?: webmes_UserRoleCreateNestedManyWithoutRoleInput
  }

  export type webmes_RoleUncheckedCreateWithoutPermissionsInput = {
    id?: number
    name: string
    description?: string | null
    users?: webmes_UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type webmes_RoleCreateOrConnectWithoutPermissionsInput = {
    where: webmes_RoleWhereUniqueInput
    create: XOR<webmes_RoleCreateWithoutPermissionsInput, webmes_RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type webmes_PermissionCreateWithoutRolesInput = {
    name: string
    module: string
  }

  export type webmes_PermissionUncheckedCreateWithoutRolesInput = {
    id?: number
    name: string
    module: string
  }

  export type webmes_PermissionCreateOrConnectWithoutRolesInput = {
    where: webmes_PermissionWhereUniqueInput
    create: XOR<webmes_PermissionCreateWithoutRolesInput, webmes_PermissionUncheckedCreateWithoutRolesInput>
  }

  export type webmes_RoleUpsertWithoutPermissionsInput = {
    update: XOR<webmes_RoleUpdateWithoutPermissionsInput, webmes_RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<webmes_RoleCreateWithoutPermissionsInput, webmes_RoleUncheckedCreateWithoutPermissionsInput>
    where?: webmes_RoleWhereInput
  }

  export type webmes_RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: webmes_RoleWhereInput
    data: XOR<webmes_RoleUpdateWithoutPermissionsInput, webmes_RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type webmes_RoleUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: webmes_UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type webmes_RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: webmes_UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type webmes_PermissionUpsertWithoutRolesInput = {
    update: XOR<webmes_PermissionUpdateWithoutRolesInput, webmes_PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<webmes_PermissionCreateWithoutRolesInput, webmes_PermissionUncheckedCreateWithoutRolesInput>
    where?: webmes_PermissionWhereInput
  }

  export type webmes_PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: webmes_PermissionWhereInput
    data: XOR<webmes_PermissionUpdateWithoutRolesInput, webmes_PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type webmes_PermissionUpdateWithoutRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
  }

  export type webmes_PermissionUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
  }

  export type AssetHistoryCreateManyAssetInput = {
    oldOwnerId?: number | null
    newOwnerId?: number | null
    changedAt?: Date | string
    reason?: string | null
  }

  export type LicenseCreateManyAssetInput = {
    softwareName: string
    licenseKey: string
    expireDate: Date | string
  }

  export type TicketCreateManyAssetInput = {
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    requestedById: number
    assignedToId?: number | null
  }

  export type AssetHistoryUpdateWithoutAssetInput = {
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    User_AssetHistory_newOwnerIdToUser?: UserUpdateOneWithoutAssetHistory_AssetHistory_newOwnerIdToUserNestedInput
    User_AssetHistory_oldOwnerIdToUser?: UserUpdateOneWithoutAssetHistory_AssetHistory_oldOwnerIdToUserNestedInput
  }

  export type AssetHistoryUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    oldOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    newOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetHistoryUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    oldOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    newOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LicenseUpdateWithoutAssetInput = {
    softwareName?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    expireDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    softwareName?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    expireDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    softwareName?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    expireDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutAssetInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutTicketNestedInput
    User_Ticket_assignedToIdToUser?: UserUpdateOneWithoutTicket_Ticket_assignedToIdToUserNestedInput
    User_Ticket_requestedByIdToUser?: UserUpdateOneRequiredWithoutTicket_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutTicketNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutTicketNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractUpdateWithoutAssetInput = {
    title?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Vendor?: VendorUpdateOneRequiredWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
  }

  export type ContractUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
  }

  export type AssetUpdateWithoutContractInput = {
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutAssetNestedInput
    AssetHistory?: AssetHistoryUpdateManyWithoutAssetNestedInput
    License?: LicenseUpdateManyWithoutAssetNestedInput
    Monitor?: MonitorUpdateOneWithoutAssetNestedInput
    Ticket?: TicketUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    AssetHistory?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
    License?: LicenseUncheckedUpdateManyWithoutAssetNestedInput
    Monitor?: MonitorUncheckedUpdateOneWithoutAssetNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type employeesCreateManyDepartmentsInput = {
    first_name: string
    last_name: string
    employee_code: string
    is_dept_head?: boolean
    is_active?: boolean
  }

  export type employeesUpdateWithoutDepartmentsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    employee_roles?: employee_rolesUpdateManyWithoutEmployeesNestedInput
  }

  export type employeesUncheckedUpdateWithoutDepartmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    employee_roles?: employee_rolesUncheckedUpdateManyWithoutEmployeesNestedInput
  }

  export type employeesUncheckedUpdateManyWithoutDepartmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type employee_rolesCreateManyEmployeesInput = {
    role_id: number
  }

  export type employee_rolesUpdateWithoutEmployeesInput = {
    roles?: rolesUpdateOneRequiredWithoutEmployee_rolesNestedInput
  }

  export type employee_rolesUncheckedUpdateWithoutEmployeesInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type employee_rolesUncheckedUpdateManyWithoutEmployeesInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryItemCreateManyInventoryCategoryInput = {
    name: string
    description?: string | null
    barcode?: string | null
    serialNumber?: string | null
    supplierId?: number | null
    stock?: number
    minStock?: number
    unit?: string | null
    imagePath?: string | null
  }

  export type InventoryItemUpdateWithoutInventoryCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    InventorySupplier?: InventorySupplierUpdateOneWithoutInventoryItemNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutInventoryCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutInventoryCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryTransactionCreateManyInventoryItemInput = {
    type: string
    qty: number
    userId?: number | null
    date?: Date | string
    note?: string | null
    barcode?: string | null
  }

  export type InventoryTransactionUpdateWithoutInventoryItemInput = {
    type?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneWithoutInventoryTransactionNestedInput
  }

  export type InventoryTransactionUncheckedUpdateWithoutInventoryItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutInventoryItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryItemCreateManyInventorySupplierInput = {
    name: string
    description?: string | null
    barcode?: string | null
    serialNumber?: string | null
    categoryId: number
    stock?: number
    minStock?: number
    unit?: string | null
    imagePath?: string | null
  }

  export type InventoryItemUpdateWithoutInventorySupplierInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    InventoryCategory?: InventoryCategoryUpdateOneRequiredWithoutInventoryItemNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutInventorySupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutInventorySupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type it_employeesCreateManyIt_departmentsInput = {
    first_name: string
    last_name: string
    employee_code: string
    is_dept_head?: boolean
    is_active?: boolean
  }

  export type it_employeesUpdateWithoutIt_departmentsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    it_employee_roles?: it_employee_rolesUpdateManyWithoutIt_employeesNestedInput
  }

  export type it_employeesUncheckedUpdateWithoutIt_departmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    it_employee_roles?: it_employee_rolesUncheckedUpdateManyWithoutIt_employeesNestedInput
  }

  export type it_employeesUncheckedUpdateManyWithoutIt_departmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    employee_code?: StringFieldUpdateOperationsInput | string
    is_dept_head?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type it_employee_rolesCreateManyIt_employeesInput = {
    role_id: number
  }

  export type it_employee_rolesUpdateWithoutIt_employeesInput = {
    it_roles?: it_rolesUpdateOneRequiredWithoutIt_employee_rolesNestedInput
  }

  export type it_employee_rolesUncheckedUpdateWithoutIt_employeesInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type it_employee_rolesUncheckedUpdateManyWithoutIt_employeesInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type it_employee_rolesCreateManyIt_rolesInput = {
    employee_id: number
  }

  export type it_employee_rolesUpdateWithoutIt_rolesInput = {
    it_employees?: it_employeesUpdateOneRequiredWithoutIt_employee_rolesNestedInput
  }

  export type it_employee_rolesUncheckedUpdateWithoutIt_rolesInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
  }

  export type it_employee_rolesUncheckedUpdateManyWithoutIt_rolesInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
  }

  export type employee_rolesCreateManyRolesInput = {
    employee_id: number
  }

  export type employee_rolesUpdateWithoutRolesInput = {
    employees?: employeesUpdateOneRequiredWithoutEmployee_rolesNestedInput
  }

  export type employee_rolesUncheckedUpdateWithoutRolesInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
  }

  export type employee_rolesUncheckedUpdateManyWithoutRolesInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
  }

  export type KnowledgeBaseCreateManyTicketInput = {
    title: string
    content: string
    category?: string | null
    tags?: string | null
    isPublic?: boolean
    createdById: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TicketAttachmentCreateManyTicketInput = {
    fileName: string
    filePath: string
    uploadedAt?: Date | string
    uploadedById: number
  }

  export type TicketCommentCreateManyTicketInput = {
    content: string
    createdAt?: Date | string
    createdById: number
  }

  export type TicketHistoryCreateManyTicketInput = {
    oldStatus: string
    newStatus: string
    changedById: number
    changedAt?: Date | string
    note?: string | null
  }

  export type KnowledgeBaseUpdateWithoutTicketInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutKnowledgeBaseNestedInput
  }

  export type KnowledgeBaseUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUpdateWithoutTicketInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutTicketAttachmentNestedInput
  }

  export type TicketAttachmentUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: IntFieldUpdateOperationsInput | number
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: IntFieldUpdateOperationsInput | number
  }

  export type TicketCommentUpdateWithoutTicketInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutTicketCommentNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type TicketHistoryUpdateWithoutTicketInput = {
    oldStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneRequiredWithoutTicketHistoryNestedInput
  }

  export type TicketHistoryUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    oldStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedById?: IntFieldUpdateOperationsInput | number
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketHistoryUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    oldStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedById?: IntFieldUpdateOperationsInput | number
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetCreateManyUserInput = {
    name: string
    serialNumber: string
    assetTag?: string | null
    type: string
    brand?: string | null
    model?: string | null
    spec?: string | null
    purchaseDate?: Date | string | null
    warrantyUntil?: Date | string | null
    location?: string | null
    status?: string
  }

  export type AssetHistoryCreateManyUser_AssetHistory_newOwnerIdToUserInput = {
    assetId: number
    oldOwnerId?: number | null
    changedAt?: Date | string
    reason?: string | null
  }

  export type AssetHistoryCreateManyUser_AssetHistory_oldOwnerIdToUserInput = {
    assetId: number
    newOwnerId?: number | null
    changedAt?: Date | string
    reason?: string | null
  }

  export type AuditLogCreateManyUserInput = {
    action: string
    tableName: string
    recordId?: number | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type DocumentCreateManyUserInput = {
    name: string
    filePath: string
    version: string
    permission: string
    createdAt?: Date | string
  }

  export type InventoryTransactionCreateManyUserInput = {
    itemId: number
    type: string
    qty: number
    date?: Date | string
    note?: string | null
    barcode?: string | null
  }

  export type KnowledgeBaseCreateManyUserInput = {
    title: string
    content: string
    category?: string | null
    tags?: string | null
    isPublic?: boolean
    linkedTicketId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TicketCreateManyUser_Ticket_assignedToIdToUserInput = {
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    assetId?: number | null
    requestedById: number
  }

  export type TicketCreateManyUser_Ticket_requestedByIdToUserInput = {
    title: string
    description: string
    resolutionNote?: string | null
    status?: string
    createdAt?: Date | string
    assetId?: number | null
    assignedToId?: number | null
  }

  export type TicketAttachmentCreateManyUserInput = {
    fileName: string
    filePath: string
    uploadedAt?: Date | string
    ticketId: number
  }

  export type TicketCommentCreateManyUserInput = {
    content: string
    createdAt?: Date | string
    ticketId: number
  }

  export type TicketHistoryCreateManyUserInput = {
    ticketId: number
    oldStatus: string
    newStatus: string
    changedAt?: Date | string
    note?: string | null
  }

  export type AssetUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    AssetHistory?: AssetHistoryUpdateManyWithoutAssetNestedInput
    License?: LicenseUpdateManyWithoutAssetNestedInput
    Monitor?: MonitorUpdateOneWithoutAssetNestedInput
    Ticket?: TicketUpdateManyWithoutAssetNestedInput
    Contract?: ContractUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    AssetHistory?: AssetHistoryUncheckedUpdateManyWithoutAssetNestedInput
    License?: LicenseUncheckedUpdateManyWithoutAssetNestedInput
    Monitor?: MonitorUncheckedUpdateOneWithoutAssetNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutAssetNestedInput
    Contract?: ContractUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    assetTag?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AssetHistoryUpdateWithoutUser_AssetHistory_newOwnerIdToUserInput = {
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateOneRequiredWithoutAssetHistoryNestedInput
    User_AssetHistory_oldOwnerIdToUser?: UserUpdateOneWithoutAssetHistory_AssetHistory_oldOwnerIdToUserNestedInput
  }

  export type AssetHistoryUncheckedUpdateWithoutUser_AssetHistory_newOwnerIdToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    oldOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_newOwnerIdToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    oldOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetHistoryUpdateWithoutUser_AssetHistory_oldOwnerIdToUserInput = {
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateOneRequiredWithoutAssetHistoryNestedInput
    User_AssetHistory_newOwnerIdToUser?: UserUpdateOneWithoutAssetHistory_AssetHistory_newOwnerIdToUserNestedInput
  }

  export type AssetHistoryUncheckedUpdateWithoutUser_AssetHistory_oldOwnerIdToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    newOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetHistoryUncheckedUpdateManyWithoutUser_AssetHistory_oldOwnerIdToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    newOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableIntFieldUpdateOperationsInput | number | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableIntFieldUpdateOperationsInput | number | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: NullableIntFieldUpdateOperationsInput | number | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    InventoryItem?: InventoryItemUpdateOneRequiredWithoutInventoryTransactionNestedInput
  }

  export type InventoryTransactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KnowledgeBaseUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ticket?: TicketUpdateOneWithoutKnowledgeBaseNestedInput
  }

  export type KnowledgeBaseUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    linkedTicketId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    linkedTicketId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutUser_Ticket_assignedToIdToUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutTicketNestedInput
    Asset?: AssetUpdateOneWithoutTicketNestedInput
    User_Ticket_requestedByIdToUser?: UserUpdateOneRequiredWithoutTicket_Ticket_requestedByIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutTicketNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutUser_Ticket_assignedToIdToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedById?: IntFieldUpdateOperationsInput | number
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutTicketNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutUser_Ticket_assignedToIdToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedById?: IntFieldUpdateOperationsInput | number
  }

  export type TicketUpdateWithoutUser_Ticket_requestedByIdToUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    KnowledgeBase?: KnowledgeBaseUpdateManyWithoutTicketNestedInput
    Asset?: AssetUpdateOneWithoutTicketNestedInput
    User_Ticket_assignedToIdToUser?: UserUpdateOneWithoutTicket_Ticket_assignedToIdToUserNestedInput
    TicketAttachment?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    TicketComment?: TicketCommentUpdateManyWithoutTicketNestedInput
    TicketHistory?: TicketHistoryUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutUser_Ticket_requestedByIdToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    KnowledgeBase?: KnowledgeBaseUncheckedUpdateManyWithoutTicketNestedInput
    TicketAttachment?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    TicketComment?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
    TicketHistory?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutUser_Ticket_requestedByIdToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TicketAttachmentUpdateWithoutUserInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ticket?: TicketUpdateOneRequiredWithoutTicketAttachmentNestedInput
  }

  export type TicketAttachmentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketCommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ticket?: TicketUpdateOneRequiredWithoutTicketCommentNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketCommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketHistoryUpdateWithoutUserInput = {
    oldStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    Ticket?: TicketUpdateOneRequiredWithoutTicketHistoryNestedInput
  }

  export type TicketHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    oldStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    oldStatus?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractCreateManyVendorInput = {
    title: string
    contractNo: string
    startDate: Date | string
    endDate: Date | string
    amount?: number | null
    description?: string | null
  }

  export type ContractUpdateWithoutVendorInput = {
    title?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Asset?: AssetUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type webmes_UserRoleCreateManyUserInput = {
    roleId: number
  }

  export type webmes_UserRoleUpdateWithoutUserInput = {
    role?: webmes_RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type webmes_UserRoleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type webmes_UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type webmes_RolePermissionCreateManyRoleInput = {
    permissionId: number
  }

  export type webmes_UserRoleCreateManyRoleInput = {
    userId: number
  }

  export type webmes_RolePermissionUpdateWithoutRoleInput = {
    permission?: webmes_PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type webmes_RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type webmes_RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type webmes_UserRoleUpdateWithoutRoleInput = {
    user?: webmes_UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type webmes_UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type webmes_UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type webmes_RolePermissionCreateManyPermissionInput = {
    roleId: number
  }

  export type webmes_RolePermissionUpdateWithoutPermissionInput = {
    role?: webmes_RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type webmes_RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type webmes_RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AssetCountOutputTypeDefaultArgs instead
     */
    export type AssetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractCountOutputTypeDefaultArgs instead
     */
    export type ContractCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentsCountOutputTypeDefaultArgs instead
     */
    export type DepartmentsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeesCountOutputTypeDefaultArgs instead
     */
    export type EmployeesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryCategoryCountOutputTypeDefaultArgs instead
     */
    export type InventoryCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryItemCountOutputTypeDefaultArgs instead
     */
    export type InventoryItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventorySupplierCountOutputTypeDefaultArgs instead
     */
    export type InventorySupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventorySupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use It_departmentsCountOutputTypeDefaultArgs instead
     */
    export type It_departmentsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = It_departmentsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use It_employeesCountOutputTypeDefaultArgs instead
     */
    export type It_employeesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = It_employeesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use It_rolesCountOutputTypeDefaultArgs instead
     */
    export type It_rolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = It_rolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolesCountOutputTypeDefaultArgs instead
     */
    export type RolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketCountOutputTypeDefaultArgs instead
     */
    export type TicketCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorCountOutputTypeDefaultArgs instead
     */
    export type VendorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Webmes_UserCountOutputTypeDefaultArgs instead
     */
    export type Webmes_UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Webmes_UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Webmes_RoleCountOutputTypeDefaultArgs instead
     */
    export type Webmes_RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Webmes_RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Webmes_PermissionCountOutputTypeDefaultArgs instead
     */
    export type Webmes_PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Webmes_PermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetDefaultArgs instead
     */
    export type AssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetHistoryDefaultArgs instead
     */
    export type AssetHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractDefaultArgs instead
     */
    export type ContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractDefaultArgs<ExtArgs>
    /**
     * @deprecated Use departmentsDefaultArgs instead
     */
    export type departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = departmentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use employee_rolesDefaultArgs instead
     */
    export type employee_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = employee_rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use employeesDefaultArgs instead
     */
    export type employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = employeesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryCategoryDefaultArgs instead
     */
    export type InventoryCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryItemDefaultArgs instead
     */
    export type InventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventorySupplierDefaultArgs instead
     */
    export type InventorySupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventorySupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryTransactionDefaultArgs instead
     */
    export type InventoryTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use it_departmentsDefaultArgs instead
     */
    export type it_departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = it_departmentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use it_employee_rolesDefaultArgs instead
     */
    export type it_employee_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = it_employee_rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use it_employeesDefaultArgs instead
     */
    export type it_employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = it_employeesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use it_rolesDefaultArgs instead
     */
    export type it_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = it_rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KnowledgeBaseDefaultArgs instead
     */
    export type KnowledgeBaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KnowledgeBaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LicenseDefaultArgs instead
     */
    export type LicenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LicenseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MonitorDefaultArgs instead
     */
    export type MonitorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MonitorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rolesDefaultArgs instead
     */
    export type rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketDefaultArgs instead
     */
    export type TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketAttachmentDefaultArgs instead
     */
    export type TicketAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketAttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketCommentDefaultArgs instead
     */
    export type TicketCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketHistoryDefaultArgs instead
     */
    export type TicketHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorDefaultArgs instead
     */
    export type VendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use webmes_UserDefaultArgs instead
     */
    export type webmes_UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = webmes_UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use webmes_RoleDefaultArgs instead
     */
    export type webmes_RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = webmes_RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use webmes_PermissionDefaultArgs instead
     */
    export type webmes_PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = webmes_PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use webmes_UserRoleDefaultArgs instead
     */
    export type webmes_UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = webmes_UserRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use webmes_RolePermissionDefaultArgs instead
     */
    export type webmes_RolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = webmes_RolePermissionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}